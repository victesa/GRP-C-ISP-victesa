import { fail } from "@jsr/std__assert/fail";
import * as types from "./data-model/mod.js";
import { getActualSelector, predicateProto, QUERIES_WITH_PAYLOAD, selectorProto } from "./query-internal.js";
export * from "./query-types.js";
const DEFAULT_SELECTOR = [
  {
    kind: 'Atom'
  }
];
function buildQueryParams(params) {
  return {
    fetchSize: params?.fetchSize?.map(BigInt) ?? null,
    pagination: {
      offset: params?.offset ? BigInt(params.offset) : 0n,
      limit: params?.limit?.map(BigInt) ?? null
    },
    sorting: {
      sortByMetadataKey: params?.sorting?.byMetadataKey ?? null
    }
  };
}
/**
 * Utility to build queries in a safe and convenient way.
 *
 * It is a lower-level utility that only builds queries. For the higher-level
 * implementation which actually sends the queries, see `QueryBuilder` from `@iroha/client` package.
 */ export class QueryBuilder {
  kind;
  payload;
  params;
  selector = DEFAULT_SELECTOR;
  predicate = types.CompoundPredicate.PASS;
  parseOutput = generateOutputTuples;
  constructor(...args){
    this.kind = args[0];
    if (QUERIES_WITH_PAYLOAD.has(this.kind)) {
      ;
      [this.payload, this.params] = args.length === 2 ? [
        args[1],
        buildQueryParams()
      ] : args.length === 3 ? [
        args[1],
        buildQueryParams(args[2])
      ] : fail('bad arguments');
    } else {
      ;
      [this.payload, this.params] = // @ts-expect-error it doesn't understand that there is an optional param
      args.length === 1 ? [
        null,
        buildQueryParams()
      ] : args.length === 2 ? [
        null,
        buildQueryParams(args[1])
      ] : fail('bad arguments');
    }
  }
  /**
   * Specify selected tuple with a _prototype_ of the querying object.
   *
   * @example Select a single value
   *
   * ```ts
   * import * as types from '@iroha/core/data-model'
   *
   * const builder: QueryBuilder<'FindAccounts', types.DomainId> =
   *   new QueryBuilder('FindAccounts')
   *     .selectWith((account) => account.id.domain)
   * ```
   *
   * @example Select multiple values
   *
   * ```ts
   * import * as types from '@iroha/core/data-model'
   *
   * const builder: QueryBuilder<'FindTransactions', [types.Hash, null | types.TransactionRejectionReason]> =
   *   new QueryBuilder('FindTransactions')
   *     .selectWith((tx) => [tx.value.hash, tx.error])
   * ```
   */ selectWith(fn) {
    const proto = selectorProto();
    const protoTuple = fn(proto);
    this.selector = protoTupleIntoActualSelector(protoTuple);
    return this;
  }
  /**
   * Specify predicate with a _prototype_ of the querying object.
   *
   * The returned type must be a variant {@linkcode [data-model].CompoundPredicate | CompoundPredicate} containing
   * the actual predicate.
   *
   * @example Specifying a compound logical predicate
   *
   * ```ts
   * import * as types from '@iroha/core/data-model'
   *
   * new QueryBuilder('FindAccounts')
   *   .filterWith((account) => types.CompoundPredicate.Or(
   *     types.CompoundPredicate.Atom(account.id.domain.name.startsWith('wonder')),
   *     types.CompoundPredicate.Atom(account.id.domain.name.endsWith('land')),
   *   ))
   * ```
   */ filterWith(fn) {
    const proto = predicateProto();
    this.predicate = fn(proto);
    return this;
  }
  build() {
    return {
      query: {
        kind: this.kind,
        value: {
          query: this.payload,
          predicate: this.predicate,
          selector: this.selector
        }
      },
      params: this.params
    };
  }
}
function protoTupleIntoActualSelector(tuple) {
  if (Array.isArray(tuple)) {
    return tuple.map((x)=>getActualSelector(x));
  }
  return [
    getActualSelector(tuple)
  ];
}
function* generateOutputTuples(response) {
  // FIXME: this is redundant in runtime, just a safe guard
  //   invariant(
  //     response.length === tuple.length,
  //     () => `Expected response to have exactly ${tuple.length} elements, got ${response.length}`,
  //   )
  //   for (let i = 0; i < tuple.length; i++) {
  //     invariant(
  //       response[i].kind === tuple[i],
  //       () => `Expected response to have type ${tuple[i]} at element ${i}, got ${response[i].kind}`,
  //     )
  //   }
  const len = response[0].value.length;
  const tupleLen = response.length;
  for(let i = 0; i < len; i++){
    if (tupleLen === 1) yield response[0].value[i];
    else yield Array.from({
      length: tupleLen
    }, (_v, j)=>response[j].value[i]);
  }
}
//# sourceMappingURL=query.js.map
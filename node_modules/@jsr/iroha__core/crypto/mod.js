/**
 * Port of `iroha_crypto` into WebAssembly.
 *
 * ## Compatibility
 *
 * Compatible with all runtimes.
 *
 * Since `0.3.0`, the `.wasm` blob __is inlined__. Therefore, it is compatible with any
 * runtime that supports {@linkcode WebAssembly} (e.g. see
 * [compatibility on MDN](https://developer.mozilla.org/en-US/docs/WebAssembly/Reference/JavaScript_interface/Instance/Instance#browser_compatibility)).
 *
 * This wasn't the case for `0.2.0`: it relied on `.wasm` ES Module Imports, which isn't widely supported (yet).
 *
 * @example Deriving a KeyPair from seed
 * ```ts
 * import { Bytes } from '@iroha/core/crypto'
 * import { assertEquals } from '@std/assert/equals'
 *
 * const kp = KeyPair.deriveFromSeed(Bytes.hex('001122'))
 *
 * assertEquals(kp.privateKey().multihash(), '8026205720A4B3BFFA5C9BBD83D09C88CD1DB08CA3F0C302EC4C8C37A26BD734C37616')
 * ```
 *
 * @example Constructing a private key from a multihash
 * ```ts
 * import { assertEquals } from '@std/assert/equals'
 *
 * const pk = PrivateKey.fromMultihash('8026205720A4B3BFFA5C9BBD83D09C88CD1DB08CA3F0C302EC4C8C37A26BD734C37616')
 *
 * assertEquals(pk.algorithm, 'ed25519')
 * ```
 *
 * @module
 */ import { Bytes } from "./util.js";
import { defineCodec, getCodec, SYMBOL_CODEC } from "../codec.js";
import { ordCompare } from "../traits.js";
import { enumCodec, GenCodec, structCodec } from "../codec.js";
import * as scale from "@scale-codec/core";
import { BytesVec } from "../data-model/primitives.js";
import * as wasm from './wasm/iroha_crypto_wasm.js';
export { Bytes };
const AlgorithmCodec = defineCodec(enumCodec({
  ed25519: [
    0
  ],
  secp256k1: [
    1
  ],
  bls_normal: [
    2
  ],
  bls_small: [
    3
  ]
}).literalUnion());
export const Algorithm = {
  ed25519: 'ed25519',
  secp256k1: 'secp256k1',
  bls_normal: 'bls_normal',
  bls_small: 'bls_small',
  default: ()=>wasm.algorithm_default(),
  ...AlgorithmCodec
};
const HASH_ARR_LEN = 32;
/**
 * Cryptographic hash used in Iroha (blake2b-32).
 *
 * ```ts
 * import { assertEquals } from '@std/assert'
 *
 * const hash = Hash.hash(Bytes.hex("01020304"))
 * assertEquals(hash.payload.hex(), '28517e4cdf6c90798c1a983b03727ca7743c21a3880672429ccfc5bd15ea5f73')
 * ```
 */ export class Hash {
  static [SYMBOL_CODEC] = new GenCodec({
    encode: scale.createUint8ArrayEncoder(HASH_ARR_LEN),
    decode: scale.createUint8ArrayDecoder(HASH_ARR_LEN)
  }).wrap({
    fromBase: (lower)=>Hash.fromRaw(Bytes.array(lower)),
    toBase: (higher)=>higher.payload.array()
  });
  /**
   * Create an hash filled with zeros.
   */ static zeroed() {
    return new Hash(wasm.Hash.zeroed(), null);
  }
  /**
   * Create by hashing the input.
   * @param input the input to hash
   * @returns the resulting hash
   */ static hash(input) {
    const repr = input.repr;
    const inner = repr.t === 'hex' ? wasm.Hash.hash_hex(repr.hex) : wasm.Hash.hash(repr.array);
    return new Hash(inner, null);
  }
  /**
   * Construct hash from "prehashed" data
   * @param payload payload of an actual hash
   * @returns hash
   */ static fromRaw(payload) {
    return new Hash(null, payload);
  }
  #wasm;
  #payload;
  constructor(wasm, payload){
    this.#wasm = wasm;
    this.#payload = payload;
  }
  get payload() {
    if (this.#payload) return this.#payload;
    return Bytes.array(this.#wasm.payload());
  }
  toJSON() {
    return this.payload.hex();
  }
}
/**
 * Private key used in Iroha (used for signing).
 *
 * @example
 *
 * ```ts
 * import { assertEquals } from '@std/assert'
 *
 * const multihash = '80262001F2DB2416255E79DB67D5AC807E55459ED8754F07586864948AEA00F6F81763'
 * const key = PrivateKey.fromMultihash(multihash)
 * assertEquals(key.multihash(), multihash)
 * assertEquals(key.algorithm, 'ed25519')
 * assertEquals(key.payload.hex(), '01f2db2416255e79db67d5ac807e55459ed8754f07586864948aea00f6f81763')
 *
 * const signature = key.sign(Bytes.array(new TextEncoder().encode('my message')))
 * ```
 */ export class PrivateKey {
  /**
   * Create from a multihash string.
   */ static fromMultihash(multihash) {
    return new PrivateKey(wasm.PrivateKey.from_multihash_hex(multihash));
  }
  static fromKeyPair(pair) {
    return new PrivateKey(pair.wasm.private_key());
  }
  static fromParts(algorithm, payload) {
    const repr = payload.repr;
    const inner = repr.t === 'hex' ? wasm.PrivateKey.from_raw_hex(algorithm, repr.hex) : wasm.PrivateKey.from_raw(algorithm, repr.array);
    return new PrivateKey(inner);
  }
  #wasm;
  constructor(wasm){
    this.#wasm = wasm;
  }
  get algorithm() {
    return this.#wasm.algorithm;
  }
  get payload() {
    return Bytes.array(this.#wasm.payload());
  }
  /**
   * Get multihash representation.
   * @returns multihash
   */ multihash() {
    return this.#wasm.to_multihash_hex();
  }
  /**
   * Sign a given message with this private key.
   * @param message any binary data
   * @returns the signature
   */ sign(message) {
    return Signature.sign(this, message);
  }
  /**
   * @internal
   */ get wasm() {
    return this.#wasm;
  }
  toJSON() {
    return this.multihash();
  }
}
/**
 * Public key used in Iroha (used for verification).
 */ export class PublicKey {
  static [SYMBOL_CODEC] = structCodec([
    'algorithm',
    'payload'
  ], {
    algorithm: getCodec(Algorithm),
    payload: getCodec(BytesVec).wrap({
      toBase: (x)=>x.array(),
      fromBase: (x)=>Bytes.array(x)
    })
  }).wrap({
    toBase: (higher)=>higher,
    fromBase: (x)=>PublicKey.fromParts(x.algorithm, x.payload)
  });
  static fromMultihash(multihash) {
    const key = wasm.PublicKey.from_multihash_hex(multihash);
    return new PublicKey(key);
  }
  /**
   * Derive public key from its corresponding private key
   */ static fromPrivateKey(privateKey) {
    const key = wasm.PublicKey.from_private_key(privateKey.wasm);
    return new PublicKey(key);
  }
  static fromKeyPair(pair) {
    return new PublicKey(pair.wasm.public_key());
  }
  static fromParts(algorithm, payload) {
    const repr = payload.repr;
    const inner = repr.t === 'hex' ? wasm.PublicKey.from_raw_hex(algorithm, repr.hex) : wasm.PublicKey.from_raw(algorithm, repr.array);
    return new PublicKey(inner);
  }
  #wasm;
  constructor(wasm){
    this.#wasm = wasm;
  }
  get algorithm() {
    return this.#wasm.algorithm;
  }
  get payload() {
    return Bytes.array(this.#wasm.payload());
  }
  get wasm() {
    return this.#wasm;
  }
  multihash() {
    return this.#wasm.to_multihash_hex();
  }
  /**
   * Verify the signature of a given message
   * @param signature signature of the message, that was created using the private key
   * @param message the message itself
   */ verify(signature, message) {
    signature.verify(this, message);
  }
  /**
   * @deprecated use {@linkcode PublicKey.verify}
   */ verifySignature(signature, message) {
    signature.verify(this, message);
  }
  compare(other) {
    return ordCompare(this.multihash(), other.multihash());
  }
  toJSON() {
    return this.multihash();
  }
}
export class KeyPair {
  /**
   * Generate a random key pair.
   */ static random(options) {
    const pair = wasm.KeyPair.random(options?.algorithm);
    return new KeyPair(pair);
  }
  /**
   * Derive the key pair from the given seed.
   * @param seed some binary data.
   * @param options key generation options
   */ static deriveFromSeed(seed, options) {
    const algorithm = options?.algorithm;
    const repr = seed.repr;
    const inner = repr.t === 'hex' ? wasm.KeyPair.derive_from_seed_hex(repr.hex, algorithm) : wasm.KeyPair.derive_from_seed(repr.array, algorithm);
    return new KeyPair(inner);
  }
  static deriveFromPrivateKey(private_key) {
    const pair = wasm.KeyPair.derive_from_private_key(private_key.wasm);
    return new KeyPair(pair);
  }
  static fromParts(publicKey, privateKey) {
    return new KeyPair(wasm.KeyPair.from_parts(publicKey.wasm, privateKey.wasm));
  }
  #wasm;
  constructor(wasm){
    this.#wasm = wasm;
  }
  get algorithm() {
    return this.#wasm.algorithm;
  }
  privateKey() {
    return PrivateKey.fromKeyPair(this);
  }
  publicKey() {
    return PublicKey.fromKeyPair(this);
  }
  /**
   * @internal
   */ get wasm() {
    return this.#wasm;
  }
  toJSON() {
    return {
      publicKey: this.publicKey(),
      privateKey: this.privateKey()
    };
  }
}
export class Signature {
  static [SYMBOL_CODEC] = getCodec(BytesVec).wrap({
    toBase: (higher)=>higher.payload.array(),
    fromBase: (lower)=>Signature.fromRaw(Bytes.array(lower))
  });
  /**
   * Create a signature from its payload and public key. This function **does not sign the payload**.
   */ static fromRaw(payload) {
    const repr = payload.repr;
    const inner = repr.t === 'hex' ? wasm.Signature.from_raw_hex(repr.hex) : wasm.Signature.from_raw(repr.array);
    return new Signature(inner);
  }
  /**
   * @deprecated use {@linkcode Signature.sign}
   */ static create(privateKey, payload) {
    return Signature.sign(privateKey, payload);
  }
  /**
   * Creates an actual signature, signing the payload with the given private key
   */ static sign(privateKey, payload) {
    const repr = payload.repr;
    const inner = repr.t === 'hex' ? wasm.Signature.sign_hex(privateKey.wasm, repr.hex) : wasm.Signature.sign(privateKey.wasm, repr.array);
    return new Signature(inner);
  }
  #wasm;
  constructor(wasm){
    this.#wasm = wasm;
  }
  /**
   * Verify that this signature is produced for the given payload by the given key (its public part)
   */ verify(publicKey, payload) {
    const repr = payload.repr;
    repr.t === 'hex' ? this.#wasm.verify_hex(publicKey.wasm, repr.hex) : this.#wasm.verify(publicKey.wasm, repr.array);
  }
  get payload() {
    return Bytes.array(this.#wasm.payload());
  }
  toJSON() {
    return this.payload.hex();
  }
}
//# sourceMappingURL=mod.js.map
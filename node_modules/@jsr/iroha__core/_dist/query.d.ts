import * as types from "./data-model/mod.js";
import type * as prototypes from "./data-model/prototypes.generated.js";
import type { GetQueryPayload, PredicateOf, QueryKind, SelectedTuple } from "./query-types.js";
export * from "./query-types.js";
export type QueryBuilderCtorArgs<Q extends QueryKind> = GetQueryPayload<Q> extends infer P ? P extends null ? [query: Q, params?: QueryBuilderParams] : [query: Q, payload: P, params?: QueryBuilderParams] : never;
export type DefaultQueryOutput<Q extends QueryKind> = SelectedTuple<prototypes.QuerySelectors[Q]>;
/**
 * Utility to build queries in a safe and convenient way.
 *
 * It is a lower-level utility that only builds queries. For the higher-level
 * implementation which actually sends the queries, see `QueryBuilder` from `@iroha/client` package.
 */ export declare class QueryBuilder<Q extends QueryKind, Output = DefaultQueryOutput<Q>> {
  protected kind: Q;
  protected payload: GetQueryPayload<Q>;
  protected params: types.QueryParams;
  protected selector: unknown;
  protected predicate: types.CompoundPredicate<unknown>;
  protected parseOutput: (resp: types.QueryOutputBatchBoxTuple) => Generator<Output>;
  public constructor(...args: QueryBuilderCtorArgs<Q>);
  /**
   * Specify selected tuple with a _prototype_ of the querying object.
   *
   * @example Select a single value
   *
   * ```ts
   * import * as types from '@iroha/core/data-model'
   *
   * const builder: QueryBuilder<'FindAccounts', types.DomainId> =
   *   new QueryBuilder('FindAccounts')
   *     .selectWith((account) => account.id.domain)
   * ```
   *
   * @example Select multiple values
   *
   * ```ts
   * import * as types from '@iroha/core/data-model'
   *
   * const builder: QueryBuilder<'FindTransactions', [types.Hash, null | types.TransactionRejectionReason]> =
   *   new QueryBuilder('FindTransactions')
   *     .selectWith((tx) => [tx.value.hash, tx.error])
   * ```
   */ public selectWith<const ProtoTuple>(fn: (prototype: prototypes.QuerySelectors[Q]) => ProtoTuple): QueryBuilder<Q, SelectedTuple<ProtoTuple>>;
  /**
   * Specify predicate with a _prototype_ of the querying object.
   *
   * The returned type must be a variant {@linkcode [data-model].CompoundPredicate | CompoundPredicate} containing
   * the actual predicate.
   *
   * @example Specifying a compound logical predicate
   *
   * ```ts
   * import * as types from '@iroha/core/data-model'
   *
   * new QueryBuilder('FindAccounts')
   *   .filterWith((account) => types.CompoundPredicate.Or(
   *     types.CompoundPredicate.Atom(account.id.domain.name.startsWith('wonder')),
   *     types.CompoundPredicate.Atom(account.id.domain.name.endsWith('land')),
   *   ))
   * ```
   */ public filterWith(fn: (prototype: prototypes.QueryPredicates[Q]) => types.CompoundPredicate<PredicateOf<Q>>): this;
  public build(): types.QueryWithParams;
}
export interface QueryBuilderParams {
  /**
   * TODO what fetch size affects, why to set
   */ fetchSize?: types.NonZero<number | bigint>;
  /**
   * TODO pagination offset
   */ offset?: number | bigint;
  /**
   * TODO pagination limit
   */ limit?: types.NonZero<number | bigint>;
  /**
   * Specify sorting of the output
   */ sorting?: {
    /**
     * Sort output by the key-value entry in the entity's metadata.
     * TODO describe example
     */ byMetadataKey?: types.Name;
  };
}
//# sourceMappingURL=query.d.ts.map
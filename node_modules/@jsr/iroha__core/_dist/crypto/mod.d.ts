/**
 * Port of `iroha_crypto` into WebAssembly.
 *
 * ## Compatibility
 *
 * Compatible with all runtimes.
 *
 * Since `0.3.0`, the `.wasm` blob __is inlined__. Therefore, it is compatible with any
 * runtime that supports {@linkcode WebAssembly} (e.g. see
 * [compatibility on MDN](https://developer.mozilla.org/en-US/docs/WebAssembly/Reference/JavaScript_interface/Instance/Instance#browser_compatibility)).
 *
 * This wasn't the case for `0.2.0`: it relied on `.wasm` ES Module Imports, which isn't widely supported (yet).
 *
 * @example Deriving a KeyPair from seed
 * ```ts
 * import { Bytes } from '@iroha/core/crypto'
 * import { assertEquals } from '@std/assert/equals'
 *
 * const kp = KeyPair.deriveFromSeed(Bytes.hex('001122'))
 *
 * assertEquals(kp.privateKey().multihash(), '8026205720A4B3BFFA5C9BBD83D09C88CD1DB08CA3F0C302EC4C8C37A26BD734C37616')
 * ```
 *
 * @example Constructing a private key from a multihash
 * ```ts
 * import { assertEquals } from '@std/assert/equals'
 *
 * const pk = PrivateKey.fromMultihash('8026205720A4B3BFFA5C9BBD83D09C88CD1DB08CA3F0C302EC4C8C37A26BD734C37616')
 *
 * assertEquals(pk.algorithm, 'ed25519')
 * ```
 *
 * @module
 */ import { Bytes } from "./util.js";
import { type CodecContainer, SYMBOL_CODEC } from "../codec.js";
import { type Ord } from "../traits.js";
import { GenCodec } from "../codec.js";
import * as wasm from "./wasm/iroha_crypto_wasm.d.ts";
export { Bytes };
/**
 * Crypto alrogithms supported by Iroha.
 */ export type Algorithm = wasm.Algorithm;
export declare const Algorithm: Record<Algorithm, Algorithm> & {
  default: () => Algorithm;
} & CodecContainer<Algorithm>;
export interface HasAlgorithm {
  readonly algorithm: Algorithm;
}
export interface HasPayload {
  readonly payload: Bytes;
}
/**
 * Cryptographic hash used in Iroha (blake2b-32).
 *
 * ```ts
 * import { assertEquals } from '@std/assert'
 *
 * const hash = Hash.hash(Bytes.hex("01020304"))
 * assertEquals(hash.payload.hex(), '28517e4cdf6c90798c1a983b03727ca7743c21a3880672429ccfc5bd15ea5f73')
 * ```
 */ export declare class Hash {
  public static [SYMBOL_CODEC]: GenCodec<Hash>;
  /**
   * Create an hash filled with zeros.
   */ public static zeroed(): Hash;
  /**
   * Create by hashing the input.
   * @param input the input to hash
   * @returns the resulting hash
   */ public static hash(input: Bytes): Hash;
  /**
   * Construct hash from "prehashed" data
   * @param payload payload of an actual hash
   * @returns hash
   */ public static fromRaw(payload: Bytes): Hash;
  private constructor();
  public get payload(): Bytes;
  public toJSON(): string;
}
/**
 * Private key used in Iroha (used for signing).
 *
 * @example
 *
 * ```ts
 * import { assertEquals } from '@std/assert'
 *
 * const multihash = '80262001F2DB2416255E79DB67D5AC807E55459ED8754F07586864948AEA00F6F81763'
 * const key = PrivateKey.fromMultihash(multihash)
 * assertEquals(key.multihash(), multihash)
 * assertEquals(key.algorithm, 'ed25519')
 * assertEquals(key.payload.hex(), '01f2db2416255e79db67d5ac807e55459ed8754f07586864948aea00f6f81763')
 *
 * const signature = key.sign(Bytes.array(new TextEncoder().encode('my message')))
 * ```
 */ export declare class PrivateKey implements HasAlgorithm, HasPayload {
  /**
   * Create from a multihash string.
   */ public static fromMultihash(multihash: string): PrivateKey;
  public static fromKeyPair(pair: KeyPair): PrivateKey;
  public static fromParts(algorithm: Algorithm, payload: Bytes): PrivateKey;
  private constructor();
  public get algorithm(): Algorithm;
  public get payload(): Bytes;
  /**
   * Get multihash representation.
   * @returns multihash
   */ public multihash(): string;
  /**
   * Sign a given message with this private key.
   * @param message any binary data
   * @returns the signature
   */ public sign(message: Bytes): Signature;
  /**
   * @internal
   */ public get wasm(): wasm.PrivateKey;
  public toJSON(): string;
}
/**
 * Public key used in Iroha (used for verification).
 */ export declare class PublicKey implements HasAlgorithm, HasPayload, Ord<PublicKey> {
  public static [SYMBOL_CODEC]: GenCodec<PublicKey>;
  public static fromMultihash(multihash: string): PublicKey;
  /**
   * Derive public key from its corresponding private key
   */ public static fromPrivateKey(privateKey: PrivateKey): PublicKey;
  public static fromKeyPair(pair: KeyPair): PublicKey;
  public static fromParts(algorithm: Algorithm, payload: Bytes): PublicKey;
  private constructor();
  public get algorithm(): Algorithm;
  public get payload(): Bytes;
  public get wasm(): wasm.PublicKey;
  public multihash(): string;
  /**
   * Verify the signature of a given message
   * @param signature signature of the message, that was created using the private key
   * @param message the message itself
   */ public verify(signature: Signature, message: Bytes): void;
  /**
   * @deprecated use {@linkcode PublicKey.verify}
   */ public verifySignature(signature: Signature, message: Bytes): void;
  public compare(other: PublicKey): number;
  public toJSON(): string;
}
export interface KeyGenOptions {
  /**
   * Cryptographic algorithm to use in key pair generation.
   *
   * @default 'ed25519'
   */ algorithm?: Algorithm;
}
export declare class KeyPair implements HasAlgorithm {
  /**
   * Generate a random key pair.
   */ public static random(options?: KeyGenOptions): KeyPair;
  /**
   * Derive the key pair from the given seed.
   * @param seed some binary data.
   * @param options key generation options
   */ public static deriveFromSeed(seed: Bytes, options?: KeyGenOptions): KeyPair;
  public static deriveFromPrivateKey(private_key: PrivateKey): KeyPair;
  public static fromParts(publicKey: PublicKey, privateKey: PrivateKey): KeyPair;
  private constructor();
  public get algorithm(): Algorithm;
  public privateKey(): PrivateKey;
  public publicKey(): PublicKey;
  /**
   * @internal
   */ public get wasm(): wasm.KeyPair;
  public toJSON(): {
    publicKey: PublicKey;
    privateKey: PrivateKey;
  };
}
export declare class Signature implements HasPayload {
  public static [SYMBOL_CODEC]: GenCodec<Signature>;
  /**
   * Create a signature from its payload and public key. This function **does not sign the payload**.
   */ public static fromRaw(payload: Bytes): Signature;
  /**
   * @deprecated use {@linkcode Signature.sign}
   */ public static create(privateKey: PrivateKey, payload: Bytes): Signature;
  /**
   * Creates an actual signature, signing the payload with the given private key
   */ public static sign(privateKey: PrivateKey, payload: Bytes): Signature;
  private constructor();
  /**
   * Verify that this signature is produced for the given payload by the given key (its public part)
   */ public verify(publicKey: PublicKey, payload: Bytes): void;
  public get payload(): Bytes;
  public toJSON(): string;
}
//# sourceMappingURL=mod.d.ts.map
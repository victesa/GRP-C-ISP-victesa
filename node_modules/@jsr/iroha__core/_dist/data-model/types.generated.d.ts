import * as lib from "./types.generated.prelude.js";
export type Metadata = lib.BTreeMap<lib.Name, lib.Json>;
export declare const Metadata: lib.CodecContainer<Metadata>;
/**
 * Structure with named fields.
 */ export interface Account {
  id: lib.AccountId;
  metadata: Metadata;
}
/**
 * Codec of the structure.
 */ export declare const Account: lib.CodecContainer<Account>;
/**
 * Structure with named fields.
 */ export interface Numeric {
  mantissa: lib.Compact;
  scale: lib.Compact;
}
/**
 * Codec of the structure.
 */ export declare const Numeric: lib.CodecContainer<Numeric>;
/**
 * Structure with named fields.
 */ export interface Asset {
  id: lib.AssetId;
  value: Numeric;
}
/**
 * Codec of the structure.
 */ export declare const Asset: lib.CodecContainer<Asset>;
/**
 * Structure with named fields.
 */ export interface AssetChanged {
  asset: lib.AssetId;
  amount: Numeric;
}
/**
 * Codec of the structure.
 */ export declare const AssetChanged: lib.CodecContainer<AssetChanged>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `Added`
 * - `Removed`
 * 
 * TODO how to construct, how to use
 */ export type AssetEvent = lib.Variant<'Created', Asset> | lib.Variant<'Deleted', lib.AssetId> | lib.Variant<'Added', AssetChanged> | lib.Variant<'Removed', AssetChanged>;
/**
 * Codec and constructors for enumeration {@link AssetEvent}.
 */ export declare const AssetEvent: lib.CodecContainer<AssetEvent> & {
  Created: <const T extends Asset>(value: T) => lib.Variant<'Created', T>;
  Deleted: <const T extends lib.AssetId>(value: T) => lib.Variant<'Deleted', T>;
  Added: <const T extends AssetChanged>(value: T) => lib.Variant<'Added', T>;
  Removed: <const T extends AssetChanged>(value: T) => lib.Variant<'Removed', T>;
};
/**
 * Structure with named fields.
 */ export interface Permission {
  name: lib.String;
  payload: lib.Json;
}
/**
 * Codec of the structure.
 */ export declare const Permission: lib.CodecContainer<Permission>;
/**
 * Structure with named fields.
 */ export interface AccountPermissionChanged {
  account: lib.AccountId;
  permission: Permission;
}
/**
 * Codec of the structure.
 */ export declare const AccountPermissionChanged: lib.CodecContainer<AccountPermissionChanged>;
export type RoleId = lib.Name;
export declare const RoleId: any;
/**
 * Structure with named fields.
 */ export interface AccountRoleChanged {
  account: lib.AccountId;
  role: RoleId;
}
/**
 * Codec of the structure.
 */ export declare const AccountRoleChanged: lib.CodecContainer<AccountRoleChanged>;
/**
 * Structure with named fields and generic parameters.
 */ export interface MetadataChanged<T0> {
  target: T0;
  key: lib.Name;
  value: lib.Json;
}
/**
 * Codec constructor for the structure with generic parameters.
 */ export declare const MetadataChanged: {
  readonly with: <T0>(t0: lib.GenCodec<T0>) => lib.GenCodec<MetadataChanged<T0>>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `Asset`
 * - `PermissionAdded`
 * - `PermissionRemoved`
 * - `RoleGranted`
 * - `RoleRevoked`
 * - `MetadataInserted`
 * - `MetadataRemoved`
 * 
 * TODO how to construct, how to use
 */ export type AccountEvent = lib.Variant<'Created', Account> | lib.Variant<'Deleted', lib.AccountId> | lib.Variant<'Asset', AssetEvent> | lib.Variant<'PermissionAdded', AccountPermissionChanged> | lib.Variant<'PermissionRemoved', AccountPermissionChanged> | lib.Variant<'RoleGranted', AccountRoleChanged> | lib.Variant<'RoleRevoked', AccountRoleChanged> | lib.Variant<'MetadataInserted', MetadataChanged<lib.AccountId>> | lib.Variant<'MetadataRemoved', MetadataChanged<lib.AccountId>>;
/**
 * Codec and constructors for enumeration {@link AccountEvent}.
 */ export declare const AccountEvent: lib.CodecContainer<AccountEvent> & {
  Created: <const T extends Account>(value: T) => lib.Variant<'Created', T>;
  Deleted: <const T extends lib.AccountId>(value: T) => lib.Variant<'Deleted', T>;
  Asset: {
    Created: <const T extends Asset>(value: T) => lib.Variant<'Asset', lib.Variant<'Created', T>>;
    Deleted: <const T extends lib.AssetId>(value: T) => lib.Variant<'Asset', lib.Variant<'Deleted', T>>;
    Added: <const T extends AssetChanged>(value: T) => lib.Variant<'Asset', lib.Variant<'Added', T>>;
    Removed: <const T extends AssetChanged>(value: T) => lib.Variant<'Asset', lib.Variant<'Removed', T>>;
  };
  PermissionAdded: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'PermissionAdded', T>;
  PermissionRemoved: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'PermissionRemoved', T>;
  RoleGranted: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'RoleGranted', T>;
  RoleRevoked: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'RoleRevoked', T>;
  MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'MetadataInserted', T>;
  MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'MetadataRemoved', T>;
};
export type AccountEventSet = Set<'Created' | 'Deleted' | 'AnyAsset' | 'PermissionAdded' | 'PermissionRemoved' | 'RoleGranted' | 'RoleRevoked' | 'MetadataInserted' | 'MetadataRemoved'>;
export declare const AccountEventSet: lib.CodecContainer<AccountEventSet>;
/**
 * Structure with named fields.
 */ export interface AccountEventFilter {
  idMatcher: lib.Option<lib.AccountId>;
  eventSet: AccountEventSet;
}
/**
 * Codec of the structure.
 */ export declare const AccountEventFilter: lib.CodecContainer<AccountEventFilter>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type AccountIdPredicateAtom = lib.Variant<'Equals', lib.AccountId>;
/**
 * Codec and constructors for enumeration {@link AccountIdPredicateAtom}.
 */ export declare const AccountIdPredicateAtom: lib.CodecContainer<AccountIdPredicateAtom> & {
  Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type DomainIdPredicateAtom = lib.Variant<'Equals', lib.DomainId>;
/**
 * Codec and constructors for enumeration {@link DomainIdPredicateAtom}.
 */ export declare const DomainIdPredicateAtom: lib.CodecContainer<DomainIdPredicateAtom> & {
  Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * - `Contains`
 * - `StartsWith`
 * - `EndsWith`
 * 
 * TODO how to construct, how to use
 */ export type StringPredicateAtom = lib.Variant<'Equals', lib.String> | lib.Variant<'Contains', lib.String> | lib.Variant<'StartsWith', lib.String> | lib.Variant<'EndsWith', lib.String>;
/**
 * Codec and constructors for enumeration {@link StringPredicateAtom}.
 */ export declare const StringPredicateAtom: lib.CodecContainer<StringPredicateAtom> & {
  Equals: <const T extends lib.String>(value: T) => lib.Variant<'Equals', T>;
  Contains: <const T extends lib.String>(value: T) => lib.Variant<'Contains', T>;
  StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'StartsWith', T>;
  EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'EndsWith', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type NameProjectionPredicate = lib.Variant<'Atom', StringPredicateAtom>;
/**
 * Codec and constructors for enumeration {@link NameProjectionPredicate}.
 */ export declare const NameProjectionPredicate: lib.CodecContainer<NameProjectionPredicate> & {
  Atom: {
    Equals: <const T extends lib.String>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
    Contains: <const T extends lib.String>(value: T) => lib.Variant<'Atom', lib.Variant<'Contains', T>>;
    StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Atom', lib.Variant<'StartsWith', T>>;
    EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Atom', lib.Variant<'EndsWith', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */ export type DomainIdProjectionPredicate = lib.Variant<'Atom', DomainIdPredicateAtom> | lib.Variant<'Name', NameProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link DomainIdProjectionPredicate}.
 */ export declare const DomainIdProjectionPredicate: lib.CodecContainer<DomainIdProjectionPredicate> & {
  Atom: {
    Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
  Name: {
    Atom: {
      Equals: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
      Contains: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>;
      StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>;
      EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type PublicKeyPredicateAtom = lib.Variant<'Equals', lib.PublicKey>;
/**
 * Codec and constructors for enumeration {@link PublicKeyPredicateAtom}.
 */ export declare const PublicKeyPredicateAtom: lib.CodecContainer<PublicKeyPredicateAtom> & {
  Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type PublicKeyProjectionPredicate = lib.Variant<'Atom', PublicKeyPredicateAtom>;
/**
 * Codec and constructors for enumeration {@link PublicKeyProjectionPredicate}.
 */ export declare const PublicKeyProjectionPredicate: lib.CodecContainer<PublicKeyProjectionPredicate> & {
  Atom: {
    Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Signatory`
 * 
 * TODO how to construct, how to use
 */ export type AccountIdProjectionPredicate = lib.Variant<'Atom', AccountIdPredicateAtom> | lib.Variant<'Domain', DomainIdProjectionPredicate> | lib.Variant<'Signatory', PublicKeyProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link AccountIdProjectionPredicate}.
 */ export declare const AccountIdProjectionPredicate: lib.CodecContainer<AccountIdProjectionPredicate> & {
  Atom: {
    Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
  Domain: {
    Atom: {
      Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Name: {
      Atom: {
        Equals: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
        Contains: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>;
        StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>;
        EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>;
      };
    };
  };
  Signatory: {
    Atom: {
      Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type NameProjectionSelector = lib.VariantUnit<'Atom'>;
/**
 * Codec and constructors for enumeration {@link NameProjectionSelector}.
 */ export declare const NameProjectionSelector: lib.CodecContainer<NameProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */ export type DomainIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Name', NameProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link DomainIdProjectionSelector}.
 */ export declare const DomainIdProjectionSelector: lib.CodecContainer<DomainIdProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Name: {
    Atom: lib.Variant<'Name', lib.VariantUnit<'Atom'>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type PublicKeyProjectionSelector = lib.VariantUnit<'Atom'>;
/**
 * Codec and constructors for enumeration {@link PublicKeyProjectionSelector}.
 */ export declare const PublicKeyProjectionSelector: lib.CodecContainer<PublicKeyProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Signatory`
 * 
 * TODO how to construct, how to use
 */ export type AccountIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Domain', DomainIdProjectionSelector> | lib.Variant<'Signatory', PublicKeyProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link AccountIdProjectionSelector}.
 */ export declare const AccountIdProjectionSelector: lib.CodecContainer<AccountIdProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Domain: {
    Atom: lib.Variant<'Domain', lib.VariantUnit<'Atom'>>;
    Name: {
      Atom: lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>;
    };
  };
  Signatory: {
    Atom: lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>;
  };
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type AccountPredicateAtom = never;
/**
 * Codec for {@link AccountPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const AccountPredicateAtom: lib.CodecContainer<never>;
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type MetadataPredicateAtom = never;
/**
 * Codec for {@link MetadataPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const MetadataPredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type JsonPredicateAtom = lib.Variant<'Equals', lib.Json>;
/**
 * Codec and constructors for enumeration {@link JsonPredicateAtom}.
 */ export declare const JsonPredicateAtom: lib.CodecContainer<JsonPredicateAtom> & {
  Equals: <const T extends lib.Json>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type JsonProjectionPredicate = lib.Variant<'Atom', JsonPredicateAtom>;
/**
 * Codec and constructors for enumeration {@link JsonProjectionPredicate}.
 */ export declare const JsonProjectionPredicate: lib.CodecContainer<JsonProjectionPredicate> & {
  Atom: {
    Equals: <const T extends lib.Json>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
};
/**
 * Structure with named fields.
 */ export interface MetadataKeyProjectionPredicate {
  key: lib.Name;
  projection: JsonProjectionPredicate;
}
/**
 * Codec of the structure.
 */ export declare const MetadataKeyProjectionPredicate: lib.CodecContainer<MetadataKeyProjectionPredicate>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Key`
 * 
 * TODO how to construct, how to use
 */ export type MetadataProjectionPredicate = lib.Variant<'Atom', MetadataPredicateAtom> | lib.Variant<'Key', MetadataKeyProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link MetadataProjectionPredicate}.
 */ export declare const MetadataProjectionPredicate: lib.CodecContainer<MetadataProjectionPredicate> & {
  Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Key', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */ export type AccountProjectionPredicate = lib.Variant<'Atom', AccountPredicateAtom> | lib.Variant<'Id', AccountIdProjectionPredicate> | lib.Variant<'Metadata', MetadataProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link AccountProjectionPredicate}.
 */ export declare const AccountProjectionPredicate: lib.CodecContainer<AccountProjectionPredicate> & {
  Id: {
    Atom: {
      Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Domain: {
      Atom: {
        Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
      Name: {
        Atom: {
          Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
          Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>;
          StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>;
          EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>;
        };
      };
    };
    Signatory: {
      Atom: {
        Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Id', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
    };
  };
  Metadata: {
    Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type JsonProjectionSelector = lib.VariantUnit<'Atom'>;
/**
 * Codec and constructors for enumeration {@link JsonProjectionSelector}.
 */ export declare const JsonProjectionSelector: lib.CodecContainer<JsonProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
};
/**
 * Structure with named fields.
 */ export interface MetadataKeyProjectionSelector {
  key: lib.Name;
  projection: JsonProjectionSelector;
}
/**
 * Codec of the structure.
 */ export declare const MetadataKeyProjectionSelector: lib.CodecContainer<MetadataKeyProjectionSelector>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Key`
 * 
 * TODO how to construct, how to use
 */ export type MetadataProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Key', MetadataKeyProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link MetadataProjectionSelector}.
 */ export declare const MetadataProjectionSelector: lib.CodecContainer<MetadataProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Key', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */ export type AccountProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', AccountIdProjectionSelector> | lib.Variant<'Metadata', MetadataProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link AccountProjectionSelector}.
 */ export declare const AccountProjectionSelector: lib.CodecContainer<AccountProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Id: {
    Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>;
    Domain: {
      Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>;
      Name: {
        Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>;
      };
    };
    Signatory: {
      Atom: lib.Variant<'Id', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>;
    };
  };
  Metadata: {
    Atom: lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>;
    Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>>;
  };
};
export type WasmSmartContract = lib.BytesVec;
export declare const WasmSmartContract: any;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Instructions`
 * - `Wasm`
 * 
 * TODO how to construct, how to use
 */ export type Executable = lib.Variant<'Instructions', lib.Vec<InstructionBox>> | lib.Variant<'Wasm', WasmSmartContract>;
/**
 * Codec and constructors for enumeration {@link Executable}.
 */ export declare const Executable: lib.CodecContainer<Executable> & {
  Instructions: <const T extends lib.Vec<InstructionBox>>(value: T) => lib.Variant<'Instructions', T>;
  Wasm: <const T extends WasmSmartContract>(value: T) => lib.Variant<'Wasm', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Indefinitely`
 * - `Exactly`
 * 
 * TODO how to construct, how to use
 */ export type Repeats = lib.VariantUnit<'Indefinitely'> | lib.Variant<'Exactly', lib.U32>;
/**
 * Codec and constructors for enumeration {@link Repeats}.
 */ export declare const Repeats: lib.CodecContainer<Repeats> & {
  Indefinitely: lib.VariantUnit<'Indefinitely'>;
  Exactly: <const T extends lib.U32>(value: T) => lib.Variant<'Exactly', T>;
};
/**
 * Structure with named fields.
 */ export interface PeerId {
  publicKey: lib.PublicKey;
}
/**
 * Codec of the structure.
 */ export declare const PeerId: lib.CodecContainer<PeerId>;
export type TriggerId = lib.Name;
export declare const TriggerId: any;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Asset`
 * - `AssetDefinition`
 * - `Nft`
 * - `Account`
 * - `Domain`
 * - `MetadataKey`
 * - `Block`
 * - `Transaction`
 * - `Peer`
 * - `Trigger`
 * - `Role`
 * - `Permission`
 * - `PublicKey`
 * 
 * TODO how to construct, how to use
 */ export type FindError = lib.Variant<'Asset', lib.AssetId> | lib.Variant<'AssetDefinition', lib.AssetDefinitionId> | lib.Variant<'Nft', lib.NftId> | lib.Variant<'Account', lib.AccountId> | lib.Variant<'Domain', lib.DomainId> | lib.Variant<'MetadataKey', lib.Name> | lib.Variant<'Block', lib.Hash> | lib.Variant<'Transaction', lib.Hash> | lib.Variant<'Peer', PeerId> | lib.Variant<'Trigger', TriggerId> | lib.Variant<'Role', RoleId> | lib.Variant<'Permission', Permission> | lib.Variant<'PublicKey', lib.PublicKey>;
/**
 * Codec and constructors for enumeration {@link FindError}.
 */ export declare const FindError: lib.CodecContainer<FindError> & {
  Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Asset', T>;
  AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AssetDefinition', T>;
  Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Nft', T>;
  Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Account', T>;
  Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', T>;
  MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'MetadataKey', T>;
  Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Block', T>;
  Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Transaction', T>;
  Peer: <const T extends PeerId>(value: T) => lib.Variant<'Peer', T>;
  Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Trigger', T>;
  Role: <const T extends RoleId>(value: T) => lib.Variant<'Role', T>;
  Permission: <const T extends Permission>(value: T) => lib.Variant<'Permission', T>;
  PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'PublicKey', T>;
};
/**
 * Structure with named fields.
 */ export interface TransactionLimitError {
  reason: lib.String;
}
/**
 * Codec of the structure.
 */ export declare const TransactionLimitError: lib.CodecContainer<TransactionLimitError>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Register`
 * - `Unregister`
 * - `Mint`
 * - `Burn`
 * - `Transfer`
 * - `SetKeyValue`
 * - `RemoveKeyValue`
 * - `Grant`
 * - `Revoke`
 * - `ExecuteTrigger`
 * - `SetParameter`
 * - `Upgrade`
 * - `Log`
 * - `Custom`
 * 
 * TODO how to construct, how to use
 */ export type InstructionType = lib.VariantUnit<'Register'> | lib.VariantUnit<'Unregister'> | lib.VariantUnit<'Mint'> | lib.VariantUnit<'Burn'> | lib.VariantUnit<'Transfer'> | lib.VariantUnit<'SetKeyValue'> | lib.VariantUnit<'RemoveKeyValue'> | lib.VariantUnit<'Grant'> | lib.VariantUnit<'Revoke'> | lib.VariantUnit<'ExecuteTrigger'> | lib.VariantUnit<'SetParameter'> | lib.VariantUnit<'Upgrade'> | lib.VariantUnit<'Log'> | lib.VariantUnit<'Custom'>;
/**
 * Codec and constructors for enumeration {@link InstructionType}.
 */ export declare const InstructionType: lib.CodecContainer<InstructionType> & {
  Register: lib.VariantUnit<'Register'>;
  Unregister: lib.VariantUnit<'Unregister'>;
  Mint: lib.VariantUnit<'Mint'>;
  Burn: lib.VariantUnit<'Burn'>;
  Transfer: lib.VariantUnit<'Transfer'>;
  SetKeyValue: lib.VariantUnit<'SetKeyValue'>;
  RemoveKeyValue: lib.VariantUnit<'RemoveKeyValue'>;
  Grant: lib.VariantUnit<'Grant'>;
  Revoke: lib.VariantUnit<'Revoke'>;
  ExecuteTrigger: lib.VariantUnit<'ExecuteTrigger'>;
  SetParameter: lib.VariantUnit<'SetParameter'>;
  Upgrade: lib.VariantUnit<'Upgrade'>;
  Log: lib.VariantUnit<'Log'>;
  Custom: lib.VariantUnit<'Custom'>;
};
/**
 * Structure with named fields and generic parameters.
 */ export interface Mismatch<T0> {
  expected: T0;
  actual: T0;
}
/**
 * Codec constructor for the structure with generic parameters.
 */ export declare const Mismatch: {
  readonly with: <T0>(t0: lib.GenCodec<T0>) => lib.GenCodec<Mismatch<T0>>;
};
/**
 * Structure with named fields.
 */ export interface NumericSpec {
  scale: lib.Option<lib.U32>;
}
/**
 * Codec of the structure.
 */ export declare const NumericSpec: lib.CodecContainer<NumericSpec>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `AssetNumericSpec`
 * 
 * TODO how to construct, how to use
 */ export type TypeError = lib.Variant<'AssetNumericSpec', Mismatch<NumericSpec>>;
/**
 * Codec and constructors for enumeration {@link TypeError}.
 */ export declare const TypeError: lib.CodecContainer<TypeError> & {
  AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'AssetNumericSpec', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Unsupported`
 * - `PermissionParameter`
 * - `Type`
 * 
 * TODO how to construct, how to use
 */ export type InstructionEvaluationError = lib.Variant<'Unsupported', InstructionType> | lib.Variant<'PermissionParameter', lib.String> | lib.Variant<'Type', TypeError>;
/**
 * Codec and constructors for enumeration {@link InstructionEvaluationError}.
 */ export declare const InstructionEvaluationError: lib.CodecContainer<InstructionEvaluationError> & {
  Unsupported: {
    Register: lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>;
    Unregister: lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>;
    Mint: lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>;
    Burn: lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>;
    Transfer: lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>;
    SetKeyValue: lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>;
    RemoveKeyValue: lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>;
    Grant: lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>;
    Revoke: lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>;
    ExecuteTrigger: lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>;
    SetParameter: lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>;
    Upgrade: lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>;
    Log: lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>;
    Custom: lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>;
  };
  PermissionParameter: <const T extends lib.String>(value: T) => lib.Variant<'PermissionParameter', T>;
  Type: {
    AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Find`
 * - `Conversion`
 * - `NotFound`
 * - `CursorMismatch`
 * - `CursorDone`
 * - `FetchSizeTooBig`
 * - `InvalidSingularParameters`
 * - `CapacityLimit`
 * 
 * TODO how to construct, how to use
 */ export type QueryExecutionFail = lib.Variant<'Find', FindError> | lib.Variant<'Conversion', lib.String> | lib.VariantUnit<'NotFound'> | lib.VariantUnit<'CursorMismatch'> | lib.VariantUnit<'CursorDone'> | lib.VariantUnit<'FetchSizeTooBig'> | lib.VariantUnit<'InvalidSingularParameters'> | lib.VariantUnit<'CapacityLimit'>;
/**
 * Codec and constructors for enumeration {@link QueryExecutionFail}.
 */ export declare const QueryExecutionFail: lib.CodecContainer<QueryExecutionFail> & {
  Find: {
    Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Find', lib.Variant<'Asset', T>>;
    AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>;
    Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Find', lib.Variant<'Nft', T>>;
    Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Find', lib.Variant<'Account', T>>;
    Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Find', lib.Variant<'Domain', T>>;
    MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Find', lib.Variant<'MetadataKey', T>>;
    Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Find', lib.Variant<'Block', T>>;
    Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Find', lib.Variant<'Transaction', T>>;
    Peer: <const T extends PeerId>(value: T) => lib.Variant<'Find', lib.Variant<'Peer', T>>;
    Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Find', lib.Variant<'Trigger', T>>;
    Role: <const T extends RoleId>(value: T) => lib.Variant<'Find', lib.Variant<'Role', T>>;
    Permission: <const T extends Permission>(value: T) => lib.Variant<'Find', lib.Variant<'Permission', T>>;
    PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Find', lib.Variant<'PublicKey', T>>;
  };
  Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Conversion', T>;
  NotFound: lib.VariantUnit<'NotFound'>;
  CursorMismatch: lib.VariantUnit<'CursorMismatch'>;
  CursorDone: lib.VariantUnit<'CursorDone'>;
  FetchSizeTooBig: lib.VariantUnit<'FetchSizeTooBig'>;
  InvalidSingularParameters: lib.VariantUnit<'InvalidSingularParameters'>;
  CapacityLimit: lib.VariantUnit<'CapacityLimit'>;
};
export type CustomParameterId = lib.Name;
export declare const CustomParameterId: any;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `DomainId`
 * - `AccountId`
 * - `AssetDefinitionId`
 * - `AssetId`
 * - `NftId`
 * - `PeerId`
 * - `TriggerId`
 * - `RoleId`
 * - `Permission`
 * - `CustomParameterId`
 * 
 * TODO how to construct, how to use
 */ export type IdBox = lib.Variant<'DomainId', lib.DomainId> | lib.Variant<'AccountId', lib.AccountId> | lib.Variant<'AssetDefinitionId', lib.AssetDefinitionId> | lib.Variant<'AssetId', lib.AssetId> | lib.Variant<'NftId', lib.NftId> | lib.Variant<'PeerId', PeerId> | lib.Variant<'TriggerId', TriggerId> | lib.Variant<'RoleId', RoleId> | lib.Variant<'Permission', Permission> | lib.Variant<'CustomParameterId', CustomParameterId>;
/**
 * Codec and constructors for enumeration {@link IdBox}.
 */ export declare const IdBox: lib.CodecContainer<IdBox> & {
  DomainId: <const T extends lib.DomainId>(value: T) => lib.Variant<'DomainId', T>;
  AccountId: <const T extends lib.AccountId>(value: T) => lib.Variant<'AccountId', T>;
  AssetDefinitionId: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AssetDefinitionId', T>;
  AssetId: <const T extends lib.AssetId>(value: T) => lib.Variant<'AssetId', T>;
  NftId: <const T extends lib.NftId>(value: T) => lib.Variant<'NftId', T>;
  PeerId: <const T extends PeerId>(value: T) => lib.Variant<'PeerId', T>;
  TriggerId: <const T extends TriggerId>(value: T) => lib.Variant<'TriggerId', T>;
  RoleId: <const T extends RoleId>(value: T) => lib.Variant<'RoleId', T>;
  Permission: <const T extends Permission>(value: T) => lib.Variant<'Permission', T>;
  CustomParameterId: <const T extends CustomParameterId>(value: T) => lib.Variant<'CustomParameterId', T>;
};
/**
 * Structure with named fields.
 */ export interface RepetitionError {
  instruction: InstructionType;
  id: IdBox;
}
/**
 * Codec of the structure.
 */ export declare const RepetitionError: lib.CodecContainer<RepetitionError>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `MintUnmintable`
 * - `ForbidMintOnMintable`
 * 
 * TODO how to construct, how to use
 */ export type MintabilityError = lib.VariantUnit<'MintUnmintable'> | lib.VariantUnit<'ForbidMintOnMintable'>;
/**
 * Codec and constructors for enumeration {@link MintabilityError}.
 */ export declare const MintabilityError: lib.CodecContainer<MintabilityError> & {
  MintUnmintable: lib.VariantUnit<'MintUnmintable'>;
  ForbidMintOnMintable: lib.VariantUnit<'ForbidMintOnMintable'>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Overflow`
 * - `NotEnoughQuantity`
 * - `DivideByZero`
 * - `NegativeValue`
 * - `DomainViolation`
 * - `Unknown`
 * - `FixedPointConversion`
 * 
 * TODO how to construct, how to use
 */ export type MathError = lib.VariantUnit<'Overflow'> | lib.VariantUnit<'NotEnoughQuantity'> | lib.VariantUnit<'DivideByZero'> | lib.VariantUnit<'NegativeValue'> | lib.VariantUnit<'DomainViolation'> | lib.VariantUnit<'Unknown'> | lib.Variant<'FixedPointConversion', lib.String>;
/**
 * Codec and constructors for enumeration {@link MathError}.
 */ export declare const MathError: lib.CodecContainer<MathError> & {
  Overflow: lib.VariantUnit<'Overflow'>;
  NotEnoughQuantity: lib.VariantUnit<'NotEnoughQuantity'>;
  DivideByZero: lib.VariantUnit<'DivideByZero'>;
  NegativeValue: lib.VariantUnit<'NegativeValue'>;
  DomainViolation: lib.VariantUnit<'DomainViolation'>;
  Unknown: lib.VariantUnit<'Unknown'>;
  FixedPointConversion: <const T extends lib.String>(value: T) => lib.Variant<'FixedPointConversion', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Wasm`
 * - `TimeTriggerInThePast`
 * 
 * TODO how to construct, how to use
 */ export type InvalidParameterError = lib.Variant<'Wasm', lib.String> | lib.VariantUnit<'TimeTriggerInThePast'>;
/**
 * Codec and constructors for enumeration {@link InvalidParameterError}.
 */ export declare const InvalidParameterError: lib.CodecContainer<InvalidParameterError> & {
  Wasm: <const T extends lib.String>(value: T) => lib.Variant<'Wasm', T>;
  TimeTriggerInThePast: lib.VariantUnit<'TimeTriggerInThePast'>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Evaluate`
 * - `Query`
 * - `Conversion`
 * - `Find`
 * - `Repetition`
 * - `Mintability`
 * - `Math`
 * - `InvalidParameter`
 * - `InvariantViolation`
 * 
 * TODO how to construct, how to use
 */ export type InstructionExecutionError = lib.Variant<'Evaluate', InstructionEvaluationError> | lib.Variant<'Query', QueryExecutionFail> | lib.Variant<'Conversion', lib.String> | lib.Variant<'Find', FindError> | lib.Variant<'Repetition', RepetitionError> | lib.Variant<'Mintability', MintabilityError> | lib.Variant<'Math', MathError> | lib.Variant<'InvalidParameter', InvalidParameterError> | lib.Variant<'InvariantViolation', lib.String>;
/**
 * Codec and constructors for enumeration {@link InstructionExecutionError}.
 */ export declare const InstructionExecutionError: lib.CodecContainer<InstructionExecutionError> & {
  Evaluate: {
    Unsupported: {
      Register: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>;
      Unregister: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>;
      Mint: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>;
      Burn: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>;
      Transfer: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>;
      SetKeyValue: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>;
      RemoveKeyValue: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>;
      Grant: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>;
      Revoke: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>;
      ExecuteTrigger: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>;
      SetParameter: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>;
      Upgrade: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>;
      Log: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>;
      Custom: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>;
    };
    PermissionParameter: <const T extends lib.String>(value: T) => lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>;
    Type: {
      AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>>;
    };
  };
  Query: {
    Find: {
      Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>;
      AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>;
      Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>;
      Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>;
      Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>;
      MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>;
      Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>;
      Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>;
      Peer: <const T extends PeerId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>;
      Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>;
      Role: <const T extends RoleId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>;
      Permission: <const T extends Permission>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>;
      PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>;
    };
    Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Query', lib.Variant<'Conversion', T>>;
    NotFound: lib.Variant<'Query', lib.VariantUnit<'NotFound'>>;
    CursorMismatch: lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>;
    CursorDone: lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>;
    FetchSizeTooBig: lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>;
    InvalidSingularParameters: lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>;
    CapacityLimit: lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>;
  };
  Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Conversion', T>;
  Find: {
    Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Find', lib.Variant<'Asset', T>>;
    AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>;
    Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Find', lib.Variant<'Nft', T>>;
    Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Find', lib.Variant<'Account', T>>;
    Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Find', lib.Variant<'Domain', T>>;
    MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Find', lib.Variant<'MetadataKey', T>>;
    Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Find', lib.Variant<'Block', T>>;
    Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Find', lib.Variant<'Transaction', T>>;
    Peer: <const T extends PeerId>(value: T) => lib.Variant<'Find', lib.Variant<'Peer', T>>;
    Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Find', lib.Variant<'Trigger', T>>;
    Role: <const T extends RoleId>(value: T) => lib.Variant<'Find', lib.Variant<'Role', T>>;
    Permission: <const T extends Permission>(value: T) => lib.Variant<'Find', lib.Variant<'Permission', T>>;
    PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Find', lib.Variant<'PublicKey', T>>;
  };
  Repetition: <const T extends RepetitionError>(value: T) => lib.Variant<'Repetition', T>;
  Mintability: {
    MintUnmintable: lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>;
    ForbidMintOnMintable: lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>;
  };
  Math: {
    Overflow: lib.Variant<'Math', lib.VariantUnit<'Overflow'>>;
    NotEnoughQuantity: lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>;
    DivideByZero: lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>;
    NegativeValue: lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>;
    DomainViolation: lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>;
    Unknown: lib.Variant<'Math', lib.VariantUnit<'Unknown'>>;
    FixedPointConversion: <const T extends lib.String>(value: T) => lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>>;
  };
  InvalidParameter: {
    Wasm: <const T extends lib.String>(value: T) => lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>;
    TimeTriggerInThePast: lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>;
  };
  InvariantViolation: <const T extends lib.String>(value: T) => lib.Variant<'InvariantViolation', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `NotPermitted`
 * - `InstructionFailed`
 * - `QueryFailed`
 * - `TooComplex`
 * - `InternalError`
 * 
 * TODO how to construct, how to use
 */ export type ValidationFail = lib.Variant<'NotPermitted', lib.String> | lib.Variant<'InstructionFailed', InstructionExecutionError> | lib.Variant<'QueryFailed', QueryExecutionFail> | lib.VariantUnit<'TooComplex'> | lib.VariantUnit<'InternalError'>;
/**
 * Codec and constructors for enumeration {@link ValidationFail}.
 */ export declare const ValidationFail: lib.CodecContainer<ValidationFail> & {
  NotPermitted: <const T extends lib.String>(value: T) => lib.Variant<'NotPermitted', T>;
  InstructionFailed: {
    Evaluate: {
      Unsupported: {
        Register: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>>;
        Unregister: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>>;
        Mint: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>>;
        Burn: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>>;
        Transfer: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>>;
        SetKeyValue: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>>;
        RemoveKeyValue: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>>;
        Grant: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>>;
        Revoke: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>>;
        ExecuteTrigger: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>>;
        SetParameter: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>>;
        Upgrade: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>>;
        Log: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>>;
        Custom: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>>;
      };
      PermissionParameter: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>>;
      Type: {
        AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>>>;
      };
    };
    Query: {
      Find: {
        Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>>;
        AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>;
        Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>>;
        Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>>;
        Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>>;
        MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>;
        Block: <const T extends lib.Hash>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>>;
        Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>;
        Peer: <const T extends PeerId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>>;
        Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>;
        Role: <const T extends RoleId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>>;
        Permission: <const T extends Permission>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>>;
        PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>;
      };
      Conversion: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Conversion', T>>>;
      NotFound: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'NotFound'>>>;
      CursorMismatch: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>>;
      CursorDone: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>>;
      FetchSizeTooBig: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>>;
      InvalidSingularParameters: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>>;
      CapacityLimit: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>>;
    };
    Conversion: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Conversion', T>>;
    Find: {
      Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>;
      AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>;
      Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>;
      Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>;
      Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>;
      MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>;
      Block: <const T extends lib.Hash>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>;
      Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>;
      Peer: <const T extends PeerId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>;
      Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>;
      Role: <const T extends RoleId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>;
      Permission: <const T extends Permission>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>;
      PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>;
    };
    Repetition: <const T extends RepetitionError>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Repetition', T>>;
    Mintability: {
      MintUnmintable: lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>>;
      ForbidMintOnMintable: lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>>;
    };
    Math: {
      Overflow: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Overflow'>>>;
      NotEnoughQuantity: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>>;
      DivideByZero: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>>;
      NegativeValue: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>>;
      DomainViolation: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>>;
      Unknown: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Unknown'>>>;
      FixedPointConversion: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>>>;
    };
    InvalidParameter: {
      Wasm: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>>;
      TimeTriggerInThePast: lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>>;
    };
    InvariantViolation: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'InvariantViolation', T>>;
  };
  QueryFailed: {
    Find: {
      Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>;
      AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>;
      Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>;
      Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>;
      Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>;
      MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>;
      Block: <const T extends lib.Hash>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>;
      Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>;
      Peer: <const T extends PeerId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>;
      Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>;
      Role: <const T extends RoleId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>;
      Permission: <const T extends Permission>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>;
      PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>;
    };
    Conversion: <const T extends lib.String>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Conversion', T>>;
    NotFound: lib.Variant<'QueryFailed', lib.VariantUnit<'NotFound'>>;
    CursorMismatch: lib.Variant<'QueryFailed', lib.VariantUnit<'CursorMismatch'>>;
    CursorDone: lib.Variant<'QueryFailed', lib.VariantUnit<'CursorDone'>>;
    FetchSizeTooBig: lib.Variant<'QueryFailed', lib.VariantUnit<'FetchSizeTooBig'>>;
    InvalidSingularParameters: lib.Variant<'QueryFailed', lib.VariantUnit<'InvalidSingularParameters'>>;
    CapacityLimit: lib.Variant<'QueryFailed', lib.VariantUnit<'CapacityLimit'>>;
  };
  TooComplex: lib.VariantUnit<'TooComplex'>;
  InternalError: lib.VariantUnit<'InternalError'>;
};
/**
 * Structure with named fields.
 */ export interface InstructionExecutionFail {
  instruction: InstructionBox;
  reason: lib.String;
}
/**
 * Codec of the structure.
 */ export declare const InstructionExecutionFail: lib.CodecContainer<InstructionExecutionFail>;
/**
 * Structure with named fields.
 */ export interface WasmExecutionFail {
  reason: lib.String;
}
/**
 * Codec of the structure.
 */ export declare const WasmExecutionFail: lib.CodecContainer<WasmExecutionFail>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `AccountDoesNotExist`
 * - `LimitCheck`
 * - `Validation`
 * - `InstructionExecution`
 * - `WasmExecution`
 * 
 * TODO how to construct, how to use
 */ export type TransactionRejectionReason = lib.Variant<'AccountDoesNotExist', FindError> | lib.Variant<'LimitCheck', TransactionLimitError> | lib.Variant<'Validation', ValidationFail> | lib.Variant<'InstructionExecution', InstructionExecutionFail> | lib.Variant<'WasmExecution', WasmExecutionFail>;
/**
 * Codec and constructors for enumeration {@link TransactionRejectionReason}.
 */ export declare const TransactionRejectionReason: lib.CodecContainer<TransactionRejectionReason> & {
  AccountDoesNotExist: {
    Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Asset', T>>;
    AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'AssetDefinition', T>>;
    Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Nft', T>>;
    Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Account', T>>;
    Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Domain', T>>;
    MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'MetadataKey', T>>;
    Block: <const T extends lib.Hash>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Block', T>>;
    Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Transaction', T>>;
    Peer: <const T extends PeerId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Peer', T>>;
    Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Trigger', T>>;
    Role: <const T extends RoleId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Role', T>>;
    Permission: <const T extends Permission>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Permission', T>>;
    PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'PublicKey', T>>;
  };
  LimitCheck: <const T extends TransactionLimitError>(value: T) => lib.Variant<'LimitCheck', T>;
  Validation: {
    NotPermitted: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'NotPermitted', T>>;
    InstructionFailed: {
      Evaluate: {
        Unsupported: {
          Register: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>>>;
          Unregister: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>>>;
          Mint: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>>>;
          Burn: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>>>;
          Transfer: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>>>;
          SetKeyValue: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>>>;
          RemoveKeyValue: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>>>;
          Grant: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>>>;
          Revoke: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>>>;
          ExecuteTrigger: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>>>;
          SetParameter: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>>>;
          Upgrade: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>>>;
          Log: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>>>;
          Custom: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>>>;
        };
        PermissionParameter: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>>>;
        Type: {
          AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>>>>;
        };
      };
      Query: {
        Find: {
          Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>>>;
          AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>>;
          Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>>>;
          Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>>>;
          Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>>>;
          MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>>;
          Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>>>;
          Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>>;
          Peer: <const T extends PeerId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>>>;
          Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>>;
          Role: <const T extends RoleId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>>>;
          Permission: <const T extends Permission>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>>>;
          PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>>;
        };
        Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Conversion', T>>>>;
        NotFound: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'NotFound'>>>>;
        CursorMismatch: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>>>;
        CursorDone: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>>>;
        FetchSizeTooBig: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>>>;
        InvalidSingularParameters: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>>>;
        CapacityLimit: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>>>;
      };
      Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Conversion', T>>>;
      Find: {
        Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>>;
        AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>;
        Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>>;
        Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>>;
        Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>>;
        MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>;
        Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>>;
        Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>;
        Peer: <const T extends PeerId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>>;
        Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>;
        Role: <const T extends RoleId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>>;
        Permission: <const T extends Permission>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>>;
        PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>;
      };
      Repetition: <const T extends RepetitionError>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Repetition', T>>>;
      Mintability: {
        MintUnmintable: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>>>;
        ForbidMintOnMintable: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>>>;
      };
      Math: {
        Overflow: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Overflow'>>>>;
        NotEnoughQuantity: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>>>;
        DivideByZero: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>>>;
        NegativeValue: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>>>;
        DomainViolation: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>>>;
        Unknown: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Unknown'>>>>;
        FixedPointConversion: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>>>>;
      };
      InvalidParameter: {
        Wasm: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>>>;
        TimeTriggerInThePast: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>>>;
      };
      InvariantViolation: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvariantViolation', T>>>;
    };
    QueryFailed: {
      Find: {
        Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>>;
        AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>;
        Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>>;
        Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>>;
        Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>>;
        MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>;
        Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>>;
        Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>;
        Peer: <const T extends PeerId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>>;
        Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>;
        Role: <const T extends RoleId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>>;
        Permission: <const T extends Permission>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>>;
        PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>;
      };
      Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Conversion', T>>>;
      NotFound: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'NotFound'>>>;
      CursorMismatch: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorMismatch'>>>;
      CursorDone: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorDone'>>>;
      FetchSizeTooBig: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'FetchSizeTooBig'>>>;
      InvalidSingularParameters: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'InvalidSingularParameters'>>>;
      CapacityLimit: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CapacityLimit'>>>;
    };
    TooComplex: lib.Variant<'Validation', lib.VariantUnit<'TooComplex'>>;
    InternalError: lib.Variant<'Validation', lib.VariantUnit<'InternalError'>>;
  };
  InstructionExecution: <const T extends InstructionExecutionFail>(value: T) => lib.Variant<'InstructionExecution', T>;
  WasmExecution: <const T extends WasmExecutionFail>(value: T) => lib.Variant<'WasmExecution', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Queued`
 * - `Expired`
 * - `Approved`
 * - `Rejected`
 * 
 * TODO how to construct, how to use
 */ export type TransactionStatus = lib.VariantUnit<'Queued'> | lib.VariantUnit<'Expired'> | lib.VariantUnit<'Approved'> | lib.Variant<'Rejected', TransactionRejectionReason>;
/**
 * Codec and constructors for enumeration {@link TransactionStatus}.
 */ export declare const TransactionStatus: lib.CodecContainer<TransactionStatus> & {
  Queued: lib.VariantUnit<'Queued'>;
  Expired: lib.VariantUnit<'Expired'>;
  Approved: lib.VariantUnit<'Approved'>;
  Rejected: {
    AccountDoesNotExist: {
      Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Asset', T>>>;
      AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'AssetDefinition', T>>>;
      Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Nft', T>>>;
      Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Account', T>>>;
      Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Domain', T>>>;
      MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'MetadataKey', T>>>;
      Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Block', T>>>;
      Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Transaction', T>>>;
      Peer: <const T extends PeerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Peer', T>>>;
      Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Trigger', T>>>;
      Role: <const T extends RoleId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Role', T>>>;
      Permission: <const T extends Permission>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Permission', T>>>;
      PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'PublicKey', T>>>;
    };
    LimitCheck: <const T extends TransactionLimitError>(value: T) => lib.Variant<'Rejected', lib.Variant<'LimitCheck', T>>;
    Validation: {
      NotPermitted: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'NotPermitted', T>>>;
      InstructionFailed: {
        Evaluate: {
          Unsupported: {
            Register: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>>>>;
            Unregister: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>>>>;
            Mint: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>>>>;
            Burn: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>>>>;
            Transfer: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>>>>;
            SetKeyValue: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>>>>;
            RemoveKeyValue: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>>>>;
            Grant: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>>>>;
            Revoke: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>>>>;
            ExecuteTrigger: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>>>>;
            SetParameter: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>>>>;
            Upgrade: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>>>>;
            Log: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>>>>;
            Custom: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>>>>;
          };
          PermissionParameter: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>>>>;
          Type: {
            AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>>>>>;
          };
        };
        Query: {
          Find: {
            Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>>>>;
            AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>>>;
            Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>>>>;
            Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>>>>;
            Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>>>>;
            MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>>>;
            Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>>>>;
            Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>>>;
            Peer: <const T extends PeerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>>>>;
            Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>>>;
            Role: <const T extends RoleId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>>>>;
            Permission: <const T extends Permission>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>>>>;
            PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>>>;
          };
          Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Conversion', T>>>>>;
          NotFound: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'NotFound'>>>>>;
          CursorMismatch: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>>>>;
          CursorDone: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>>>>;
          FetchSizeTooBig: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>>>>;
          InvalidSingularParameters: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>>>>;
          CapacityLimit: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>>>>;
        };
        Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Conversion', T>>>>;
        Find: {
          Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>>>;
          AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>>;
          Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>>>;
          Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>>>;
          Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>>>;
          MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>>;
          Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>>>;
          Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>>;
          Peer: <const T extends PeerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>>>;
          Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>>;
          Role: <const T extends RoleId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>>>;
          Permission: <const T extends Permission>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>>>;
          PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>>;
        };
        Repetition: <const T extends RepetitionError>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Repetition', T>>>>;
        Mintability: {
          MintUnmintable: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>>>>;
          ForbidMintOnMintable: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>>>>;
        };
        Math: {
          Overflow: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Overflow'>>>>>;
          NotEnoughQuantity: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>>>>;
          DivideByZero: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>>>>;
          NegativeValue: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>>>>;
          DomainViolation: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>>>>;
          Unknown: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Unknown'>>>>>;
          FixedPointConversion: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>>>>>;
        };
        InvalidParameter: {
          Wasm: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>>>>;
          TimeTriggerInThePast: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>>>>;
        };
        InvariantViolation: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvariantViolation', T>>>>;
      };
      QueryFailed: {
        Find: {
          Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>>>;
          AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>>;
          Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>>>;
          Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>>>;
          Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>>>;
          MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>>;
          Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>>>;
          Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>>;
          Peer: <const T extends PeerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>>>;
          Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>>;
          Role: <const T extends RoleId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>>>;
          Permission: <const T extends Permission>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>>>;
          PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>>;
        };
        Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Conversion', T>>>>;
        NotFound: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'NotFound'>>>>;
        CursorMismatch: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorMismatch'>>>>;
        CursorDone: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorDone'>>>>;
        FetchSizeTooBig: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'FetchSizeTooBig'>>>>;
        InvalidSingularParameters: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'InvalidSingularParameters'>>>>;
        CapacityLimit: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CapacityLimit'>>>>;
      };
      TooComplex: lib.Variant<'Rejected', lib.Variant<'Validation', lib.VariantUnit<'TooComplex'>>>;
      InternalError: lib.Variant<'Rejected', lib.Variant<'Validation', lib.VariantUnit<'InternalError'>>>;
    };
    InstructionExecution: <const T extends InstructionExecutionFail>(value: T) => lib.Variant<'Rejected', lib.Variant<'InstructionExecution', T>>;
    WasmExecution: <const T extends WasmExecutionFail>(value: T) => lib.Variant<'Rejected', lib.Variant<'WasmExecution', T>>;
  };
};
/**
 * Structure with named fields.
 */ export interface TransactionEventFilter {
  hash: lib.Option<lib.Hash>;
  blockHeight: lib.Option<lib.Option<lib.NonZero<lib.U64>>>;
  status: lib.Option<TransactionStatus>;
}
/**
 * Codec of the structure.
 */ export declare const TransactionEventFilter: lib.CodecContainer<TransactionEventFilter>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `ConsensusBlockRejection`
 * 
 * TODO how to construct, how to use
 */ export type BlockRejectionReason = lib.VariantUnit<'ConsensusBlockRejection'>;
/**
 * Codec and constructors for enumeration {@link BlockRejectionReason}.
 */ export declare const BlockRejectionReason: lib.CodecContainer<BlockRejectionReason> & {
  ConsensusBlockRejection: lib.VariantUnit<'ConsensusBlockRejection'>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Approved`
 * - `Rejected`
 * - `Committed`
 * - `Applied`
 * 
 * TODO how to construct, how to use
 */ export type BlockStatus = lib.VariantUnit<'Created'> | lib.VariantUnit<'Approved'> | lib.Variant<'Rejected', BlockRejectionReason> | lib.VariantUnit<'Committed'> | lib.VariantUnit<'Applied'>;
/**
 * Codec and constructors for enumeration {@link BlockStatus}.
 */ export declare const BlockStatus: lib.CodecContainer<BlockStatus> & {
  Created: lib.VariantUnit<'Created'>;
  Approved: lib.VariantUnit<'Approved'>;
  Rejected: {
    ConsensusBlockRejection: lib.Variant<'Rejected', lib.VariantUnit<'ConsensusBlockRejection'>>;
  };
  Committed: lib.VariantUnit<'Committed'>;
  Applied: lib.VariantUnit<'Applied'>;
};
/**
 * Structure with named fields.
 */ export interface BlockEventFilter {
  height: lib.Option<lib.NonZero<lib.U64>>;
  status: lib.Option<BlockStatus>;
}
/**
 * Codec of the structure.
 */ export declare const BlockEventFilter: lib.CodecContainer<BlockEventFilter>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Transaction`
 * - `Block`
 * 
 * TODO how to construct, how to use
 */ export type PipelineEventFilterBox = lib.Variant<'Transaction', TransactionEventFilter> | lib.Variant<'Block', BlockEventFilter>;
/**
 * Codec and constructors for enumeration {@link PipelineEventFilterBox}.
 */ export declare const PipelineEventFilterBox: lib.CodecContainer<PipelineEventFilterBox> & {
  Transaction: <const T extends TransactionEventFilter>(value: T) => lib.Variant<'Transaction', T>;
  Block: <const T extends BlockEventFilter>(value: T) => lib.Variant<'Block', T>;
};
export type PeerEventSet = Set<'Added' | 'Removed'>;
export declare const PeerEventSet: lib.CodecContainer<PeerEventSet>;
/**
 * Structure with named fields.
 */ export interface PeerEventFilter {
  idMatcher: lib.Option<PeerId>;
  eventSet: PeerEventSet;
}
/**
 * Codec of the structure.
 */ export declare const PeerEventFilter: lib.CodecContainer<PeerEventFilter>;
export type DomainEventSet = Set<'Created' | 'Deleted' | 'AnyAssetDefinition' | 'AnyNft' | 'AnyAccount' | 'MetadataInserted' | 'MetadataRemoved' | 'OwnerChanged'>;
export declare const DomainEventSet: lib.CodecContainer<DomainEventSet>;
/**
 * Structure with named fields.
 */ export interface DomainEventFilter {
  idMatcher: lib.Option<lib.DomainId>;
  eventSet: DomainEventSet;
}
/**
 * Codec of the structure.
 */ export declare const DomainEventFilter: lib.CodecContainer<DomainEventFilter>;
export type AssetEventSet = Set<'Created' | 'Deleted' | 'Added' | 'Removed'>;
export declare const AssetEventSet: lib.CodecContainer<AssetEventSet>;
/**
 * Structure with named fields.
 */ export interface AssetEventFilter {
  idMatcher: lib.Option<lib.AssetId>;
  eventSet: AssetEventSet;
}
/**
 * Codec of the structure.
 */ export declare const AssetEventFilter: lib.CodecContainer<AssetEventFilter>;
export type AssetDefinitionEventSet = Set<'Created' | 'Deleted' | 'MetadataInserted' | 'MetadataRemoved' | 'MintabilityChanged' | 'TotalQuantityChanged' | 'OwnerChanged'>;
export declare const AssetDefinitionEventSet: lib.CodecContainer<AssetDefinitionEventSet>;
/**
 * Structure with named fields.
 */ export interface AssetDefinitionEventFilter {
  idMatcher: lib.Option<lib.AssetDefinitionId>;
  eventSet: AssetDefinitionEventSet;
}
/**
 * Codec of the structure.
 */ export declare const AssetDefinitionEventFilter: lib.CodecContainer<AssetDefinitionEventFilter>;
export type NftEventSet = Set<'Created' | 'Deleted' | 'MetadataInserted' | 'MetadataRemoved' | 'OwnerChanged'>;
export declare const NftEventSet: lib.CodecContainer<NftEventSet>;
/**
 * Structure with named fields.
 */ export interface NftEventFilter {
  idMatcher: lib.Option<lib.NftId>;
  eventSet: NftEventSet;
}
/**
 * Codec of the structure.
 */ export declare const NftEventFilter: lib.CodecContainer<NftEventFilter>;
export type TriggerEventSet = Set<'Created' | 'Deleted' | 'Extended' | 'Shortened' | 'MetadataInserted' | 'MetadataRemoved'>;
export declare const TriggerEventSet: lib.CodecContainer<TriggerEventSet>;
/**
 * Structure with named fields.
 */ export interface TriggerEventFilter {
  idMatcher: lib.Option<TriggerId>;
  eventSet: TriggerEventSet;
}
/**
 * Codec of the structure.
 */ export declare const TriggerEventFilter: lib.CodecContainer<TriggerEventFilter>;
export type RoleEventSet = Set<'Created' | 'Deleted' | 'PermissionAdded' | 'PermissionRemoved'>;
export declare const RoleEventSet: lib.CodecContainer<RoleEventSet>;
/**
 * Structure with named fields.
 */ export interface RoleEventFilter {
  idMatcher: lib.Option<RoleId>;
  eventSet: RoleEventSet;
}
/**
 * Codec of the structure.
 */ export declare const RoleEventFilter: lib.CodecContainer<RoleEventFilter>;
export type ConfigurationEventSet = Set<'Changed'>;
export declare const ConfigurationEventSet: lib.CodecContainer<ConfigurationEventSet>;
/**
 * Structure with named fields.
 */ export interface ConfigurationEventFilter {
  eventSet: ConfigurationEventSet;
}
/**
 * Codec of the structure.
 */ export declare const ConfigurationEventFilter: lib.CodecContainer<ConfigurationEventFilter>;
export type ExecutorEventSet = Set<'Upgraded'>;
export declare const ExecutorEventSet: lib.CodecContainer<ExecutorEventSet>;
/**
 * Structure with named fields.
 */ export interface ExecutorEventFilter {
  eventSet: ExecutorEventSet;
}
/**
 * Codec of the structure.
 */ export declare const ExecutorEventFilter: lib.CodecContainer<ExecutorEventFilter>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Any`
 * - `Peer`
 * - `Domain`
 * - `Account`
 * - `Asset`
 * - `AssetDefinition`
 * - `Nft`
 * - `Trigger`
 * - `Role`
 * - `Configuration`
 * - `Executor`
 * 
 * TODO how to construct, how to use
 */ export type DataEventFilter = lib.VariantUnit<'Any'> | lib.Variant<'Peer', PeerEventFilter> | lib.Variant<'Domain', DomainEventFilter> | lib.Variant<'Account', AccountEventFilter> | lib.Variant<'Asset', AssetEventFilter> | lib.Variant<'AssetDefinition', AssetDefinitionEventFilter> | lib.Variant<'Nft', NftEventFilter> | lib.Variant<'Trigger', TriggerEventFilter> | lib.Variant<'Role', RoleEventFilter> | lib.Variant<'Configuration', ConfigurationEventFilter> | lib.Variant<'Executor', ExecutorEventFilter>;
/**
 * Codec and constructors for enumeration {@link DataEventFilter}.
 */ export declare const DataEventFilter: lib.CodecContainer<DataEventFilter> & {
  Any: lib.VariantUnit<'Any'>;
  Peer: <const T extends PeerEventFilter>(value: T) => lib.Variant<'Peer', T>;
  Domain: <const T extends DomainEventFilter>(value: T) => lib.Variant<'Domain', T>;
  Account: <const T extends AccountEventFilter>(value: T) => lib.Variant<'Account', T>;
  Asset: <const T extends AssetEventFilter>(value: T) => lib.Variant<'Asset', T>;
  AssetDefinition: <const T extends AssetDefinitionEventFilter>(value: T) => lib.Variant<'AssetDefinition', T>;
  Nft: <const T extends NftEventFilter>(value: T) => lib.Variant<'Nft', T>;
  Trigger: <const T extends TriggerEventFilter>(value: T) => lib.Variant<'Trigger', T>;
  Role: <const T extends RoleEventFilter>(value: T) => lib.Variant<'Role', T>;
  Configuration: <const T extends ConfigurationEventFilter>(value: T) => lib.Variant<'Configuration', T>;
  Executor: <const T extends ExecutorEventFilter>(value: T) => lib.Variant<'Executor', T>;
};
/**
 * Structure with named fields.
 */ export interface Schedule {
  start: lib.Timestamp;
  period: lib.Option<lib.Duration>;
}
/**
 * Codec of the structure.
 */ export declare const Schedule: lib.CodecContainer<Schedule>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `PreCommit`
 * - `Schedule`
 * 
 * TODO how to construct, how to use
 */ export type ExecutionTime = lib.VariantUnit<'PreCommit'> | lib.Variant<'Schedule', Schedule>;
/**
 * Codec and constructors for enumeration {@link ExecutionTime}.
 */ export declare const ExecutionTime: lib.CodecContainer<ExecutionTime> & {
  PreCommit: lib.VariantUnit<'PreCommit'>;
  Schedule: <const T extends Schedule>(value: T) => lib.Variant<'Schedule', T>;
};
export type TimeEventFilter = ExecutionTime;
export declare const TimeEventFilter: any;
/**
 * Structure with named fields.
 */ export interface ExecuteTriggerEventFilter {
  triggerId: lib.Option<TriggerId>;
  authority: lib.Option<lib.AccountId>;
}
/**
 * Codec of the structure.
 */ export declare const ExecuteTriggerEventFilter: lib.CodecContainer<ExecuteTriggerEventFilter>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Success`
 * - `Failure`
 * 
 * TODO how to construct, how to use
 */ export type TriggerCompletedOutcomeType = lib.VariantUnit<'Success'> | lib.VariantUnit<'Failure'>;
/**
 * Codec and constructors for enumeration {@link TriggerCompletedOutcomeType}.
 */ export declare const TriggerCompletedOutcomeType: lib.CodecContainer<TriggerCompletedOutcomeType> & {
  Success: lib.VariantUnit<'Success'>;
  Failure: lib.VariantUnit<'Failure'>;
};
/**
 * Structure with named fields.
 */ export interface TriggerCompletedEventFilter {
  triggerId: lib.Option<TriggerId>;
  outcomeType: lib.Option<TriggerCompletedOutcomeType>;
}
/**
 * Codec of the structure.
 */ export declare const TriggerCompletedEventFilter: lib.CodecContainer<TriggerCompletedEventFilter>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Pipeline`
 * - `Data`
 * - `Time`
 * - `ExecuteTrigger`
 * - `TriggerCompleted`
 * 
 * TODO how to construct, how to use
 */ export type EventFilterBox = lib.Variant<'Pipeline', PipelineEventFilterBox> | lib.Variant<'Data', DataEventFilter> | lib.Variant<'Time', TimeEventFilter> | lib.Variant<'ExecuteTrigger', ExecuteTriggerEventFilter> | lib.Variant<'TriggerCompleted', TriggerCompletedEventFilter>;
/**
 * Codec and constructors for enumeration {@link EventFilterBox}.
 */ export declare const EventFilterBox: lib.CodecContainer<EventFilterBox> & {
  Pipeline: {
    Transaction: <const T extends TransactionEventFilter>(value: T) => lib.Variant<'Pipeline', lib.Variant<'Transaction', T>>;
    Block: <const T extends BlockEventFilter>(value: T) => lib.Variant<'Pipeline', lib.Variant<'Block', T>>;
  };
  Data: {
    Any: lib.Variant<'Data', lib.VariantUnit<'Any'>>;
    Peer: <const T extends PeerEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Peer', T>>;
    Domain: <const T extends DomainEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', T>>;
    Account: <const T extends AccountEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Account', T>>;
    Asset: <const T extends AssetEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Asset', T>>;
    AssetDefinition: <const T extends AssetDefinitionEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'AssetDefinition', T>>;
    Nft: <const T extends NftEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Nft', T>>;
    Trigger: <const T extends TriggerEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', T>>;
    Role: <const T extends RoleEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Role', T>>;
    Configuration: <const T extends ConfigurationEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Configuration', T>>;
    Executor: <const T extends ExecutorEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Executor', T>>;
  };
  Time: {
    PreCommit: lib.Variant<'Time', lib.VariantUnit<'PreCommit'>>;
    Schedule: <const T extends Schedule>(value: T) => lib.Variant<'Time', lib.Variant<'Schedule', T>>;
  };
  ExecuteTrigger: <const T extends ExecuteTriggerEventFilter>(value: T) => lib.Variant<'ExecuteTrigger', T>;
  TriggerCompleted: <const T extends TriggerCompletedEventFilter>(value: T) => lib.Variant<'TriggerCompleted', T>;
};
/**
 * Structure with named fields.
 */ export interface Action {
  executable: Executable;
  repeats: Repeats;
  authority: lib.AccountId;
  filter: EventFilterBox;
  metadata: Metadata;
}
/**
 * Codec of the structure.
 */ export declare const Action: lib.CodecContainer<Action>;
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type ActionPredicateAtom = never;
/**
 * Codec for {@link ActionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const ActionPredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */ export type ActionProjectionPredicate = lib.Variant<'Atom', ActionPredicateAtom> | lib.Variant<'Metadata', MetadataProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link ActionProjectionPredicate}.
 */ export declare const ActionProjectionPredicate: lib.CodecContainer<ActionProjectionPredicate> & {
  Metadata: {
    Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */ export type ActionProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Metadata', MetadataProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link ActionProjectionSelector}.
 */ export declare const ActionProjectionSelector: lib.CodecContainer<ActionProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Metadata: {
    Atom: lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>;
    Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Infinitely`
 * - `Once`
 * - `Not`
 * 
 * TODO how to construct, how to use
 */ export type Mintable = lib.VariantUnit<'Infinitely'> | lib.VariantUnit<'Once'> | lib.VariantUnit<'Not'>;
/**
 * Codec and constructors for enumeration {@link Mintable}.
 */ export declare const Mintable: lib.CodecContainer<Mintable> & {
  Infinitely: lib.VariantUnit<'Infinitely'>;
  Once: lib.VariantUnit<'Once'>;
  Not: lib.VariantUnit<'Not'>;
};
export type IpfsPath = lib.String;
export declare const IpfsPath: any;
/**
 * Structure with named fields.
 */ export interface AssetDefinition {
  id: lib.AssetDefinitionId;
  spec: NumericSpec;
  mintable: Mintable;
  logo: lib.Option<IpfsPath>;
  metadata: Metadata;
  ownedBy: lib.AccountId;
  totalQuantity: Numeric;
}
/**
 * Codec of the structure.
 */ export declare const AssetDefinition: lib.CodecContainer<AssetDefinition>;
/**
 * Structure with named fields.
 */ export interface AssetDefinitionTotalQuantityChanged {
  assetDefinition: lib.AssetDefinitionId;
  totalAmount: Numeric;
}
/**
 * Codec of the structure.
 */ export declare const AssetDefinitionTotalQuantityChanged: lib.CodecContainer<AssetDefinitionTotalQuantityChanged>;
/**
 * Structure with named fields.
 */ export interface AssetDefinitionOwnerChanged {
  assetDefinition: lib.AssetDefinitionId;
  newOwner: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const AssetDefinitionOwnerChanged: lib.CodecContainer<AssetDefinitionOwnerChanged>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `MetadataInserted`
 * - `MetadataRemoved`
 * - `MintabilityChanged`
 * - `TotalQuantityChanged`
 * - `OwnerChanged`
 * 
 * TODO how to construct, how to use
 */ export type AssetDefinitionEvent = lib.Variant<'Created', AssetDefinition> | lib.Variant<'Deleted', lib.AssetDefinitionId> | lib.Variant<'MetadataInserted', MetadataChanged<lib.AssetDefinitionId>> | lib.Variant<'MetadataRemoved', MetadataChanged<lib.AssetDefinitionId>> | lib.Variant<'MintabilityChanged', lib.AssetDefinitionId> | lib.Variant<'TotalQuantityChanged', AssetDefinitionTotalQuantityChanged> | lib.Variant<'OwnerChanged', AssetDefinitionOwnerChanged>;
/**
 * Codec and constructors for enumeration {@link AssetDefinitionEvent}.
 */ export declare const AssetDefinitionEvent: lib.CodecContainer<AssetDefinitionEvent> & {
  Created: <const T extends AssetDefinition>(value: T) => lib.Variant<'Created', T>;
  Deleted: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Deleted', T>;
  MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'MetadataInserted', T>;
  MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'MetadataRemoved', T>;
  MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'MintabilityChanged', T>;
  TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T) => lib.Variant<'TotalQuantityChanged', T>;
  OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T) => lib.Variant<'OwnerChanged', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type AssetDefinitionIdPredicateAtom = lib.Variant<'Equals', lib.AssetDefinitionId>;
/**
 * Codec and constructors for enumeration {@link AssetDefinitionIdPredicateAtom}.
 */ export declare const AssetDefinitionIdPredicateAtom: lib.CodecContainer<AssetDefinitionIdPredicateAtom> & {
  Equals: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */ export type AssetDefinitionIdProjectionPredicate = lib.Variant<'Atom', AssetDefinitionIdPredicateAtom> | lib.Variant<'Domain', DomainIdProjectionPredicate> | lib.Variant<'Name', NameProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link AssetDefinitionIdProjectionPredicate}.
 */ export declare const AssetDefinitionIdProjectionPredicate: lib.CodecContainer<AssetDefinitionIdProjectionPredicate> & {
  Atom: {
    Equals: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
  Domain: {
    Atom: {
      Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Name: {
      Atom: {
        Equals: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
        Contains: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>;
        StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>;
        EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>;
      };
    };
  };
  Name: {
    Atom: {
      Equals: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
      Contains: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>;
      StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>;
      EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */ export type AssetDefinitionIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Domain', DomainIdProjectionSelector> | lib.Variant<'Name', NameProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link AssetDefinitionIdProjectionSelector}.
 */ export declare const AssetDefinitionIdProjectionSelector: lib.CodecContainer<AssetDefinitionIdProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Domain: {
    Atom: lib.Variant<'Domain', lib.VariantUnit<'Atom'>>;
    Name: {
      Atom: lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>;
    };
  };
  Name: {
    Atom: lib.Variant<'Name', lib.VariantUnit<'Atom'>>;
  };
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type AssetDefinitionPredicateAtom = never;
/**
 * Codec for {@link AssetDefinitionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const AssetDefinitionPredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */ export type AssetDefinitionProjectionPredicate = lib.Variant<'Atom', AssetDefinitionPredicateAtom> | lib.Variant<'Id', AssetDefinitionIdProjectionPredicate> | lib.Variant<'Metadata', MetadataProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link AssetDefinitionProjectionPredicate}.
 */ export declare const AssetDefinitionProjectionPredicate: lib.CodecContainer<AssetDefinitionProjectionPredicate> & {
  Id: {
    Atom: {
      Equals: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Domain: {
      Atom: {
        Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
      Name: {
        Atom: {
          Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
          Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>;
          StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>;
          EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>;
        };
      };
    };
    Name: {
      Atom: {
        Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
        Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>;
        StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>;
        EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>;
      };
    };
  };
  Metadata: {
    Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */ export type AssetDefinitionProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', AssetDefinitionIdProjectionSelector> | lib.Variant<'Metadata', MetadataProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link AssetDefinitionProjectionSelector}.
 */ export declare const AssetDefinitionProjectionSelector: lib.CodecContainer<AssetDefinitionProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Id: {
    Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>;
    Domain: {
      Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>;
      Name: {
        Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>;
      };
    };
    Name: {
      Atom: lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>;
    };
  };
  Metadata: {
    Atom: lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>;
    Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type AssetIdPredicateAtom = lib.Variant<'Equals', lib.AssetId>;
/**
 * Codec and constructors for enumeration {@link AssetIdPredicateAtom}.
 */ export declare const AssetIdPredicateAtom: lib.CodecContainer<AssetIdPredicateAtom> & {
  Equals: <const T extends lib.AssetId>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Account`
 * - `Definition`
 * 
 * TODO how to construct, how to use
 */ export type AssetIdProjectionPredicate = lib.Variant<'Atom', AssetIdPredicateAtom> | lib.Variant<'Account', AccountIdProjectionPredicate> | lib.Variant<'Definition', AssetDefinitionIdProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link AssetIdProjectionPredicate}.
 */ export declare const AssetIdProjectionPredicate: lib.CodecContainer<AssetIdProjectionPredicate> & {
  Atom: {
    Equals: <const T extends lib.AssetId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
  Account: {
    Atom: {
      Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Account', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Domain: {
      Atom: {
        Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
      Name: {
        Atom: {
          Equals: <const T extends lib.String>(value: T) => lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
          Contains: <const T extends lib.String>(value: T) => lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>;
          StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>;
          EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>;
        };
      };
    };
    Signatory: {
      Atom: {
        Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Account', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
    };
  };
  Definition: {
    Atom: {
      Equals: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Definition', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Domain: {
      Atom: {
        Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
      Name: {
        Atom: {
          Equals: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
          Contains: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>;
          StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>;
          EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>;
        };
      };
    };
    Name: {
      Atom: {
        Equals: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
        Contains: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>;
        StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>;
        EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>;
      };
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Account`
 * - `Definition`
 * 
 * TODO how to construct, how to use
 */ export type AssetIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Account', AccountIdProjectionSelector> | lib.Variant<'Definition', AssetDefinitionIdProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link AssetIdProjectionSelector}.
 */ export declare const AssetIdProjectionSelector: lib.CodecContainer<AssetIdProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Account: {
    Atom: lib.Variant<'Account', lib.VariantUnit<'Atom'>>;
    Domain: {
      Atom: lib.Variant<'Account', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>;
      Name: {
        Atom: lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>;
      };
    };
    Signatory: {
      Atom: lib.Variant<'Account', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>;
    };
  };
  Definition: {
    Atom: lib.Variant<'Definition', lib.VariantUnit<'Atom'>>;
    Domain: {
      Atom: lib.Variant<'Definition', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>;
      Name: {
        Atom: lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>;
      };
    };
    Name: {
      Atom: lib.Variant<'Definition', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>;
    };
  };
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type AssetPredicateAtom = never;
/**
 * Codec for {@link AssetPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const AssetPredicateAtom: lib.CodecContainer<never>;
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type NumericProjectionPredicate = never;
/**
 * Codec for {@link NumericProjectionPredicate}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const NumericProjectionPredicate: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Value`
 * 
 * TODO how to construct, how to use
 */ export type AssetProjectionPredicate = lib.Variant<'Atom', AssetPredicateAtom> | lib.Variant<'Id', AssetIdProjectionPredicate> | lib.Variant<'Value', NumericProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link AssetProjectionPredicate}.
 */ export declare const AssetProjectionPredicate: lib.CodecContainer<AssetProjectionPredicate> & {
  Id: {
    Atom: {
      Equals: <const T extends lib.AssetId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Account: {
      Atom: {
        Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
      Domain: {
        Atom: {
          Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
        };
        Name: {
          Atom: {
            Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>>;
            Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>>;
            StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>>;
            EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>>;
          };
        };
      };
      Signatory: {
        Atom: {
          Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
        };
      };
    };
    Definition: {
      Atom: {
        Equals: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
      Domain: {
        Atom: {
          Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
        };
        Name: {
          Atom: {
            Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>>;
            Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>>;
            StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>>;
            EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>>;
          };
        };
      };
      Name: {
        Atom: {
          Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
          Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>;
          StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>;
          EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>;
        };
      };
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type NumericProjectionSelector = lib.VariantUnit<'Atom'>;
/**
 * Codec and constructors for enumeration {@link NumericProjectionSelector}.
 */ export declare const NumericProjectionSelector: lib.CodecContainer<NumericProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Value`
 * 
 * TODO how to construct, how to use
 */ export type AssetProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', AssetIdProjectionSelector> | lib.Variant<'Value', NumericProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link AssetProjectionSelector}.
 */ export declare const AssetProjectionSelector: lib.CodecContainer<AssetProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Id: {
    Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>;
    Account: {
      Atom: lib.Variant<'Id', lib.Variant<'Account', lib.VariantUnit<'Atom'>>>;
      Domain: {
        Atom: lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>;
        Name: {
          Atom: lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>;
        };
      };
      Signatory: {
        Atom: lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>>;
      };
    };
    Definition: {
      Atom: lib.Variant<'Id', lib.Variant<'Definition', lib.VariantUnit<'Atom'>>>;
      Domain: {
        Atom: lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>;
        Name: {
          Atom: lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>;
        };
      };
      Name: {
        Atom: lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>;
      };
    };
  };
  Value: {
    Atom: lib.Variant<'Value', lib.VariantUnit<'Atom'>>;
  };
};
/**
 * Structure with named fields.
 */ export interface BlockHeader {
  height: lib.NonZero<lib.U64>;
  prevBlockHash: lib.Option<lib.Hash>;
  transactionsHash: lib.Option<lib.Hash>;
  creationTime: lib.Timestamp;
  viewChangeIndex: lib.U32;
}
/**
 * Codec of the structure.
 */ export declare const BlockHeader: lib.CodecContainer<BlockHeader>;
/**
 * Structure with named fields.
 */ export interface BlockEvent {
  header: BlockHeader;
  status: BlockStatus;
}
/**
 * Codec of the structure.
 */ export declare const BlockEvent: lib.CodecContainer<BlockEvent>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type BlockHeaderHashPredicateAtom = lib.Variant<'Equals', lib.Hash>;
/**
 * Codec and constructors for enumeration {@link BlockHeaderHashPredicateAtom}.
 */ export declare const BlockHeaderHashPredicateAtom: lib.CodecContainer<BlockHeaderHashPredicateAtom> & {
  Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type BlockHeaderHashProjectionPredicate = lib.Variant<'Atom', BlockHeaderHashPredicateAtom>;
/**
 * Codec and constructors for enumeration {@link BlockHeaderHashProjectionPredicate}.
 */ export declare const BlockHeaderHashProjectionPredicate: lib.CodecContainer<BlockHeaderHashProjectionPredicate> & {
  Atom: {
    Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type BlockHeaderHashProjectionSelector = lib.VariantUnit<'Atom'>;
/**
 * Codec and constructors for enumeration {@link BlockHeaderHashProjectionSelector}.
 */ export declare const BlockHeaderHashProjectionSelector: lib.CodecContainer<BlockHeaderHashProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type BlockHeaderPredicateAtom = never;
/**
 * Codec for {@link BlockHeaderPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const BlockHeaderPredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Hash`
 * 
 * TODO how to construct, how to use
 */ export type BlockHeaderProjectionPredicate = lib.Variant<'Atom', BlockHeaderPredicateAtom> | lib.Variant<'Hash', BlockHeaderHashProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link BlockHeaderProjectionPredicate}.
 */ export declare const BlockHeaderProjectionPredicate: lib.CodecContainer<BlockHeaderProjectionPredicate> & {
  Hash: {
    Atom: {
      Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Hash`
 * 
 * TODO how to construct, how to use
 */ export type BlockHeaderProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Hash', BlockHeaderHashProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link BlockHeaderProjectionSelector}.
 */ export declare const BlockHeaderProjectionSelector: lib.CodecContainer<BlockHeaderProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Hash: {
    Atom: lib.Variant<'Hash', lib.VariantUnit<'Atom'>>;
  };
};
/**
 * Structure with named fields.
 */ export interface BlockSignature {
  peerTopologyIndex: lib.U64;
  signature: lib.Signature;
}
/**
 * Codec of the structure.
 */ export declare const BlockSignature: lib.CodecContainer<BlockSignature>;
export type ChainId = lib.String;
export declare const ChainId: any;
/**
 * Structure with named fields.
 */ export interface TransactionPayload {
  chain: ChainId;
  authority: lib.AccountId;
  creationTime: lib.Timestamp;
  instructions: Executable;
  timeToLive: lib.Option<lib.NonZero<lib.Duration>>;
  nonce: lib.Option<lib.NonZero<lib.U32>>;
  metadata: Metadata;
}
/**
 * Codec of the structure.
 */ export declare const TransactionPayload: lib.CodecContainer<TransactionPayload>;
/**
 * Structure with named fields.
 */ export interface SignedTransactionV1 {
  signature: lib.Signature;
  payload: TransactionPayload;
}
/**
 * Codec of the structure.
 */ export declare const SignedTransactionV1: lib.CodecContainer<SignedTransactionV1>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `V1`
 * 
 * TODO how to construct, how to use
 */ export type SignedTransaction = lib.Variant<'V1', SignedTransactionV1>;
/**
 * Codec and constructors for enumeration {@link SignedTransaction}.
 */ export declare const SignedTransaction: lib.CodecContainer<SignedTransaction> & {
  V1: <const T extends SignedTransactionV1>(value: T) => lib.Variant<'V1', T>;
};
/**
 * Structure with named fields.
 */ export interface BlockPayload {
  header: BlockHeader;
  transactions: lib.Vec<SignedTransaction>;
}
/**
 * Codec of the structure.
 */ export declare const BlockPayload: lib.CodecContainer<BlockPayload>;
/**
 * Structure with named fields.
 */ export interface TransactionErrorWithIndex {
  index: lib.U64;
  error: TransactionRejectionReason;
}
/**
 * Codec of the structure.
 */ export declare const TransactionErrorWithIndex: lib.CodecContainer<TransactionErrorWithIndex>;
export type TransactionErrors = lib.BTreeSet<TransactionErrorWithIndex>;
export declare const TransactionErrors: lib.CodecContainer<TransactionErrors>;
/**
 * Structure with named fields.
 */ export interface SignedBlockV1 {
  signatures: lib.Vec<BlockSignature>;
  payload: BlockPayload;
  errors: TransactionErrors;
}
/**
 * Codec of the structure.
 */ export declare const SignedBlockV1: lib.CodecContainer<SignedBlockV1>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `V1`
 * 
 * TODO how to construct, how to use
 */ export type SignedBlock = lib.Variant<'V1', SignedBlockV1>;
/**
 * Codec and constructors for enumeration {@link SignedBlock}.
 */ export declare const SignedBlock: lib.CodecContainer<SignedBlock> & {
  V1: <const T extends SignedBlockV1>(value: T) => lib.Variant<'V1', T>;
};
export type BlockMessage = SignedBlock;
export declare const BlockMessage: any;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `MaxTransactions`
 * 
 * TODO how to construct, how to use
 */ export type BlockParameter = lib.Variant<'MaxTransactions', lib.NonZero<lib.U64>>;
/**
 * Codec and constructors for enumeration {@link BlockParameter}.
 */ export declare const BlockParameter: lib.CodecContainer<BlockParameter> & {
  MaxTransactions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'MaxTransactions', T>;
};
/**
 * Structure with named fields.
 */ export interface BlockParameters {
  maxTransactions: lib.NonZero<lib.U64>;
}
/**
 * Codec of the structure.
 */ export declare const BlockParameters: lib.CodecContainer<BlockParameters>;
/**
 * Structure with named fields.
 */ export interface BlockSubscriptionRequest {
  fromBlockHeight: lib.NonZero<lib.U64>;
}
/**
 * Codec of the structure.
 */ export declare const BlockSubscriptionRequest: lib.CodecContainer<BlockSubscriptionRequest>;
/**
 * Structure with named fields and generic parameters.
 */ export interface Burn<T0, T1> {
  object: T0;
  destination: T1;
}
/**
 * Codec constructor for the structure with generic parameters.
 */ export declare const Burn: {
  readonly with: <T0, T1>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>) => lib.GenCodec<Burn<T0, T1>>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Asset`
 * - `TriggerRepetitions`
 * 
 * TODO how to construct, how to use
 */ export type BurnBox = lib.Variant<'Asset', Burn<Numeric, lib.AssetId>> | lib.Variant<'TriggerRepetitions', Burn<lib.U32, TriggerId>>;
/**
 * Codec and constructors for enumeration {@link BurnBox}.
 */ export declare const BurnBox: lib.CodecContainer<BurnBox> & {
  Asset: <const T extends Burn<Numeric, lib.AssetId>>(value: T) => lib.Variant<'Asset', T>;
  TriggerRepetitions: <const T extends Burn<lib.U32, TriggerId>>(value: T) => lib.Variant<'TriggerRepetitions', T>;
};
/**
 * Structure with named fields.
 */ export interface CanBurnAsset {
  asset: lib.AssetId;
}
/**
 * Codec of the structure.
 */ export declare const CanBurnAsset: lib.CodecContainer<CanBurnAsset>;
/**
 * Structure with named fields.
 */ export interface CanBurnAssetWithDefinition {
  assetDefinition: lib.AssetDefinitionId;
}
/**
 * Codec of the structure.
 */ export declare const CanBurnAssetWithDefinition: lib.CodecContainer<CanBurnAssetWithDefinition>;
/**
 * Structure with named fields.
 */ export interface CanExecuteTrigger {
  trigger: TriggerId;
}
/**
 * Codec of the structure.
 */ export declare const CanExecuteTrigger: lib.CodecContainer<CanExecuteTrigger>;
/**
 * Structure with named fields.
 */ export interface CanMintAsset {
  asset: lib.AssetId;
}
/**
 * Codec of the structure.
 */ export declare const CanMintAsset: lib.CodecContainer<CanMintAsset>;
/**
 * Structure with named fields.
 */ export interface CanMintAssetWithDefinition {
  assetDefinition: lib.AssetDefinitionId;
}
/**
 * Codec of the structure.
 */ export declare const CanMintAssetWithDefinition: lib.CodecContainer<CanMintAssetWithDefinition>;
/**
 * Structure with named fields.
 */ export interface CanModifyAccountMetadata {
  account: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const CanModifyAccountMetadata: lib.CodecContainer<CanModifyAccountMetadata>;
/**
 * Structure with named fields.
 */ export interface CanModifyAssetDefinitionMetadata {
  assetDefinition: lib.AssetDefinitionId;
}
/**
 * Codec of the structure.
 */ export declare const CanModifyAssetDefinitionMetadata: lib.CodecContainer<CanModifyAssetDefinitionMetadata>;
/**
 * Structure with named fields.
 */ export interface CanModifyDomainMetadata {
  domain: lib.DomainId;
}
/**
 * Codec of the structure.
 */ export declare const CanModifyDomainMetadata: lib.CodecContainer<CanModifyDomainMetadata>;
/**
 * Structure with named fields.
 */ export interface CanModifyNftMetadata {
  nft: lib.NftId;
}
/**
 * Codec of the structure.
 */ export declare const CanModifyNftMetadata: lib.CodecContainer<CanModifyNftMetadata>;
/**
 * Structure with named fields.
 */ export interface CanModifyTrigger {
  trigger: TriggerId;
}
/**
 * Codec of the structure.
 */ export declare const CanModifyTrigger: lib.CodecContainer<CanModifyTrigger>;
/**
 * Structure with named fields.
 */ export interface CanModifyTriggerMetadata {
  trigger: TriggerId;
}
/**
 * Codec of the structure.
 */ export declare const CanModifyTriggerMetadata: lib.CodecContainer<CanModifyTriggerMetadata>;
/**
 * Structure with named fields.
 */ export interface CanRegisterAccount {
  domain: lib.DomainId;
}
/**
 * Codec of the structure.
 */ export declare const CanRegisterAccount: lib.CodecContainer<CanRegisterAccount>;
/**
 * Structure with named fields.
 */ export interface CanRegisterAssetDefinition {
  domain: lib.DomainId;
}
/**
 * Codec of the structure.
 */ export declare const CanRegisterAssetDefinition: lib.CodecContainer<CanRegisterAssetDefinition>;
/**
 * Structure with named fields.
 */ export interface CanRegisterNft {
  domain: lib.DomainId;
}
/**
 * Codec of the structure.
 */ export declare const CanRegisterNft: lib.CodecContainer<CanRegisterNft>;
/**
 * Structure with named fields.
 */ export interface CanRegisterTrigger {
  authority: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const CanRegisterTrigger: lib.CodecContainer<CanRegisterTrigger>;
/**
 * Structure with named fields.
 */ export interface CanTransferAsset {
  asset: lib.AssetId;
}
/**
 * Codec of the structure.
 */ export declare const CanTransferAsset: lib.CodecContainer<CanTransferAsset>;
/**
 * Structure with named fields.
 */ export interface CanTransferAssetWithDefinition {
  assetDefinition: lib.AssetDefinitionId;
}
/**
 * Codec of the structure.
 */ export declare const CanTransferAssetWithDefinition: lib.CodecContainer<CanTransferAssetWithDefinition>;
/**
 * Structure with named fields.
 */ export interface CanTransferNft {
  nft: lib.NftId;
}
/**
 * Codec of the structure.
 */ export declare const CanTransferNft: lib.CodecContainer<CanTransferNft>;
/**
 * Structure with named fields.
 */ export interface CanUnregisterAccount {
  account: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const CanUnregisterAccount: lib.CodecContainer<CanUnregisterAccount>;
/**
 * Structure with named fields.
 */ export interface CanUnregisterAssetDefinition {
  assetDefinition: lib.AssetDefinitionId;
}
/**
 * Codec of the structure.
 */ export declare const CanUnregisterAssetDefinition: lib.CodecContainer<CanUnregisterAssetDefinition>;
/**
 * Structure with named fields.
 */ export interface CanUnregisterDomain {
  domain: lib.DomainId;
}
/**
 * Codec of the structure.
 */ export declare const CanUnregisterDomain: lib.CodecContainer<CanUnregisterDomain>;
/**
 * Structure with named fields.
 */ export interface CanUnregisterNft {
  nft: lib.NftId;
}
/**
 * Codec of the structure.
 */ export declare const CanUnregisterNft: lib.CodecContainer<CanUnregisterNft>;
/**
 * Structure with named fields.
 */ export interface CanUnregisterTrigger {
  trigger: TriggerId;
}
/**
 * Codec of the structure.
 */ export declare const CanUnregisterTrigger: lib.CodecContainer<CanUnregisterTrigger>;
/**
 * Structure with named fields.
 */ export interface CommittedTransaction {
  blockHash: lib.Hash;
  value: SignedTransaction;
  error: lib.Option<TransactionRejectionReason>;
}
/**
 * Codec of the structure.
 */ export declare const CommittedTransaction: lib.CodecContainer<CommittedTransaction>;
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type CommittedTransactionPredicateAtom = never;
/**
 * Codec for {@link CommittedTransactionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const CommittedTransactionPredicateAtom: lib.CodecContainer<never>;
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type SignedTransactionPredicateAtom = never;
/**
 * Codec for {@link SignedTransactionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const SignedTransactionPredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type TransactionHashPredicateAtom = lib.Variant<'Equals', lib.Hash>;
/**
 * Codec and constructors for enumeration {@link TransactionHashPredicateAtom}.
 */ export declare const TransactionHashPredicateAtom: lib.CodecContainer<TransactionHashPredicateAtom> & {
  Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type TransactionHashProjectionPredicate = lib.Variant<'Atom', TransactionHashPredicateAtom>;
/**
 * Codec and constructors for enumeration {@link TransactionHashProjectionPredicate}.
 */ export declare const TransactionHashProjectionPredicate: lib.CodecContainer<TransactionHashProjectionPredicate> & {
  Atom: {
    Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Hash`
 * - `Authority`
 * 
 * TODO how to construct, how to use
 */ export type SignedTransactionProjectionPredicate = lib.Variant<'Atom', SignedTransactionPredicateAtom> | lib.Variant<'Hash', TransactionHashProjectionPredicate> | lib.Variant<'Authority', AccountIdProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link SignedTransactionProjectionPredicate}.
 */ export declare const SignedTransactionProjectionPredicate: lib.CodecContainer<SignedTransactionProjectionPredicate> & {
  Hash: {
    Atom: {
      Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
  };
  Authority: {
    Atom: {
      Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Authority', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Domain: {
      Atom: {
        Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
      Name: {
        Atom: {
          Equals: <const T extends lib.String>(value: T) => lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
          Contains: <const T extends lib.String>(value: T) => lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>;
          StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>;
          EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>;
        };
      };
    };
    Signatory: {
      Atom: {
        Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Authority', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `IsSome`
 * 
 * TODO how to construct, how to use
 */ export type TransactionErrorPredicateAtom = lib.VariantUnit<'IsSome'>;
/**
 * Codec and constructors for enumeration {@link TransactionErrorPredicateAtom}.
 */ export declare const TransactionErrorPredicateAtom: lib.CodecContainer<TransactionErrorPredicateAtom> & {
  IsSome: lib.VariantUnit<'IsSome'>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type TransactionErrorProjectionPredicate = lib.Variant<'Atom', TransactionErrorPredicateAtom>;
/**
 * Codec and constructors for enumeration {@link TransactionErrorProjectionPredicate}.
 */ export declare const TransactionErrorProjectionPredicate: lib.CodecContainer<TransactionErrorProjectionPredicate> & {
  Atom: {
    IsSome: lib.Variant<'Atom', lib.VariantUnit<'IsSome'>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `BlockHash`
 * - `Value`
 * - `Error`
 * 
 * TODO how to construct, how to use
 */ export type CommittedTransactionProjectionPredicate = lib.Variant<'Atom', CommittedTransactionPredicateAtom> | lib.Variant<'BlockHash', BlockHeaderHashProjectionPredicate> | lib.Variant<'Value', SignedTransactionProjectionPredicate> | lib.Variant<'Error', TransactionErrorProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link CommittedTransactionProjectionPredicate}.
 */ export declare const CommittedTransactionProjectionPredicate: lib.CodecContainer<CommittedTransactionProjectionPredicate> & {
  BlockHash: {
    Atom: {
      Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'BlockHash', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
  };
  Value: {
    Hash: {
      Atom: {
        Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Value', lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
    };
    Authority: {
      Atom: {
        Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
      Domain: {
        Atom: {
          Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
        };
        Name: {
          Atom: {
            Equals: <const T extends lib.String>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>>;
            Contains: <const T extends lib.String>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>>;
            StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>>;
            EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>>;
          };
        };
      };
      Signatory: {
        Atom: {
          Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
        };
      };
    };
  };
  Error: {
    Atom: {
      IsSome: lib.Variant<'Error', lib.Variant<'Atom', lib.VariantUnit<'IsSome'>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type TransactionHashProjectionSelector = lib.VariantUnit<'Atom'>;
/**
 * Codec and constructors for enumeration {@link TransactionHashProjectionSelector}.
 */ export declare const TransactionHashProjectionSelector: lib.CodecContainer<TransactionHashProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Hash`
 * - `Authority`
 * 
 * TODO how to construct, how to use
 */ export type SignedTransactionProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Hash', TransactionHashProjectionSelector> | lib.Variant<'Authority', AccountIdProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link SignedTransactionProjectionSelector}.
 */ export declare const SignedTransactionProjectionSelector: lib.CodecContainer<SignedTransactionProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Hash: {
    Atom: lib.Variant<'Hash', lib.VariantUnit<'Atom'>>;
  };
  Authority: {
    Atom: lib.Variant<'Authority', lib.VariantUnit<'Atom'>>;
    Domain: {
      Atom: lib.Variant<'Authority', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>;
      Name: {
        Atom: lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>;
      };
    };
    Signatory: {
      Atom: lib.Variant<'Authority', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type TransactionErrorProjectionSelector = lib.VariantUnit<'Atom'>;
/**
 * Codec and constructors for enumeration {@link TransactionErrorProjectionSelector}.
 */ export declare const TransactionErrorProjectionSelector: lib.CodecContainer<TransactionErrorProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `BlockHash`
 * - `Value`
 * - `Error`
 * 
 * TODO how to construct, how to use
 */ export type CommittedTransactionProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'BlockHash', BlockHeaderHashProjectionSelector> | lib.Variant<'Value', SignedTransactionProjectionSelector> | lib.Variant<'Error', TransactionErrorProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link CommittedTransactionProjectionSelector}.
 */ export declare const CommittedTransactionProjectionSelector: lib.CodecContainer<CommittedTransactionProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  BlockHash: {
    Atom: lib.Variant<'BlockHash', lib.VariantUnit<'Atom'>>;
  };
  Value: {
    Atom: lib.Variant<'Value', lib.VariantUnit<'Atom'>>;
    Hash: {
      Atom: lib.Variant<'Value', lib.Variant<'Hash', lib.VariantUnit<'Atom'>>>;
    };
    Authority: {
      Atom: lib.Variant<'Value', lib.Variant<'Authority', lib.VariantUnit<'Atom'>>>;
      Domain: {
        Atom: lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>;
        Name: {
          Atom: lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>;
        };
      };
      Signatory: {
        Atom: lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>>;
      };
    };
  };
  Error: {
    Atom: lib.Variant<'Error', lib.VariantUnit<'Atom'>>;
  };
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type DomainPredicateAtom = never;
/**
 * Codec for {@link DomainPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const DomainPredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */ export type DomainProjectionPredicate = lib.Variant<'Atom', DomainPredicateAtom> | lib.Variant<'Id', DomainIdProjectionPredicate> | lib.Variant<'Metadata', MetadataProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link DomainProjectionPredicate}.
 */ export declare const DomainProjectionPredicate: lib.CodecContainer<DomainProjectionPredicate> & {
  Id: {
    Atom: {
      Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Name: {
      Atom: {
        Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
        Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>;
        StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>;
        EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>;
      };
    };
  };
  Metadata: {
    Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>>;
  };
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type NftPredicateAtom = never;
/**
 * Codec for {@link NftPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const NftPredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type NftIdPredicateAtom = lib.Variant<'Equals', lib.NftId>;
/**
 * Codec and constructors for enumeration {@link NftIdPredicateAtom}.
 */ export declare const NftIdPredicateAtom: lib.CodecContainer<NftIdPredicateAtom> & {
  Equals: <const T extends lib.NftId>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */ export type NftIdProjectionPredicate = lib.Variant<'Atom', NftIdPredicateAtom> | lib.Variant<'Domain', DomainIdProjectionPredicate> | lib.Variant<'Name', NameProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link NftIdProjectionPredicate}.
 */ export declare const NftIdProjectionPredicate: lib.CodecContainer<NftIdProjectionPredicate> & {
  Atom: {
    Equals: <const T extends lib.NftId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
  Domain: {
    Atom: {
      Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Name: {
      Atom: {
        Equals: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
        Contains: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>;
        StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>;
        EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>;
      };
    };
  };
  Name: {
    Atom: {
      Equals: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
      Contains: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>;
      StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>;
      EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * - `AccountId`
 * 
 * TODO how to construct, how to use
 */ export type NftProjectionPredicate = lib.Variant<'Atom', NftPredicateAtom> | lib.Variant<'Id', NftIdProjectionPredicate> | lib.Variant<'Metadata', MetadataProjectionPredicate> | lib.Variant<'AccountId', AccountIdProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link NftProjectionPredicate}.
 */ export declare const NftProjectionPredicate: lib.CodecContainer<NftProjectionPredicate> & {
  Id: {
    Atom: {
      Equals: <const T extends lib.NftId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Domain: {
      Atom: {
        Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
      Name: {
        Atom: {
          Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
          Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>;
          StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>;
          EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>;
        };
      };
    };
    Name: {
      Atom: {
        Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
        Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>;
        StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>;
        EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>;
      };
    };
  };
  Metadata: {
    Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>>;
  };
  AccountId: {
    Atom: {
      Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'AccountId', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Domain: {
      Atom: {
        Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
      Name: {
        Atom: {
          Equals: <const T extends lib.String>(value: T) => lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>;
          Contains: <const T extends lib.String>(value: T) => lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>;
          StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>;
          EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>;
        };
      };
    };
    Signatory: {
      Atom: {
        Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'AccountId', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
    };
  };
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type PeerIdPredicateAtom = never;
/**
 * Codec for {@link PeerIdPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const PeerIdPredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `PublicKey`
 * 
 * TODO how to construct, how to use
 */ export type PeerIdProjectionPredicate = lib.Variant<'Atom', PeerIdPredicateAtom> | lib.Variant<'PublicKey', PublicKeyProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link PeerIdProjectionPredicate}.
 */ export declare const PeerIdProjectionPredicate: lib.CodecContainer<PeerIdProjectionPredicate> & {
  PublicKey: {
    Atom: {
      Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'PublicKey', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
  };
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type PermissionProjectionPredicate = never;
/**
 * Codec for {@link PermissionProjectionPredicate}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const PermissionProjectionPredicate: lib.CodecContainer<never>;
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type RolePredicateAtom = never;
/**
 * Codec for {@link RolePredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const RolePredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type RoleIdPredicateAtom = lib.Variant<'Equals', RoleId>;
/**
 * Codec and constructors for enumeration {@link RoleIdPredicateAtom}.
 */ export declare const RoleIdPredicateAtom: lib.CodecContainer<RoleIdPredicateAtom> & {
  Equals: <const T extends RoleId>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */ export type RoleIdProjectionPredicate = lib.Variant<'Atom', RoleIdPredicateAtom> | lib.Variant<'Name', NameProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link RoleIdProjectionPredicate}.
 */ export declare const RoleIdProjectionPredicate: lib.CodecContainer<RoleIdProjectionPredicate> & {
  Atom: {
    Equals: <const T extends RoleId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
  Name: {
    Atom: {
      Equals: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
      Contains: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>;
      StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>;
      EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * 
 * TODO how to construct, how to use
 */ export type RoleProjectionPredicate = lib.Variant<'Atom', RolePredicateAtom> | lib.Variant<'Id', RoleIdProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link RoleProjectionPredicate}.
 */ export declare const RoleProjectionPredicate: lib.CodecContainer<RoleProjectionPredicate> & {
  Id: {
    Atom: {
      Equals: <const T extends RoleId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Name: {
      Atom: {
        Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
        Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>;
        StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>;
        EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>;
      };
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `IsEmpty`
 * 
 * TODO how to construct, how to use
 */ export type SignedBlockPredicateAtom = lib.VariantUnit<'IsEmpty'>;
/**
 * Codec and constructors for enumeration {@link SignedBlockPredicateAtom}.
 */ export declare const SignedBlockPredicateAtom: lib.CodecContainer<SignedBlockPredicateAtom> & {
  IsEmpty: lib.VariantUnit<'IsEmpty'>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Header`
 * 
 * TODO how to construct, how to use
 */ export type SignedBlockProjectionPredicate = lib.Variant<'Atom', SignedBlockPredicateAtom> | lib.Variant<'Header', BlockHeaderProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link SignedBlockProjectionPredicate}.
 */ export declare const SignedBlockProjectionPredicate: lib.CodecContainer<SignedBlockProjectionPredicate> & {
  Atom: {
    IsEmpty: lib.Variant<'Atom', lib.VariantUnit<'IsEmpty'>>;
  };
  Header: {
    Hash: {
      Atom: {
        Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Header', lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
      };
    };
  };
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type TriggerPredicateAtom = never;
/**
 * Codec for {@link TriggerPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const TriggerPredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */ export type TriggerIdPredicateAtom = lib.Variant<'Equals', TriggerId>;
/**
 * Codec and constructors for enumeration {@link TriggerIdPredicateAtom}.
 */ export declare const TriggerIdPredicateAtom: lib.CodecContainer<TriggerIdPredicateAtom> & {
  Equals: <const T extends TriggerId>(value: T) => lib.Variant<'Equals', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */ export type TriggerIdProjectionPredicate = lib.Variant<'Atom', TriggerIdPredicateAtom> | lib.Variant<'Name', NameProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link TriggerIdProjectionPredicate}.
 */ export declare const TriggerIdProjectionPredicate: lib.CodecContainer<TriggerIdProjectionPredicate> & {
  Atom: {
    Equals: <const T extends TriggerId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>;
  };
  Name: {
    Atom: {
      Equals: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
      Contains: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>;
      StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>;
      EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Action`
 * 
 * TODO how to construct, how to use
 */ export type TriggerProjectionPredicate = lib.Variant<'Atom', TriggerPredicateAtom> | lib.Variant<'Id', TriggerIdProjectionPredicate> | lib.Variant<'Action', ActionProjectionPredicate>;
/**
 * Codec and constructors for enumeration {@link TriggerProjectionPredicate}.
 */ export declare const TriggerProjectionPredicate: lib.CodecContainer<TriggerProjectionPredicate> & {
  Id: {
    Atom: {
      Equals: <const T extends TriggerId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>>;
    };
    Name: {
      Atom: {
        Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>;
        Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>;
        StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>;
        EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>;
      };
    };
  };
  Action: {
    Metadata: {
      Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Action', lib.Variant<'Metadata', lib.Variant<'Key', T>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `BlockTime`
 * - `CommitTime`
 * - `MaxClockDrift`
 * 
 * TODO how to construct, how to use
 */ export type SumeragiParameter = lib.Variant<'BlockTime', lib.Duration> | lib.Variant<'CommitTime', lib.Duration> | lib.Variant<'MaxClockDrift', lib.Duration>;
/**
 * Codec and constructors for enumeration {@link SumeragiParameter}.
 */ export declare const SumeragiParameter: lib.CodecContainer<SumeragiParameter> & {
  BlockTime: <const T extends lib.Duration>(value: T) => lib.Variant<'BlockTime', T>;
  CommitTime: <const T extends lib.Duration>(value: T) => lib.Variant<'CommitTime', T>;
  MaxClockDrift: <const T extends lib.Duration>(value: T) => lib.Variant<'MaxClockDrift', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `MaxInstructions`
 * - `SmartContractSize`
 * 
 * TODO how to construct, how to use
 */ export type TransactionParameter = lib.Variant<'MaxInstructions', lib.NonZero<lib.U64>> | lib.Variant<'SmartContractSize', lib.NonZero<lib.U64>>;
/**
 * Codec and constructors for enumeration {@link TransactionParameter}.
 */ export declare const TransactionParameter: lib.CodecContainer<TransactionParameter> & {
  MaxInstructions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'MaxInstructions', T>;
  SmartContractSize: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SmartContractSize', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Fuel`
 * - `Memory`
 * 
 * TODO how to construct, how to use
 */ export type SmartContractParameter = lib.Variant<'Fuel', lib.NonZero<lib.U64>> | lib.Variant<'Memory', lib.NonZero<lib.U64>>;
/**
 * Codec and constructors for enumeration {@link SmartContractParameter}.
 */ export declare const SmartContractParameter: lib.CodecContainer<SmartContractParameter> & {
  Fuel: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Fuel', T>;
  Memory: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Memory', T>;
};
/**
 * Structure with named fields.
 */ export interface CustomParameter {
  id: CustomParameterId;
  payload: lib.Json;
}
/**
 * Codec of the structure.
 */ export declare const CustomParameter: lib.CodecContainer<CustomParameter>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Sumeragi`
 * - `Block`
 * - `Transaction`
 * - `SmartContract`
 * - `Executor`
 * - `Custom`
 * 
 * TODO how to construct, how to use
 */ export type Parameter = lib.Variant<'Sumeragi', SumeragiParameter> | lib.Variant<'Block', BlockParameter> | lib.Variant<'Transaction', TransactionParameter> | lib.Variant<'SmartContract', SmartContractParameter> | lib.Variant<'Executor', SmartContractParameter> | lib.Variant<'Custom', CustomParameter>;
/**
 * Codec and constructors for enumeration {@link Parameter}.
 */ export declare const Parameter: lib.CodecContainer<Parameter> & {
  Sumeragi: {
    BlockTime: <const T extends lib.Duration>(value: T) => lib.Variant<'Sumeragi', lib.Variant<'BlockTime', T>>;
    CommitTime: <const T extends lib.Duration>(value: T) => lib.Variant<'Sumeragi', lib.Variant<'CommitTime', T>>;
    MaxClockDrift: <const T extends lib.Duration>(value: T) => lib.Variant<'Sumeragi', lib.Variant<'MaxClockDrift', T>>;
  };
  Block: {
    MaxTransactions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Block', lib.Variant<'MaxTransactions', T>>;
  };
  Transaction: {
    MaxInstructions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Transaction', lib.Variant<'MaxInstructions', T>>;
    SmartContractSize: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Transaction', lib.Variant<'SmartContractSize', T>>;
  };
  SmartContract: {
    Fuel: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SmartContract', lib.Variant<'Fuel', T>>;
    Memory: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SmartContract', lib.Variant<'Memory', T>>;
  };
  Executor: {
    Fuel: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Executor', lib.Variant<'Fuel', T>>;
    Memory: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Executor', lib.Variant<'Memory', T>>;
  };
  Custom: <const T extends CustomParameter>(value: T) => lib.Variant<'Custom', T>;
};
/**
 * Structure with named fields.
 */ export interface ParameterChanged {
  oldValue: Parameter;
  newValue: Parameter;
}
/**
 * Codec of the structure.
 */ export declare const ParameterChanged: lib.CodecContainer<ParameterChanged>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Changed`
 * 
 * TODO how to construct, how to use
 */ export type ConfigurationEvent = lib.Variant<'Changed', ParameterChanged>;
/**
 * Codec and constructors for enumeration {@link ConfigurationEvent}.
 */ export declare const ConfigurationEvent: lib.CodecContainer<ConfigurationEvent> & {
  Changed: <const T extends ParameterChanged>(value: T) => lib.Variant<'Changed', T>;
};
/**
 * Structure with named fields.
 */ export interface CustomInstruction {
  payload: lib.Json;
}
/**
 * Codec of the structure.
 */ export declare const CustomInstruction: lib.CodecContainer<CustomInstruction>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Added`
 * - `Removed`
 * 
 * TODO how to construct, how to use
 */ export type PeerEvent = lib.Variant<'Added', PeerId> | lib.Variant<'Removed', PeerId>;
/**
 * Codec and constructors for enumeration {@link PeerEvent}.
 */ export declare const PeerEvent: lib.CodecContainer<PeerEvent> & {
  Added: <const T extends PeerId>(value: T) => lib.Variant<'Added', T>;
  Removed: <const T extends PeerId>(value: T) => lib.Variant<'Removed', T>;
};
/**
 * Structure with named fields.
 */ export interface Domain {
  id: lib.DomainId;
  logo: lib.Option<IpfsPath>;
  metadata: Metadata;
  ownedBy: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const Domain: lib.CodecContainer<Domain>;
/**
 * Structure with named fields.
 */ export interface Nft {
  id: lib.NftId;
  content: Metadata;
  ownedBy: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const Nft: lib.CodecContainer<Nft>;
/**
 * Structure with named fields.
 */ export interface NftOwnerChanged {
  nft: lib.NftId;
  newOwner: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const NftOwnerChanged: lib.CodecContainer<NftOwnerChanged>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `MetadataInserted`
 * - `MetadataRemoved`
 * - `OwnerChanged`
 * 
 * TODO how to construct, how to use
 */ export type NftEvent = lib.Variant<'Created', Nft> | lib.Variant<'Deleted', lib.NftId> | lib.Variant<'MetadataInserted', MetadataChanged<lib.NftId>> | lib.Variant<'MetadataRemoved', MetadataChanged<lib.NftId>> | lib.Variant<'OwnerChanged', NftOwnerChanged>;
/**
 * Codec and constructors for enumeration {@link NftEvent}.
 */ export declare const NftEvent: lib.CodecContainer<NftEvent> & {
  Created: <const T extends Nft>(value: T) => lib.Variant<'Created', T>;
  Deleted: <const T extends lib.NftId>(value: T) => lib.Variant<'Deleted', T>;
  MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'MetadataInserted', T>;
  MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'MetadataRemoved', T>;
  OwnerChanged: <const T extends NftOwnerChanged>(value: T) => lib.Variant<'OwnerChanged', T>;
};
/**
 * Structure with named fields.
 */ export interface DomainOwnerChanged {
  domain: lib.DomainId;
  newOwner: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const DomainOwnerChanged: lib.CodecContainer<DomainOwnerChanged>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `AssetDefinition`
 * - `Nft`
 * - `Account`
 * - `MetadataInserted`
 * - `MetadataRemoved`
 * - `OwnerChanged`
 * 
 * TODO how to construct, how to use
 */ export type DomainEvent = lib.Variant<'Created', Domain> | lib.Variant<'Deleted', lib.DomainId> | lib.Variant<'AssetDefinition', AssetDefinitionEvent> | lib.Variant<'Nft', NftEvent> | lib.Variant<'Account', AccountEvent> | lib.Variant<'MetadataInserted', MetadataChanged<lib.DomainId>> | lib.Variant<'MetadataRemoved', MetadataChanged<lib.DomainId>> | lib.Variant<'OwnerChanged', DomainOwnerChanged>;
/**
 * Codec and constructors for enumeration {@link DomainEvent}.
 */ export declare const DomainEvent: lib.CodecContainer<DomainEvent> & {
  Created: <const T extends Domain>(value: T) => lib.Variant<'Created', T>;
  Deleted: <const T extends lib.DomainId>(value: T) => lib.Variant<'Deleted', T>;
  AssetDefinition: {
    Created: <const T extends AssetDefinition>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'Created', T>>;
    Deleted: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'Deleted', T>>;
    MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'MetadataInserted', T>>;
    MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'MetadataRemoved', T>>;
    MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'MintabilityChanged', T>>;
    TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'TotalQuantityChanged', T>>;
    OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'OwnerChanged', T>>;
  };
  Nft: {
    Created: <const T extends Nft>(value: T) => lib.Variant<'Nft', lib.Variant<'Created', T>>;
    Deleted: <const T extends lib.NftId>(value: T) => lib.Variant<'Nft', lib.Variant<'Deleted', T>>;
    MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Nft', lib.Variant<'MetadataInserted', T>>;
    MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Nft', lib.Variant<'MetadataRemoved', T>>;
    OwnerChanged: <const T extends NftOwnerChanged>(value: T) => lib.Variant<'Nft', lib.Variant<'OwnerChanged', T>>;
  };
  Account: {
    Created: <const T extends Account>(value: T) => lib.Variant<'Account', lib.Variant<'Created', T>>;
    Deleted: <const T extends lib.AccountId>(value: T) => lib.Variant<'Account', lib.Variant<'Deleted', T>>;
    Asset: {
      Created: <const T extends Asset>(value: T) => lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Created', T>>>;
      Deleted: <const T extends lib.AssetId>(value: T) => lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Deleted', T>>>;
      Added: <const T extends AssetChanged>(value: T) => lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Added', T>>>;
      Removed: <const T extends AssetChanged>(value: T) => lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Removed', T>>>;
    };
    PermissionAdded: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Account', lib.Variant<'PermissionAdded', T>>;
    PermissionRemoved: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Account', lib.Variant<'PermissionRemoved', T>>;
    RoleGranted: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Account', lib.Variant<'RoleGranted', T>>;
    RoleRevoked: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Account', lib.Variant<'RoleRevoked', T>>;
    MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Account', lib.Variant<'MetadataInserted', T>>;
    MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Account', lib.Variant<'MetadataRemoved', T>>;
  };
  MetadataInserted: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'MetadataInserted', T>;
  MetadataRemoved: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'MetadataRemoved', T>;
  OwnerChanged: <const T extends DomainOwnerChanged>(value: T) => lib.Variant<'OwnerChanged', T>;
};
/**
 * Structure with named fields.
 */ export interface TriggerNumberOfExecutionsChanged {
  trigger: TriggerId;
  by: lib.U32;
}
/**
 * Codec of the structure.
 */ export declare const TriggerNumberOfExecutionsChanged: lib.CodecContainer<TriggerNumberOfExecutionsChanged>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `Extended`
 * - `Shortened`
 * - `MetadataInserted`
 * - `MetadataRemoved`
 * 
 * TODO how to construct, how to use
 */ export type TriggerEvent = lib.Variant<'Created', TriggerId> | lib.Variant<'Deleted', TriggerId> | lib.Variant<'Extended', TriggerNumberOfExecutionsChanged> | lib.Variant<'Shortened', TriggerNumberOfExecutionsChanged> | lib.Variant<'MetadataInserted', MetadataChanged<TriggerId>> | lib.Variant<'MetadataRemoved', MetadataChanged<TriggerId>>;
/**
 * Codec and constructors for enumeration {@link TriggerEvent}.
 */ export declare const TriggerEvent: lib.CodecContainer<TriggerEvent> & {
  Created: <const T extends TriggerId>(value: T) => lib.Variant<'Created', T>;
  Deleted: <const T extends TriggerId>(value: T) => lib.Variant<'Deleted', T>;
  Extended: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Extended', T>;
  Shortened: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Shortened', T>;
  MetadataInserted: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'MetadataInserted', T>;
  MetadataRemoved: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'MetadataRemoved', T>;
};
export type PermissionsSet = lib.BTreeSet<Permission>;
export declare const PermissionsSet: lib.CodecContainer<PermissionsSet>;
/**
 * Structure with named fields.
 */ export interface Role {
  id: RoleId;
  permissions: PermissionsSet;
}
/**
 * Codec of the structure.
 */ export declare const Role: lib.CodecContainer<Role>;
/**
 * Structure with named fields.
 */ export interface RolePermissionChanged {
  role: RoleId;
  permission: Permission;
}
/**
 * Codec of the structure.
 */ export declare const RolePermissionChanged: lib.CodecContainer<RolePermissionChanged>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `PermissionAdded`
 * - `PermissionRemoved`
 * 
 * TODO how to construct, how to use
 */ export type RoleEvent = lib.Variant<'Created', Role> | lib.Variant<'Deleted', RoleId> | lib.Variant<'PermissionAdded', RolePermissionChanged> | lib.Variant<'PermissionRemoved', RolePermissionChanged>;
/**
 * Codec and constructors for enumeration {@link RoleEvent}.
 */ export declare const RoleEvent: lib.CodecContainer<RoleEvent> & {
  Created: <const T extends Role>(value: T) => lib.Variant<'Created', T>;
  Deleted: <const T extends RoleId>(value: T) => lib.Variant<'Deleted', T>;
  PermissionAdded: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'PermissionAdded', T>;
  PermissionRemoved: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'PermissionRemoved', T>;
};
/**
 * Structure with named fields.
 */ export interface ExecutorDataModel {
  parameters: lib.BTreeMap<CustomParameterId, CustomParameter>;
  instructions: lib.BTreeSet<lib.String>;
  permissions: lib.BTreeSet<lib.String>;
  schema: lib.Json;
}
/**
 * Codec of the structure.
 */ export declare const ExecutorDataModel: lib.CodecContainer<ExecutorDataModel>;
/**
 * Structure with named fields.
 */ export interface ExecutorUpgrade {
  newDataModel: ExecutorDataModel;
}
/**
 * Codec of the structure.
 */ export declare const ExecutorUpgrade: lib.CodecContainer<ExecutorUpgrade>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Upgraded`
 * 
 * TODO how to construct, how to use
 */ export type ExecutorEvent = lib.Variant<'Upgraded', ExecutorUpgrade>;
/**
 * Codec and constructors for enumeration {@link ExecutorEvent}.
 */ export declare const ExecutorEvent: lib.CodecContainer<ExecutorEvent> & {
  Upgraded: <const T extends ExecutorUpgrade>(value: T) => lib.Variant<'Upgraded', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Peer`
 * - `Domain`
 * - `Trigger`
 * - `Role`
 * - `Configuration`
 * - `Executor`
 * 
 * TODO how to construct, how to use
 */ export type DataEvent = lib.Variant<'Peer', PeerEvent> | lib.Variant<'Domain', DomainEvent> | lib.Variant<'Trigger', TriggerEvent> | lib.Variant<'Role', RoleEvent> | lib.Variant<'Configuration', ConfigurationEvent> | lib.Variant<'Executor', ExecutorEvent>;
/**
 * Codec and constructors for enumeration {@link DataEvent}.
 */ export declare const DataEvent: lib.CodecContainer<DataEvent> & {
  Peer: {
    Added: <const T extends PeerId>(value: T) => lib.Variant<'Peer', lib.Variant<'Added', T>>;
    Removed: <const T extends PeerId>(value: T) => lib.Variant<'Peer', lib.Variant<'Removed', T>>;
  };
  Domain: {
    Created: <const T extends Domain>(value: T) => lib.Variant<'Domain', lib.Variant<'Created', T>>;
    Deleted: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', lib.Variant<'Deleted', T>>;
    AssetDefinition: {
      Created: <const T extends AssetDefinition>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Created', T>>>;
      Deleted: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Deleted', T>>>;
      MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataInserted', T>>>;
      MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataRemoved', T>>>;
      MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MintabilityChanged', T>>>;
      TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'TotalQuantityChanged', T>>>;
      OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'OwnerChanged', T>>>;
    };
    Nft: {
      Created: <const T extends Nft>(value: T) => lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Created', T>>>;
      Deleted: <const T extends lib.NftId>(value: T) => lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Deleted', T>>>;
      MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataInserted', T>>>;
      MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataRemoved', T>>>;
      OwnerChanged: <const T extends NftOwnerChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'OwnerChanged', T>>>;
    };
    Account: {
      Created: <const T extends Account>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Created', T>>>;
      Deleted: <const T extends lib.AccountId>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Deleted', T>>>;
      Asset: {
        Created: <const T extends Asset>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Created', T>>>>;
        Deleted: <const T extends lib.AssetId>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Deleted', T>>>>;
        Added: <const T extends AssetChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Added', T>>>>;
        Removed: <const T extends AssetChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Removed', T>>>>;
      };
      PermissionAdded: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionAdded', T>>>;
      PermissionRemoved: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionRemoved', T>>>;
      RoleGranted: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleGranted', T>>>;
      RoleRevoked: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleRevoked', T>>>;
      MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataInserted', T>>>;
      MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataRemoved', T>>>;
    };
    MetadataInserted: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'Domain', lib.Variant<'MetadataInserted', T>>;
    MetadataRemoved: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'Domain', lib.Variant<'MetadataRemoved', T>>;
    OwnerChanged: <const T extends DomainOwnerChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'OwnerChanged', T>>;
  };
  Trigger: {
    Created: <const T extends TriggerId>(value: T) => lib.Variant<'Trigger', lib.Variant<'Created', T>>;
    Deleted: <const T extends TriggerId>(value: T) => lib.Variant<'Trigger', lib.Variant<'Deleted', T>>;
    Extended: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Trigger', lib.Variant<'Extended', T>>;
    Shortened: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Trigger', lib.Variant<'Shortened', T>>;
    MetadataInserted: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'Trigger', lib.Variant<'MetadataInserted', T>>;
    MetadataRemoved: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'Trigger', lib.Variant<'MetadataRemoved', T>>;
  };
  Role: {
    Created: <const T extends Role>(value: T) => lib.Variant<'Role', lib.Variant<'Created', T>>;
    Deleted: <const T extends RoleId>(value: T) => lib.Variant<'Role', lib.Variant<'Deleted', T>>;
    PermissionAdded: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'Role', lib.Variant<'PermissionAdded', T>>;
    PermissionRemoved: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'Role', lib.Variant<'PermissionRemoved', T>>;
  };
  Configuration: {
    Changed: <const T extends ParameterChanged>(value: T) => lib.Variant<'Configuration', lib.Variant<'Changed', T>>;
  };
  Executor: {
    Upgraded: <const T extends ExecutorUpgrade>(value: T) => lib.Variant<'Executor', lib.Variant<'Upgraded', T>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */ export type DomainProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', DomainIdProjectionSelector> | lib.Variant<'Metadata', MetadataProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link DomainProjectionSelector}.
 */ export declare const DomainProjectionSelector: lib.CodecContainer<DomainProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Id: {
    Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>;
    Name: {
      Atom: lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>;
    };
  };
  Metadata: {
    Atom: lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>;
    Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>>;
  };
};
/**
 * Structure with named fields.
 */ export interface TransactionEvent {
  hash: lib.Hash;
  blockHeight: lib.Option<lib.NonZero<lib.U64>>;
  status: TransactionStatus;
}
/**
 * Codec of the structure.
 */ export declare const TransactionEvent: lib.CodecContainer<TransactionEvent>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Transaction`
 * - `Block`
 * 
 * TODO how to construct, how to use
 */ export type PipelineEventBox = lib.Variant<'Transaction', TransactionEvent> | lib.Variant<'Block', BlockEvent>;
/**
 * Codec and constructors for enumeration {@link PipelineEventBox}.
 */ export declare const PipelineEventBox: lib.CodecContainer<PipelineEventBox> & {
  Transaction: <const T extends TransactionEvent>(value: T) => lib.Variant<'Transaction', T>;
  Block: <const T extends BlockEvent>(value: T) => lib.Variant<'Block', T>;
};
/**
 * Structure with named fields.
 */ export interface TimeInterval {
  since: lib.Timestamp;
  length: lib.Duration;
}
/**
 * Codec of the structure.
 */ export declare const TimeInterval: lib.CodecContainer<TimeInterval>;
/**
 * Structure with named fields.
 */ export interface TimeEvent {
  interval: TimeInterval;
}
/**
 * Codec of the structure.
 */ export declare const TimeEvent: lib.CodecContainer<TimeEvent>;
/**
 * Structure with named fields.
 */ export interface ExecuteTriggerEvent {
  triggerId: TriggerId;
  authority: lib.AccountId;
  args: lib.Json;
}
/**
 * Codec of the structure.
 */ export declare const ExecuteTriggerEvent: lib.CodecContainer<ExecuteTriggerEvent>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Success`
 * - `Failure`
 * 
 * TODO how to construct, how to use
 */ export type TriggerCompletedOutcome = lib.VariantUnit<'Success'> | lib.Variant<'Failure', lib.String>;
/**
 * Codec and constructors for enumeration {@link TriggerCompletedOutcome}.
 */ export declare const TriggerCompletedOutcome: lib.CodecContainer<TriggerCompletedOutcome> & {
  Success: lib.VariantUnit<'Success'>;
  Failure: <const T extends lib.String>(value: T) => lib.Variant<'Failure', T>;
};
/**
 * Structure with named fields.
 */ export interface TriggerCompletedEvent {
  triggerId: TriggerId;
  outcome: TriggerCompletedOutcome;
}
/**
 * Codec of the structure.
 */ export declare const TriggerCompletedEvent: lib.CodecContainer<TriggerCompletedEvent>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Pipeline`
 * - `Data`
 * - `Time`
 * - `ExecuteTrigger`
 * - `TriggerCompleted`
 * 
 * TODO how to construct, how to use
 */ export type EventBox = lib.Variant<'Pipeline', PipelineEventBox> | lib.Variant<'Data', DataEvent> | lib.Variant<'Time', TimeEvent> | lib.Variant<'ExecuteTrigger', ExecuteTriggerEvent> | lib.Variant<'TriggerCompleted', TriggerCompletedEvent>;
/**
 * Codec and constructors for enumeration {@link EventBox}.
 */ export declare const EventBox: lib.CodecContainer<EventBox> & {
  Pipeline: {
    Transaction: <const T extends TransactionEvent>(value: T) => lib.Variant<'Pipeline', lib.Variant<'Transaction', T>>;
    Block: <const T extends BlockEvent>(value: T) => lib.Variant<'Pipeline', lib.Variant<'Block', T>>;
  };
  Data: {
    Peer: {
      Added: <const T extends PeerId>(value: T) => lib.Variant<'Data', lib.Variant<'Peer', lib.Variant<'Added', T>>>;
      Removed: <const T extends PeerId>(value: T) => lib.Variant<'Data', lib.Variant<'Peer', lib.Variant<'Removed', T>>>;
    };
    Domain: {
      Created: <const T extends Domain>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Created', T>>>;
      Deleted: <const T extends lib.DomainId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Deleted', T>>>;
      AssetDefinition: {
        Created: <const T extends AssetDefinition>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Created', T>>>>;
        Deleted: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Deleted', T>>>>;
        MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataInserted', T>>>>;
        MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataRemoved', T>>>>;
        MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MintabilityChanged', T>>>>;
        TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'TotalQuantityChanged', T>>>>;
        OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'OwnerChanged', T>>>>;
      };
      Nft: {
        Created: <const T extends Nft>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Created', T>>>>;
        Deleted: <const T extends lib.NftId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Deleted', T>>>>;
        MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataInserted', T>>>>;
        MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataRemoved', T>>>>;
        OwnerChanged: <const T extends NftOwnerChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'OwnerChanged', T>>>>;
      };
      Account: {
        Created: <const T extends Account>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Created', T>>>>;
        Deleted: <const T extends lib.AccountId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Deleted', T>>>>;
        Asset: {
          Created: <const T extends Asset>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Created', T>>>>>;
          Deleted: <const T extends lib.AssetId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Deleted', T>>>>>;
          Added: <const T extends AssetChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Added', T>>>>>;
          Removed: <const T extends AssetChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Removed', T>>>>>;
        };
        PermissionAdded: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionAdded', T>>>>;
        PermissionRemoved: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionRemoved', T>>>>;
        RoleGranted: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleGranted', T>>>>;
        RoleRevoked: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleRevoked', T>>>>;
        MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataInserted', T>>>>;
        MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataRemoved', T>>>>;
      };
      MetadataInserted: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'MetadataInserted', T>>>;
      MetadataRemoved: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'MetadataRemoved', T>>>;
      OwnerChanged: <const T extends DomainOwnerChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'OwnerChanged', T>>>;
    };
    Trigger: {
      Created: <const T extends TriggerId>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Created', T>>>;
      Deleted: <const T extends TriggerId>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Deleted', T>>>;
      Extended: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Extended', T>>>;
      Shortened: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Shortened', T>>>;
      MetadataInserted: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'MetadataInserted', T>>>;
      MetadataRemoved: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'MetadataRemoved', T>>>;
    };
    Role: {
      Created: <const T extends Role>(value: T) => lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'Created', T>>>;
      Deleted: <const T extends RoleId>(value: T) => lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'Deleted', T>>>;
      PermissionAdded: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'PermissionAdded', T>>>;
      PermissionRemoved: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'PermissionRemoved', T>>>;
    };
    Configuration: {
      Changed: <const T extends ParameterChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Configuration', lib.Variant<'Changed', T>>>;
    };
    Executor: {
      Upgraded: <const T extends ExecutorUpgrade>(value: T) => lib.Variant<'Data', lib.Variant<'Executor', lib.Variant<'Upgraded', T>>>;
    };
  };
  Time: <const T extends TimeEvent>(value: T) => lib.Variant<'Time', T>;
  ExecuteTrigger: <const T extends ExecuteTriggerEvent>(value: T) => lib.Variant<'ExecuteTrigger', T>;
  TriggerCompleted: <const T extends TriggerCompletedEvent>(value: T) => lib.Variant<'TriggerCompleted', T>;
};
export type EventMessage = EventBox;
export declare const EventMessage: any;
/**
 * Structure with named fields.
 */ export interface EventSubscriptionRequest {
  filters: lib.Vec<EventFilterBox>;
}
/**
 * Codec of the structure.
 */ export declare const EventSubscriptionRequest: lib.CodecContainer<EventSubscriptionRequest>;
/**
 * Structure with named fields.
 */ export interface ExecuteTrigger {
  trigger: TriggerId;
  args: lib.Json;
}
/**
 * Codec of the structure.
 */ export declare const ExecuteTrigger: lib.CodecContainer<ExecuteTrigger>;
/**
 * Structure with named fields.
 */ export interface Executor {
  wasm: WasmSmartContract;
}
/**
 * Codec of the structure.
 */ export declare const Executor: lib.CodecContainer<Executor>;
/**
 * Structure with named fields.
 */ export interface FindAccountsWithAsset {
  assetDefinition: lib.AssetDefinitionId;
}
/**
 * Codec of the structure.
 */ export declare const FindAccountsWithAsset: lib.CodecContainer<FindAccountsWithAsset>;
/**
 * Structure with named fields.
 */ export interface FindPermissionsByAccountId {
  id: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const FindPermissionsByAccountId: lib.CodecContainer<FindPermissionsByAccountId>;
/**
 * Structure with named fields.
 */ export interface FindRolesByAccountId {
  id: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const FindRolesByAccountId: lib.CodecContainer<FindRolesByAccountId>;
/**
 * Structure with named fields.
 */ export interface ForwardCursor {
  query: lib.String;
  cursor: lib.NonZero<lib.U64>;
}
/**
 * Codec of the structure.
 */ export declare const ForwardCursor: lib.CodecContainer<ForwardCursor>;
/**
 * Structure with named fields.
 */ export interface GenesisWasmAction {
  executable: lib.String;
  repeats: Repeats;
  authority: lib.AccountId;
  filter: EventFilterBox;
}
/**
 * Codec of the structure.
 */ export declare const GenesisWasmAction: lib.CodecContainer<GenesisWasmAction>;
/**
 * Structure with named fields.
 */ export interface GenesisWasmTrigger {
  id: TriggerId;
  action: GenesisWasmAction;
}
/**
 * Codec of the structure.
 */ export declare const GenesisWasmTrigger: lib.CodecContainer<GenesisWasmTrigger>;
/**
 * Structure with named fields and generic parameters.
 */ export interface Grant<T0, T1> {
  object: T0;
  destination: T1;
}
/**
 * Codec constructor for the structure with generic parameters.
 */ export declare const Grant: {
  readonly with: <T0, T1>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>) => lib.GenCodec<Grant<T0, T1>>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Permission`
 * - `Role`
 * - `RolePermission`
 * 
 * TODO how to construct, how to use
 */ export type GrantBox = lib.Variant<'Permission', Grant<Permission, lib.AccountId>> | lib.Variant<'Role', Grant<RoleId, lib.AccountId>> | lib.Variant<'RolePermission', Grant<Permission, RoleId>>;
/**
 * Codec and constructors for enumeration {@link GrantBox}.
 */ export declare const GrantBox: lib.CodecContainer<GrantBox> & {
  Permission: <const T extends Grant<Permission, lib.AccountId>>(value: T) => lib.Variant<'Permission', T>;
  Role: <const T extends Grant<RoleId, lib.AccountId>>(value: T) => lib.Variant<'Role', T>;
  RolePermission: <const T extends Grant<Permission, RoleId>>(value: T) => lib.Variant<'RolePermission', T>;
};
/**
 * Structure with named fields.
 */ export interface NewDomain {
  id: lib.DomainId;
  logo: lib.Option<IpfsPath>;
  metadata: Metadata;
}
/**
 * Codec of the structure.
 */ export declare const NewDomain: lib.CodecContainer<NewDomain>;
/**
 * Structure with named fields.
 */ export interface NewAccount {
  id: lib.AccountId;
  metadata: Metadata;
}
/**
 * Codec of the structure.
 */ export declare const NewAccount: lib.CodecContainer<NewAccount>;
/**
 * Structure with named fields.
 */ export interface NewAssetDefinition {
  id: lib.AssetDefinitionId;
  spec: NumericSpec;
  mintable: Mintable;
  logo: lib.Option<IpfsPath>;
  metadata: Metadata;
}
/**
 * Codec of the structure.
 */ export declare const NewAssetDefinition: lib.CodecContainer<NewAssetDefinition>;
/**
 * Structure with named fields.
 */ export interface NewNft {
  id: lib.NftId;
  content: Metadata;
}
/**
 * Codec of the structure.
 */ export declare const NewNft: lib.CodecContainer<NewNft>;
/**
 * Structure with named fields.
 */ export interface NewRole {
  inner: Role;
  grantTo: lib.AccountId;
}
/**
 * Codec of the structure.
 */ export declare const NewRole: lib.CodecContainer<NewRole>;
/**
 * Structure with named fields.
 */ export interface Trigger {
  id: TriggerId;
  action: Action;
}
/**
 * Codec of the structure.
 */ export declare const Trigger: lib.CodecContainer<Trigger>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Peer`
 * - `Domain`
 * - `Account`
 * - `AssetDefinition`
 * - `Nft`
 * - `Role`
 * - `Trigger`
 * 
 * TODO how to construct, how to use
 */ export type RegisterBox = lib.Variant<'Peer', PeerId> | lib.Variant<'Domain', NewDomain> | lib.Variant<'Account', NewAccount> | lib.Variant<'AssetDefinition', NewAssetDefinition> | lib.Variant<'Nft', NewNft> | lib.Variant<'Role', NewRole> | lib.Variant<'Trigger', Trigger>;
/**
 * Codec and constructors for enumeration {@link RegisterBox}.
 */ export declare const RegisterBox: lib.CodecContainer<RegisterBox> & {
  Peer: <const T extends PeerId>(value: T) => lib.Variant<'Peer', T>;
  Domain: <const T extends NewDomain>(value: T) => lib.Variant<'Domain', T>;
  Account: <const T extends NewAccount>(value: T) => lib.Variant<'Account', T>;
  AssetDefinition: <const T extends NewAssetDefinition>(value: T) => lib.Variant<'AssetDefinition', T>;
  Nft: <const T extends NewNft>(value: T) => lib.Variant<'Nft', T>;
  Role: <const T extends NewRole>(value: T) => lib.Variant<'Role', T>;
  Trigger: <const T extends Trigger>(value: T) => lib.Variant<'Trigger', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Peer`
 * - `Domain`
 * - `Account`
 * - `AssetDefinition`
 * - `Nft`
 * - `Role`
 * - `Trigger`
 * 
 * TODO how to construct, how to use
 */ export type UnregisterBox = lib.Variant<'Peer', PeerId> | lib.Variant<'Domain', lib.DomainId> | lib.Variant<'Account', lib.AccountId> | lib.Variant<'AssetDefinition', lib.AssetDefinitionId> | lib.Variant<'Nft', lib.NftId> | lib.Variant<'Role', RoleId> | lib.Variant<'Trigger', TriggerId>;
/**
 * Codec and constructors for enumeration {@link UnregisterBox}.
 */ export declare const UnregisterBox: lib.CodecContainer<UnregisterBox> & {
  Peer: <const T extends PeerId>(value: T) => lib.Variant<'Peer', T>;
  Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', T>;
  Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Account', T>;
  AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AssetDefinition', T>;
  Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Nft', T>;
  Role: <const T extends RoleId>(value: T) => lib.Variant<'Role', T>;
  Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Trigger', T>;
};
/**
 * Structure with named fields and generic parameters.
 */ export interface Mint<T0, T1> {
  object: T0;
  destination: T1;
}
/**
 * Codec constructor for the structure with generic parameters.
 */ export declare const Mint: {
  readonly with: <T0, T1>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>) => lib.GenCodec<Mint<T0, T1>>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Asset`
 * - `TriggerRepetitions`
 * 
 * TODO how to construct, how to use
 */ export type MintBox = lib.Variant<'Asset', Mint<Numeric, lib.AssetId>> | lib.Variant<'TriggerRepetitions', Mint<lib.U32, TriggerId>>;
/**
 * Codec and constructors for enumeration {@link MintBox}.
 */ export declare const MintBox: lib.CodecContainer<MintBox> & {
  Asset: <const T extends Mint<Numeric, lib.AssetId>>(value: T) => lib.Variant<'Asset', T>;
  TriggerRepetitions: <const T extends Mint<lib.U32, TriggerId>>(value: T) => lib.Variant<'TriggerRepetitions', T>;
};
/**
 * Structure with named fields and generic parameters.
 */ export interface Transfer<T0, T1, T2> {
  source: T0;
  object: T1;
  destination: T2;
}
/**
 * Codec constructor for the structure with generic parameters.
 */ export declare const Transfer: {
  readonly with: <T0, T1, T2>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>, t2: lib.GenCodec<T2>) => lib.GenCodec<Transfer<T0, T1, T2>>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Domain`
 * - `AssetDefinition`
 * - `Asset`
 * - `Nft`
 * 
 * TODO how to construct, how to use
 */ export type TransferBox = lib.Variant<'Domain', Transfer<lib.AccountId, lib.DomainId, lib.AccountId>> | lib.Variant<'AssetDefinition', Transfer<lib.AccountId, lib.AssetDefinitionId, lib.AccountId>> | lib.Variant<'Asset', Transfer<lib.AssetId, Numeric, lib.AccountId>> | lib.Variant<'Nft', Transfer<lib.AccountId, lib.NftId, lib.AccountId>>;
/**
 * Codec and constructors for enumeration {@link TransferBox}.
 */ export declare const TransferBox: lib.CodecContainer<TransferBox> & {
  Domain: <const T extends Transfer<lib.AccountId, lib.DomainId, lib.AccountId>>(value: T) => lib.Variant<'Domain', T>;
  AssetDefinition: <const T extends Transfer<lib.AccountId, lib.AssetDefinitionId, lib.AccountId>>(value: T) => lib.Variant<'AssetDefinition', T>;
  Asset: <const T extends Transfer<lib.AssetId, Numeric, lib.AccountId>>(value: T) => lib.Variant<'Asset', T>;
  Nft: <const T extends Transfer<lib.AccountId, lib.NftId, lib.AccountId>>(value: T) => lib.Variant<'Nft', T>;
};
/**
 * Structure with named fields and generic parameters.
 */ export interface SetKeyValue<T0> {
  object: T0;
  key: lib.Name;
  value: lib.Json;
}
/**
 * Codec constructor for the structure with generic parameters.
 */ export declare const SetKeyValue: {
  readonly with: <T0>(t0: lib.GenCodec<T0>) => lib.GenCodec<SetKeyValue<T0>>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Domain`
 * - `Account`
 * - `AssetDefinition`
 * - `Nft`
 * - `Trigger`
 * 
 * TODO how to construct, how to use
 */ export type SetKeyValueBox = lib.Variant<'Domain', SetKeyValue<lib.DomainId>> | lib.Variant<'Account', SetKeyValue<lib.AccountId>> | lib.Variant<'AssetDefinition', SetKeyValue<lib.AssetDefinitionId>> | lib.Variant<'Nft', SetKeyValue<lib.NftId>> | lib.Variant<'Trigger', SetKeyValue<TriggerId>>;
/**
 * Codec and constructors for enumeration {@link SetKeyValueBox}.
 */ export declare const SetKeyValueBox: lib.CodecContainer<SetKeyValueBox> & {
  Domain: <const T extends SetKeyValue<lib.DomainId>>(value: T) => lib.Variant<'Domain', T>;
  Account: <const T extends SetKeyValue<lib.AccountId>>(value: T) => lib.Variant<'Account', T>;
  AssetDefinition: <const T extends SetKeyValue<lib.AssetDefinitionId>>(value: T) => lib.Variant<'AssetDefinition', T>;
  Nft: <const T extends SetKeyValue<lib.NftId>>(value: T) => lib.Variant<'Nft', T>;
  Trigger: <const T extends SetKeyValue<TriggerId>>(value: T) => lib.Variant<'Trigger', T>;
};
/**
 * Structure with named fields and generic parameters.
 */ export interface RemoveKeyValue<T0> {
  object: T0;
  key: lib.Name;
}
/**
 * Codec constructor for the structure with generic parameters.
 */ export declare const RemoveKeyValue: {
  readonly with: <T0>(t0: lib.GenCodec<T0>) => lib.GenCodec<RemoveKeyValue<T0>>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Domain`
 * - `Account`
 * - `AssetDefinition`
 * - `Nft`
 * - `Trigger`
 * 
 * TODO how to construct, how to use
 */ export type RemoveKeyValueBox = lib.Variant<'Domain', RemoveKeyValue<lib.DomainId>> | lib.Variant<'Account', RemoveKeyValue<lib.AccountId>> | lib.Variant<'AssetDefinition', RemoveKeyValue<lib.AssetDefinitionId>> | lib.Variant<'Nft', RemoveKeyValue<lib.NftId>> | lib.Variant<'Trigger', RemoveKeyValue<TriggerId>>;
/**
 * Codec and constructors for enumeration {@link RemoveKeyValueBox}.
 */ export declare const RemoveKeyValueBox: lib.CodecContainer<RemoveKeyValueBox> & {
  Domain: <const T extends RemoveKeyValue<lib.DomainId>>(value: T) => lib.Variant<'Domain', T>;
  Account: <const T extends RemoveKeyValue<lib.AccountId>>(value: T) => lib.Variant<'Account', T>;
  AssetDefinition: <const T extends RemoveKeyValue<lib.AssetDefinitionId>>(value: T) => lib.Variant<'AssetDefinition', T>;
  Nft: <const T extends RemoveKeyValue<lib.NftId>>(value: T) => lib.Variant<'Nft', T>;
  Trigger: <const T extends RemoveKeyValue<TriggerId>>(value: T) => lib.Variant<'Trigger', T>;
};
/**
 * Structure with named fields and generic parameters.
 */ export interface Revoke<T0, T1> {
  object: T0;
  destination: T1;
}
/**
 * Codec constructor for the structure with generic parameters.
 */ export declare const Revoke: {
  readonly with: <T0, T1>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>) => lib.GenCodec<Revoke<T0, T1>>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Permission`
 * - `Role`
 * - `RolePermission`
 * 
 * TODO how to construct, how to use
 */ export type RevokeBox = lib.Variant<'Permission', Revoke<Permission, lib.AccountId>> | lib.Variant<'Role', Revoke<RoleId, lib.AccountId>> | lib.Variant<'RolePermission', Revoke<Permission, RoleId>>;
/**
 * Codec and constructors for enumeration {@link RevokeBox}.
 */ export declare const RevokeBox: lib.CodecContainer<RevokeBox> & {
  Permission: <const T extends Revoke<Permission, lib.AccountId>>(value: T) => lib.Variant<'Permission', T>;
  Role: <const T extends Revoke<RoleId, lib.AccountId>>(value: T) => lib.Variant<'Role', T>;
  RolePermission: <const T extends Revoke<Permission, RoleId>>(value: T) => lib.Variant<'RolePermission', T>;
};
export type SetParameter = Parameter;
export declare const SetParameter: any;
/**
 * Structure with named fields.
 */ export interface Upgrade {
  executor: Executor;
}
/**
 * Codec of the structure.
 */ export declare const Upgrade: lib.CodecContainer<Upgrade>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `TRACE`
 * - `DEBUG`
 * - `INFO`
 * - `WARN`
 * - `ERROR`
 * 
 * TODO how to construct, how to use
 */ export type Level = lib.VariantUnit<'TRACE'> | lib.VariantUnit<'DEBUG'> | lib.VariantUnit<'INFO'> | lib.VariantUnit<'WARN'> | lib.VariantUnit<'ERROR'>;
/**
 * Codec and constructors for enumeration {@link Level}.
 */ export declare const Level: lib.CodecContainer<Level> & {
  TRACE: lib.VariantUnit<'TRACE'>;
  DEBUG: lib.VariantUnit<'DEBUG'>;
  INFO: lib.VariantUnit<'INFO'>;
  WARN: lib.VariantUnit<'WARN'>;
  ERROR: lib.VariantUnit<'ERROR'>;
};
/**
 * Structure with named fields.
 */ export interface Log {
  level: Level;
  msg: lib.String;
}
/**
 * Codec of the structure.
 */ export declare const Log: lib.CodecContainer<Log>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Register`
 * - `Unregister`
 * - `Mint`
 * - `Burn`
 * - `Transfer`
 * - `SetKeyValue`
 * - `RemoveKeyValue`
 * - `Grant`
 * - `Revoke`
 * - `ExecuteTrigger`
 * - `SetParameter`
 * - `Upgrade`
 * - `Log`
 * - `Custom`
 * 
 * TODO how to construct, how to use
 */ export type InstructionBox = lib.Variant<'Register', RegisterBox> | lib.Variant<'Unregister', UnregisterBox> | lib.Variant<'Mint', MintBox> | lib.Variant<'Burn', BurnBox> | lib.Variant<'Transfer', TransferBox> | lib.Variant<'SetKeyValue', SetKeyValueBox> | lib.Variant<'RemoveKeyValue', RemoveKeyValueBox> | lib.Variant<'Grant', GrantBox> | lib.Variant<'Revoke', RevokeBox> | lib.Variant<'ExecuteTrigger', ExecuteTrigger> | lib.Variant<'SetParameter', SetParameter> | lib.Variant<'Upgrade', Upgrade> | lib.Variant<'Log', Log> | lib.Variant<'Custom', CustomInstruction>;
/**
 * Codec and constructors for enumeration {@link InstructionBox}.
 */ export declare const InstructionBox: lib.CodecContainer<InstructionBox> & {
  Register: {
    Peer: <const T extends PeerId>(value: T) => lib.Variant<'Register', lib.Variant<'Peer', T>>;
    Domain: <const T extends NewDomain>(value: T) => lib.Variant<'Register', lib.Variant<'Domain', T>>;
    Account: <const T extends NewAccount>(value: T) => lib.Variant<'Register', lib.Variant<'Account', T>>;
    AssetDefinition: <const T extends NewAssetDefinition>(value: T) => lib.Variant<'Register', lib.Variant<'AssetDefinition', T>>;
    Nft: <const T extends NewNft>(value: T) => lib.Variant<'Register', lib.Variant<'Nft', T>>;
    Role: <const T extends NewRole>(value: T) => lib.Variant<'Register', lib.Variant<'Role', T>>;
    Trigger: <const T extends Trigger>(value: T) => lib.Variant<'Register', lib.Variant<'Trigger', T>>;
  };
  Unregister: {
    Peer: <const T extends PeerId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Peer', T>>;
    Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Domain', T>>;
    Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Account', T>>;
    AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Unregister', lib.Variant<'AssetDefinition', T>>;
    Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Nft', T>>;
    Role: <const T extends RoleId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Role', T>>;
    Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Trigger', T>>;
  };
  Mint: {
    Asset: <const T extends Mint<Numeric, lib.AssetId>>(value: T) => lib.Variant<'Mint', lib.Variant<'Asset', T>>;
    TriggerRepetitions: <const T extends Mint<lib.U32, TriggerId>>(value: T) => lib.Variant<'Mint', lib.Variant<'TriggerRepetitions', T>>;
  };
  Burn: {
    Asset: <const T extends Burn<Numeric, lib.AssetId>>(value: T) => lib.Variant<'Burn', lib.Variant<'Asset', T>>;
    TriggerRepetitions: <const T extends Burn<lib.U32, TriggerId>>(value: T) => lib.Variant<'Burn', lib.Variant<'TriggerRepetitions', T>>;
  };
  Transfer: {
    Domain: <const T extends Transfer<lib.AccountId, lib.DomainId, lib.AccountId>>(value: T) => lib.Variant<'Transfer', lib.Variant<'Domain', T>>;
    AssetDefinition: <const T extends Transfer<lib.AccountId, lib.AssetDefinitionId, lib.AccountId>>(value: T) => lib.Variant<'Transfer', lib.Variant<'AssetDefinition', T>>;
    Asset: <const T extends Transfer<lib.AssetId, Numeric, lib.AccountId>>(value: T) => lib.Variant<'Transfer', lib.Variant<'Asset', T>>;
    Nft: <const T extends Transfer<lib.AccountId, lib.NftId, lib.AccountId>>(value: T) => lib.Variant<'Transfer', lib.Variant<'Nft', T>>;
  };
  SetKeyValue: {
    Domain: <const T extends SetKeyValue<lib.DomainId>>(value: T) => lib.Variant<'SetKeyValue', lib.Variant<'Domain', T>>;
    Account: <const T extends SetKeyValue<lib.AccountId>>(value: T) => lib.Variant<'SetKeyValue', lib.Variant<'Account', T>>;
    AssetDefinition: <const T extends SetKeyValue<lib.AssetDefinitionId>>(value: T) => lib.Variant<'SetKeyValue', lib.Variant<'AssetDefinition', T>>;
    Nft: <const T extends SetKeyValue<lib.NftId>>(value: T) => lib.Variant<'SetKeyValue', lib.Variant<'Nft', T>>;
    Trigger: <const T extends SetKeyValue<TriggerId>>(value: T) => lib.Variant<'SetKeyValue', lib.Variant<'Trigger', T>>;
  };
  RemoveKeyValue: {
    Domain: <const T extends RemoveKeyValue<lib.DomainId>>(value: T) => lib.Variant<'RemoveKeyValue', lib.Variant<'Domain', T>>;
    Account: <const T extends RemoveKeyValue<lib.AccountId>>(value: T) => lib.Variant<'RemoveKeyValue', lib.Variant<'Account', T>>;
    AssetDefinition: <const T extends RemoveKeyValue<lib.AssetDefinitionId>>(value: T) => lib.Variant<'RemoveKeyValue', lib.Variant<'AssetDefinition', T>>;
    Nft: <const T extends RemoveKeyValue<lib.NftId>>(value: T) => lib.Variant<'RemoveKeyValue', lib.Variant<'Nft', T>>;
    Trigger: <const T extends RemoveKeyValue<TriggerId>>(value: T) => lib.Variant<'RemoveKeyValue', lib.Variant<'Trigger', T>>;
  };
  Grant: {
    Permission: <const T extends Grant<Permission, lib.AccountId>>(value: T) => lib.Variant<'Grant', lib.Variant<'Permission', T>>;
    Role: <const T extends Grant<RoleId, lib.AccountId>>(value: T) => lib.Variant<'Grant', lib.Variant<'Role', T>>;
    RolePermission: <const T extends Grant<Permission, RoleId>>(value: T) => lib.Variant<'Grant', lib.Variant<'RolePermission', T>>;
  };
  Revoke: {
    Permission: <const T extends Revoke<Permission, lib.AccountId>>(value: T) => lib.Variant<'Revoke', lib.Variant<'Permission', T>>;
    Role: <const T extends Revoke<RoleId, lib.AccountId>>(value: T) => lib.Variant<'Revoke', lib.Variant<'Role', T>>;
    RolePermission: <const T extends Revoke<Permission, RoleId>>(value: T) => lib.Variant<'Revoke', lib.Variant<'RolePermission', T>>;
  };
  ExecuteTrigger: <const T extends ExecuteTrigger>(value: T) => lib.Variant<'ExecuteTrigger', T>;
  SetParameter: {
    Sumeragi: {
      BlockTime: <const T extends lib.Duration>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Sumeragi', lib.Variant<'BlockTime', T>>>;
      CommitTime: <const T extends lib.Duration>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Sumeragi', lib.Variant<'CommitTime', T>>>;
      MaxClockDrift: <const T extends lib.Duration>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Sumeragi', lib.Variant<'MaxClockDrift', T>>>;
    };
    Block: {
      MaxTransactions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Block', lib.Variant<'MaxTransactions', T>>>;
    };
    Transaction: {
      MaxInstructions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Transaction', lib.Variant<'MaxInstructions', T>>>;
      SmartContractSize: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Transaction', lib.Variant<'SmartContractSize', T>>>;
    };
    SmartContract: {
      Fuel: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'SmartContract', lib.Variant<'Fuel', T>>>;
      Memory: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'SmartContract', lib.Variant<'Memory', T>>>;
    };
    Executor: {
      Fuel: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Executor', lib.Variant<'Fuel', T>>>;
      Memory: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Executor', lib.Variant<'Memory', T>>>;
    };
    Custom: <const T extends CustomParameter>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Custom', T>>;
  };
  Upgrade: <const T extends Upgrade>(value: T) => lib.Variant<'Upgrade', T>;
  Log: <const T extends Log>(value: T) => lib.Variant<'Log', T>;
  Custom: <const T extends CustomInstruction>(value: T) => lib.Variant<'Custom', T>;
};
export type Ipv4Addr = [lib.U8, lib.U8, lib.U8, lib.U8];
export declare const Ipv4Addr: lib.CodecContainer<Ipv4Addr>;
export type Ipv6Addr = [lib.U16, lib.U16, lib.U16, lib.U16, lib.U16, lib.U16, lib.U16, lib.U16];
export declare const Ipv6Addr: lib.CodecContainer<Ipv6Addr>;
/**
 * Structure with named fields.
 */ export interface MultisigApprove {
  account: lib.AccountId;
  instructionsHash: lib.Hash;
}
/**
 * Codec of the structure.
 */ export declare const MultisigApprove: lib.CodecContainer<MultisigApprove>;
/**
 * Structure with named fields.
 */ export interface MultisigSpec {
  signatories: lib.BTreeMap<lib.AccountId, lib.U8>;
  quorum: lib.NonZero<lib.U16>;
  transactionTtl: lib.NonZero<lib.Duration>;
}
/**
 * Codec of the structure.
 */ export declare const MultisigSpec: lib.CodecContainer<MultisigSpec>;
/**
 * Structure with named fields.
 */ export interface MultisigRegister {
  account: lib.AccountId;
  spec: MultisigSpec;
}
/**
 * Codec of the structure.
 */ export declare const MultisigRegister: lib.CodecContainer<MultisigRegister>;
/**
 * Structure with named fields.
 */ export interface MultisigPropose {
  account: lib.AccountId;
  instructions: lib.Vec<InstructionBox>;
  transactionTtl: lib.Option<lib.NonZero<lib.Duration>>;
}
/**
 * Codec of the structure.
 */ export declare const MultisigPropose: lib.CodecContainer<MultisigPropose>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Register`
 * - `Propose`
 * - `Approve`
 * 
 * TODO how to construct, how to use
 */ export type MultisigInstructionBox = lib.Variant<'Register', MultisigRegister> | lib.Variant<'Propose', MultisigPropose> | lib.Variant<'Approve', MultisigApprove>;
/**
 * Codec and constructors for enumeration {@link MultisigInstructionBox}.
 */ export declare const MultisigInstructionBox: lib.CodecContainer<MultisigInstructionBox> & {
  Register: <const T extends MultisigRegister>(value: T) => lib.Variant<'Register', T>;
  Propose: <const T extends MultisigPropose>(value: T) => lib.Variant<'Propose', T>;
  Approve: <const T extends MultisigApprove>(value: T) => lib.Variant<'Approve', T>;
};
/**
 * Structure with named fields.
 */ export interface MultisigProposalValue {
  instructions: lib.Vec<InstructionBox>;
  proposedAt: lib.Timestamp;
  expiresAt: lib.Timestamp;
  approvals: lib.BTreeSet<lib.AccountId>;
  isRelayed: lib.Option<lib.Bool>;
}
/**
 * Codec of the structure.
 */ export declare const MultisigProposalValue: lib.CodecContainer<MultisigProposalValue>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */ export type NftIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Domain', DomainIdProjectionSelector> | lib.Variant<'Name', NameProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link NftIdProjectionSelector}.
 */ export declare const NftIdProjectionSelector: lib.CodecContainer<NftIdProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Domain: {
    Atom: lib.Variant<'Domain', lib.VariantUnit<'Atom'>>;
    Name: {
      Atom: lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>;
    };
  };
  Name: {
    Atom: lib.Variant<'Name', lib.VariantUnit<'Atom'>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * - `AccountId`
 * 
 * TODO how to construct, how to use
 */ export type NftProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', NftIdProjectionSelector> | lib.Variant<'Metadata', MetadataProjectionSelector> | lib.Variant<'AccountId', AccountIdProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link NftProjectionSelector}.
 */ export declare const NftProjectionSelector: lib.CodecContainer<NftProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Id: {
    Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>;
    Domain: {
      Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>;
      Name: {
        Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>;
      };
    };
    Name: {
      Atom: lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>;
    };
  };
  Metadata: {
    Atom: lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>;
    Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>>;
  };
  AccountId: {
    Atom: lib.Variant<'AccountId', lib.VariantUnit<'Atom'>>;
    Domain: {
      Atom: lib.Variant<'AccountId', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>;
      Name: {
        Atom: lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>;
      };
    };
    Signatory: {
      Atom: lib.Variant<'AccountId', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>;
    };
  };
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type NumericPredicateAtom = never;
/**
 * Codec for {@link NumericPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const NumericPredicateAtom: lib.CodecContainer<never>;
/**
 * Structure with named fields.
 */ export interface SumeragiParameters {
  blockTime: lib.Duration;
  commitTime: lib.Duration;
  maxClockDrift: lib.Duration;
}
/**
 * Codec of the structure.
 */ export declare const SumeragiParameters: lib.CodecContainer<SumeragiParameters>;
/**
 * Structure with named fields.
 */ export interface TransactionParameters {
  maxInstructions: lib.NonZero<lib.U64>;
  smartContractSize: lib.NonZero<lib.U64>;
}
/**
 * Codec of the structure.
 */ export declare const TransactionParameters: lib.CodecContainer<TransactionParameters>;
/**
 * Structure with named fields.
 */ export interface SmartContractParameters {
  fuel: lib.NonZero<lib.U64>;
  memory: lib.NonZero<lib.U64>;
}
/**
 * Codec of the structure.
 */ export declare const SmartContractParameters: lib.CodecContainer<SmartContractParameters>;
/**
 * Structure with named fields.
 */ export interface Parameters {
  sumeragi: SumeragiParameters;
  block: BlockParameters;
  transaction: TransactionParameters;
  executor: SmartContractParameters;
  smartContract: SmartContractParameters;
  custom: lib.BTreeMap<CustomParameterId, CustomParameter>;
}
/**
 * Codec of the structure.
 */ export declare const Parameters: lib.CodecContainer<Parameters>;
/**
 * Structure with named fields.
 */ export interface Pagination {
  limit: lib.Option<lib.NonZero<lib.U64>>;
  offset: lib.U64;
}
/**
 * Codec of the structure.
 */ export declare const Pagination: lib.CodecContainer<Pagination>;
/**
 * Structure with named fields.
 */ export interface SocketAddrV4 {
  ip: Ipv4Addr;
  port: lib.U16;
}
/**
 * Codec of the structure.
 */ export declare const SocketAddrV4: lib.CodecContainer<SocketAddrV4>;
/**
 * Structure with named fields.
 */ export interface SocketAddrV6 {
  ip: Ipv6Addr;
  port: lib.U16;
}
/**
 * Codec of the structure.
 */ export declare const SocketAddrV6: lib.CodecContainer<SocketAddrV6>;
/**
 * Structure with named fields.
 */ export interface SocketAddrHost {
  host: lib.String;
  port: lib.U16;
}
/**
 * Codec of the structure.
 */ export declare const SocketAddrHost: lib.CodecContainer<SocketAddrHost>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Ipv4`
 * - `Ipv6`
 * - `Host`
 * 
 * TODO how to construct, how to use
 */ export type SocketAddr = lib.Variant<'Ipv4', SocketAddrV4> | lib.Variant<'Ipv6', SocketAddrV6> | lib.Variant<'Host', SocketAddrHost>;
/**
 * Codec and constructors for enumeration {@link SocketAddr}.
 */ export declare const SocketAddr: lib.CodecContainer<SocketAddr> & {
  Ipv4: <const T extends SocketAddrV4>(value: T) => lib.Variant<'Ipv4', T>;
  Ipv6: <const T extends SocketAddrV6>(value: T) => lib.Variant<'Ipv6', T>;
  Host: <const T extends SocketAddrHost>(value: T) => lib.Variant<'Host', T>;
};
/**
 * Structure with named fields.
 */ export interface Peer {
  address: SocketAddr;
  id: PeerId;
}
/**
 * Codec of the structure.
 */ export declare const Peer: lib.CodecContainer<Peer>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `PublicKey`
 * 
 * TODO how to construct, how to use
 */ export type PeerIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'PublicKey', PublicKeyProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link PeerIdProjectionSelector}.
 */ export declare const PeerIdProjectionSelector: lib.CodecContainer<PeerIdProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  PublicKey: {
    Atom: lib.Variant<'PublicKey', lib.VariantUnit<'Atom'>>;
  };
};
/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */ export type PermissionPredicateAtom = never;
/**
 * Codec for {@link PermissionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export declare const PermissionPredicateAtom: lib.CodecContainer<never>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */ export type PermissionProjectionSelector = lib.VariantUnit<'Atom'>;
/**
 * Codec and constructors for enumeration {@link PermissionProjectionSelector}.
 */ export declare const PermissionProjectionSelector: lib.CodecContainer<PermissionProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
};
/**
 * Structure with named fields and generic parameters.
 */ export interface QueryWithFilter<T0, T1, T2> {
  query: T0;
  predicate: T1;
  selector: T2;
}
/**
 * Codec constructor for the structure with generic parameters.
 */ export declare const QueryWithFilter: {
  readonly with: <T0, T1, T2>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>, t2: lib.GenCodec<T2>) => lib.GenCodec<QueryWithFilter<T0, T1, T2>>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */ export type RoleIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Name', NameProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link RoleIdProjectionSelector}.
 */ export declare const RoleIdProjectionSelector: lib.CodecContainer<RoleIdProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Name: {
    Atom: lib.Variant<'Name', lib.VariantUnit<'Atom'>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * 
 * TODO how to construct, how to use
 */ export type RoleProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', RoleIdProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link RoleProjectionSelector}.
 */ export declare const RoleProjectionSelector: lib.CodecContainer<RoleProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Id: {
    Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>;
    Name: {
      Atom: lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */ export type TriggerIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Name', NameProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link TriggerIdProjectionSelector}.
 */ export declare const TriggerIdProjectionSelector: lib.CodecContainer<TriggerIdProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Name: {
    Atom: lib.Variant<'Name', lib.VariantUnit<'Atom'>>;
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Action`
 * 
 * TODO how to construct, how to use
 */ export type TriggerProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', TriggerIdProjectionSelector> | lib.Variant<'Action', ActionProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link TriggerProjectionSelector}.
 */ export declare const TriggerProjectionSelector: lib.CodecContainer<TriggerProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Id: {
    Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>;
    Name: {
      Atom: lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>;
    };
  };
  Action: {
    Atom: lib.Variant<'Action', lib.VariantUnit<'Atom'>>;
    Metadata: {
      Atom: lib.Variant<'Action', lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>>;
      Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Action', lib.Variant<'Metadata', lib.Variant<'Key', T>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Header`
 * 
 * TODO how to construct, how to use
 */ export type SignedBlockProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Header', BlockHeaderProjectionSelector>;
/**
 * Codec and constructors for enumeration {@link SignedBlockProjectionSelector}.
 */ export declare const SignedBlockProjectionSelector: lib.CodecContainer<SignedBlockProjectionSelector> & {
  Atom: lib.VariantUnit<'Atom'>;
  Header: {
    Atom: lib.Variant<'Header', lib.VariantUnit<'Atom'>>;
    Hash: {
      Atom: lib.Variant<'Header', lib.Variant<'Hash', lib.VariantUnit<'Atom'>>>;
    };
  };
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `FindDomains`
 * - `FindAccounts`
 * - `FindAssets`
 * - `FindAssetsDefinitions`
 * - `FindNfts`
 * - `FindRoles`
 * - `FindRoleIds`
 * - `FindPermissionsByAccountId`
 * - `FindRolesByAccountId`
 * - `FindAccountsWithAsset`
 * - `FindPeers`
 * - `FindActiveTriggerIds`
 * - `FindTriggers`
 * - `FindTransactions`
 * - `FindBlocks`
 * - `FindBlockHeaders`
 * 
 * TODO how to construct, how to use
 */ export type QueryBox = lib.Variant<'FindDomains', QueryWithFilter<null, lib.CompoundPredicate<DomainProjectionPredicate>, lib.Vec<DomainProjectionSelector>>> | lib.Variant<'FindAccounts', QueryWithFilter<null, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>> | lib.Variant<'FindAssets', QueryWithFilter<null, lib.CompoundPredicate<AssetProjectionPredicate>, lib.Vec<AssetProjectionSelector>>> | lib.Variant<'FindAssetsDefinitions', QueryWithFilter<null, lib.CompoundPredicate<AssetDefinitionProjectionPredicate>, lib.Vec<AssetDefinitionProjectionSelector>>> | lib.Variant<'FindNfts', QueryWithFilter<null, lib.CompoundPredicate<NftProjectionPredicate>, lib.Vec<NftProjectionSelector>>> | lib.Variant<'FindRoles', QueryWithFilter<null, lib.CompoundPredicate<RoleProjectionPredicate>, lib.Vec<RoleProjectionSelector>>> | lib.Variant<'FindRoleIds', QueryWithFilter<null, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>> | lib.Variant<'FindPermissionsByAccountId', QueryWithFilter<FindPermissionsByAccountId, lib.CompoundPredicate<PermissionProjectionPredicate>, lib.Vec<PermissionProjectionSelector>>> | lib.Variant<'FindRolesByAccountId', QueryWithFilter<FindRolesByAccountId, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>> | lib.Variant<'FindAccountsWithAsset', QueryWithFilter<FindAccountsWithAsset, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>> | lib.Variant<'FindPeers', QueryWithFilter<null, lib.CompoundPredicate<PeerIdProjectionPredicate>, lib.Vec<PeerIdProjectionSelector>>> | lib.Variant<'FindActiveTriggerIds', QueryWithFilter<null, lib.CompoundPredicate<TriggerIdProjectionPredicate>, lib.Vec<TriggerIdProjectionSelector>>> | lib.Variant<'FindTriggers', QueryWithFilter<null, lib.CompoundPredicate<TriggerProjectionPredicate>, lib.Vec<TriggerProjectionSelector>>> | lib.Variant<'FindTransactions', QueryWithFilter<null, lib.CompoundPredicate<CommittedTransactionProjectionPredicate>, lib.Vec<CommittedTransactionProjectionSelector>>> | lib.Variant<'FindBlocks', QueryWithFilter<null, lib.CompoundPredicate<SignedBlockProjectionPredicate>, lib.Vec<SignedBlockProjectionSelector>>> | lib.Variant<'FindBlockHeaders', QueryWithFilter<null, lib.CompoundPredicate<BlockHeaderProjectionPredicate>, lib.Vec<BlockHeaderProjectionSelector>>>;
/**
 * Codec and constructors for enumeration {@link QueryBox}.
 */ export declare const QueryBox: lib.CodecContainer<QueryBox> & {
  FindDomains: <const T extends QueryWithFilter<null, lib.CompoundPredicate<DomainProjectionPredicate>, lib.Vec<DomainProjectionSelector>>>(value: T) => lib.Variant<'FindDomains', T>;
  FindAccounts: <const T extends QueryWithFilter<null, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>>(value: T) => lib.Variant<'FindAccounts', T>;
  FindAssets: <const T extends QueryWithFilter<null, lib.CompoundPredicate<AssetProjectionPredicate>, lib.Vec<AssetProjectionSelector>>>(value: T) => lib.Variant<'FindAssets', T>;
  FindAssetsDefinitions: <const T extends QueryWithFilter<null, lib.CompoundPredicate<AssetDefinitionProjectionPredicate>, lib.Vec<AssetDefinitionProjectionSelector>>>(value: T) => lib.Variant<'FindAssetsDefinitions', T>;
  FindNfts: <const T extends QueryWithFilter<null, lib.CompoundPredicate<NftProjectionPredicate>, lib.Vec<NftProjectionSelector>>>(value: T) => lib.Variant<'FindNfts', T>;
  FindRoles: <const T extends QueryWithFilter<null, lib.CompoundPredicate<RoleProjectionPredicate>, lib.Vec<RoleProjectionSelector>>>(value: T) => lib.Variant<'FindRoles', T>;
  FindRoleIds: <const T extends QueryWithFilter<null, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>>(value: T) => lib.Variant<'FindRoleIds', T>;
  FindPermissionsByAccountId: <const T extends QueryWithFilter<FindPermissionsByAccountId, lib.CompoundPredicate<PermissionProjectionPredicate>, lib.Vec<PermissionProjectionSelector>>>(value: T) => lib.Variant<'FindPermissionsByAccountId', T>;
  FindRolesByAccountId: <const T extends QueryWithFilter<FindRolesByAccountId, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>>(value: T) => lib.Variant<'FindRolesByAccountId', T>;
  FindAccountsWithAsset: <const T extends QueryWithFilter<FindAccountsWithAsset, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>>(value: T) => lib.Variant<'FindAccountsWithAsset', T>;
  FindPeers: <const T extends QueryWithFilter<null, lib.CompoundPredicate<PeerIdProjectionPredicate>, lib.Vec<PeerIdProjectionSelector>>>(value: T) => lib.Variant<'FindPeers', T>;
  FindActiveTriggerIds: <const T extends QueryWithFilter<null, lib.CompoundPredicate<TriggerIdProjectionPredicate>, lib.Vec<TriggerIdProjectionSelector>>>(value: T) => lib.Variant<'FindActiveTriggerIds', T>;
  FindTriggers: <const T extends QueryWithFilter<null, lib.CompoundPredicate<TriggerProjectionPredicate>, lib.Vec<TriggerProjectionSelector>>>(value: T) => lib.Variant<'FindTriggers', T>;
  FindTransactions: <const T extends QueryWithFilter<null, lib.CompoundPredicate<CommittedTransactionProjectionPredicate>, lib.Vec<CommittedTransactionProjectionSelector>>>(value: T) => lib.Variant<'FindTransactions', T>;
  FindBlocks: <const T extends QueryWithFilter<null, lib.CompoundPredicate<SignedBlockProjectionPredicate>, lib.Vec<SignedBlockProjectionSelector>>>(value: T) => lib.Variant<'FindBlocks', T>;
  FindBlockHeaders: <const T extends QueryWithFilter<null, lib.CompoundPredicate<BlockHeaderProjectionPredicate>, lib.Vec<BlockHeaderProjectionSelector>>>(value: T) => lib.Variant<'FindBlockHeaders', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `PublicKey`
 * - `String`
 * - `Metadata`
 * - `Json`
 * - `Numeric`
 * - `Name`
 * - `DomainId`
 * - `Domain`
 * - `AccountId`
 * - `Account`
 * - `AssetId`
 * - `Asset`
 * - `AssetDefinitionId`
 * - `AssetDefinition`
 * - `NftId`
 * - `Nft`
 * - `Role`
 * - `Parameter`
 * - `Permission`
 * - `CommittedTransaction`
 * - `SignedTransaction`
 * - `TransactionHash`
 * - `TransactionRejectionReason`
 * - `Peer`
 * - `RoleId`
 * - `TriggerId`
 * - `Trigger`
 * - `Action`
 * - `Block`
 * - `BlockHeader`
 * - `BlockHeaderHash`
 * 
 * TODO how to construct, how to use
 */ export type QueryOutputBatchBox = lib.Variant<'PublicKey', lib.Vec<lib.PublicKey>> | lib.Variant<'String', lib.Vec<lib.String>> | lib.Variant<'Metadata', lib.Vec<Metadata>> | lib.Variant<'Json', lib.Vec<lib.Json>> | lib.Variant<'Numeric', lib.Vec<Numeric>> | lib.Variant<'Name', lib.Vec<lib.Name>> | lib.Variant<'DomainId', lib.Vec<lib.DomainId>> | lib.Variant<'Domain', lib.Vec<Domain>> | lib.Variant<'AccountId', lib.Vec<lib.AccountId>> | lib.Variant<'Account', lib.Vec<Account>> | lib.Variant<'AssetId', lib.Vec<lib.AssetId>> | lib.Variant<'Asset', lib.Vec<Asset>> | lib.Variant<'AssetDefinitionId', lib.Vec<lib.AssetDefinitionId>> | lib.Variant<'AssetDefinition', lib.Vec<AssetDefinition>> | lib.Variant<'NftId', lib.Vec<lib.NftId>> | lib.Variant<'Nft', lib.Vec<Nft>> | lib.Variant<'Role', lib.Vec<Role>> | lib.Variant<'Parameter', lib.Vec<Parameter>> | lib.Variant<'Permission', lib.Vec<Permission>> | lib.Variant<'CommittedTransaction', lib.Vec<CommittedTransaction>> | lib.Variant<'SignedTransaction', lib.Vec<SignedTransaction>> | lib.Variant<'TransactionHash', lib.Vec<lib.Hash>> | lib.Variant<'TransactionRejectionReason', lib.Vec<lib.Option<TransactionRejectionReason>>> | lib.Variant<'Peer', lib.Vec<PeerId>> | lib.Variant<'RoleId', lib.Vec<RoleId>> | lib.Variant<'TriggerId', lib.Vec<TriggerId>> | lib.Variant<'Trigger', lib.Vec<Trigger>> | lib.Variant<'Action', lib.Vec<Action>> | lib.Variant<'Block', lib.Vec<SignedBlock>> | lib.Variant<'BlockHeader', lib.Vec<BlockHeader>> | lib.Variant<'BlockHeaderHash', lib.Vec<lib.Hash>>;
/**
 * Codec and constructors for enumeration {@link QueryOutputBatchBox}.
 */ export declare const QueryOutputBatchBox: lib.CodecContainer<QueryOutputBatchBox> & {
  PublicKey: <const T extends lib.Vec<lib.PublicKey>>(value: T) => lib.Variant<'PublicKey', T>;
  String: <const T extends lib.Vec<lib.String>>(value: T) => lib.Variant<'String', T>;
  Metadata: <const T extends lib.Vec<Metadata>>(value: T) => lib.Variant<'Metadata', T>;
  Json: <const T extends lib.Vec<lib.Json>>(value: T) => lib.Variant<'Json', T>;
  Numeric: <const T extends lib.Vec<Numeric>>(value: T) => lib.Variant<'Numeric', T>;
  Name: <const T extends lib.Vec<lib.Name>>(value: T) => lib.Variant<'Name', T>;
  DomainId: <const T extends lib.Vec<lib.DomainId>>(value: T) => lib.Variant<'DomainId', T>;
  Domain: <const T extends lib.Vec<Domain>>(value: T) => lib.Variant<'Domain', T>;
  AccountId: <const T extends lib.Vec<lib.AccountId>>(value: T) => lib.Variant<'AccountId', T>;
  Account: <const T extends lib.Vec<Account>>(value: T) => lib.Variant<'Account', T>;
  AssetId: <const T extends lib.Vec<lib.AssetId>>(value: T) => lib.Variant<'AssetId', T>;
  Asset: <const T extends lib.Vec<Asset>>(value: T) => lib.Variant<'Asset', T>;
  AssetDefinitionId: <const T extends lib.Vec<lib.AssetDefinitionId>>(value: T) => lib.Variant<'AssetDefinitionId', T>;
  AssetDefinition: <const T extends lib.Vec<AssetDefinition>>(value: T) => lib.Variant<'AssetDefinition', T>;
  NftId: <const T extends lib.Vec<lib.NftId>>(value: T) => lib.Variant<'NftId', T>;
  Nft: <const T extends lib.Vec<Nft>>(value: T) => lib.Variant<'Nft', T>;
  Role: <const T extends lib.Vec<Role>>(value: T) => lib.Variant<'Role', T>;
  Parameter: <const T extends lib.Vec<Parameter>>(value: T) => lib.Variant<'Parameter', T>;
  Permission: <const T extends lib.Vec<Permission>>(value: T) => lib.Variant<'Permission', T>;
  CommittedTransaction: <const T extends lib.Vec<CommittedTransaction>>(value: T) => lib.Variant<'CommittedTransaction', T>;
  SignedTransaction: <const T extends lib.Vec<SignedTransaction>>(value: T) => lib.Variant<'SignedTransaction', T>;
  TransactionHash: <const T extends lib.Vec<lib.Hash>>(value: T) => lib.Variant<'TransactionHash', T>;
  TransactionRejectionReason: <const T extends lib.Vec<lib.Option<TransactionRejectionReason>>>(value: T) => lib.Variant<'TransactionRejectionReason', T>;
  Peer: <const T extends lib.Vec<PeerId>>(value: T) => lib.Variant<'Peer', T>;
  RoleId: <const T extends lib.Vec<RoleId>>(value: T) => lib.Variant<'RoleId', T>;
  TriggerId: <const T extends lib.Vec<TriggerId>>(value: T) => lib.Variant<'TriggerId', T>;
  Trigger: <const T extends lib.Vec<Trigger>>(value: T) => lib.Variant<'Trigger', T>;
  Action: <const T extends lib.Vec<Action>>(value: T) => lib.Variant<'Action', T>;
  Block: <const T extends lib.Vec<SignedBlock>>(value: T) => lib.Variant<'Block', T>;
  BlockHeader: <const T extends lib.Vec<BlockHeader>>(value: T) => lib.Variant<'BlockHeader', T>;
  BlockHeaderHash: <const T extends lib.Vec<lib.Hash>>(value: T) => lib.Variant<'BlockHeaderHash', T>;
};
export type QueryOutputBatchBoxTuple = lib.Vec<QueryOutputBatchBox>;
export declare const QueryOutputBatchBoxTuple: lib.CodecContainer<QueryOutputBatchBoxTuple>;
/**
 * Structure with named fields.
 */ export interface QueryOutput {
  batch: QueryOutputBatchBoxTuple;
  remainingItems: lib.U64;
  continueCursor: lib.Option<ForwardCursor>;
}
/**
 * Codec of the structure.
 */ export declare const QueryOutput: lib.CodecContainer<QueryOutput>;
/**
 * Structure with named fields.
 */ export interface Sorting {
  sortByMetadataKey: lib.Option<lib.Name>;
}
/**
 * Codec of the structure.
 */ export declare const Sorting: lib.CodecContainer<Sorting>;
/**
 * Structure with named fields.
 */ export interface QueryParams {
  pagination: Pagination;
  sorting: Sorting;
  fetchSize: lib.Option<lib.NonZero<lib.U64>>;
}
/**
 * Codec of the structure.
 */ export declare const QueryParams: lib.CodecContainer<QueryParams>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `FindExecutorDataModel`
 * - `FindParameters`
 * 
 * TODO how to construct, how to use
 */ export type SingularQueryBox = lib.VariantUnit<'FindExecutorDataModel'> | lib.VariantUnit<'FindParameters'>;
/**
 * Codec and constructors for enumeration {@link SingularQueryBox}.
 */ export declare const SingularQueryBox: lib.CodecContainer<SingularQueryBox> & {
  FindExecutorDataModel: lib.VariantUnit<'FindExecutorDataModel'>;
  FindParameters: lib.VariantUnit<'FindParameters'>;
};
/**
 * Structure with named fields.
 */ export interface QueryWithParams {
  query: QueryBox;
  params: QueryParams;
}
/**
 * Codec of the structure.
 */ export declare const QueryWithParams: lib.CodecContainer<QueryWithParams>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Singular`
 * - `Start`
 * - `Continue`
 * 
 * TODO how to construct, how to use
 */ export type QueryRequest = lib.Variant<'Singular', SingularQueryBox> | lib.Variant<'Start', QueryWithParams> | lib.Variant<'Continue', ForwardCursor>;
/**
 * Codec and constructors for enumeration {@link QueryRequest}.
 */ export declare const QueryRequest: lib.CodecContainer<QueryRequest> & {
  Singular: {
    FindExecutorDataModel: lib.Variant<'Singular', lib.VariantUnit<'FindExecutorDataModel'>>;
    FindParameters: lib.Variant<'Singular', lib.VariantUnit<'FindParameters'>>;
  };
  Start: <const T extends QueryWithParams>(value: T) => lib.Variant<'Start', T>;
  Continue: <const T extends ForwardCursor>(value: T) => lib.Variant<'Continue', T>;
};
/**
 * Structure with named fields.
 */ export interface QueryRequestWithAuthority {
  authority: lib.AccountId;
  request: QueryRequest;
}
/**
 * Codec of the structure.
 */ export declare const QueryRequestWithAuthority: lib.CodecContainer<QueryRequestWithAuthority>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `ExecutorDataModel`
 * - `Parameters`
 * 
 * TODO how to construct, how to use
 */ export type SingularQueryOutputBox = lib.Variant<'ExecutorDataModel', ExecutorDataModel> | lib.Variant<'Parameters', Parameters>;
/**
 * Codec and constructors for enumeration {@link SingularQueryOutputBox}.
 */ export declare const SingularQueryOutputBox: lib.CodecContainer<SingularQueryOutputBox> & {
  ExecutorDataModel: <const T extends ExecutorDataModel>(value: T) => lib.Variant<'ExecutorDataModel', T>;
  Parameters: <const T extends Parameters>(value: T) => lib.Variant<'Parameters', T>;
};
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Singular`
 * - `Iterable`
 * 
 * TODO how to construct, how to use
 */ export type QueryResponse = lib.Variant<'Singular', SingularQueryOutputBox> | lib.Variant<'Iterable', QueryOutput>;
/**
 * Codec and constructors for enumeration {@link QueryResponse}.
 */ export declare const QueryResponse: lib.CodecContainer<QueryResponse> & {
  Singular: {
    ExecutorDataModel: <const T extends ExecutorDataModel>(value: T) => lib.Variant<'Singular', lib.Variant<'ExecutorDataModel', T>>;
    Parameters: <const T extends Parameters>(value: T) => lib.Variant<'Singular', lib.Variant<'Parameters', T>>;
  };
  Iterable: <const T extends QueryOutput>(value: T) => lib.Variant<'Iterable', T>;
};
/**
 * Structure with named fields.
 */ export interface RawGenesisTransaction {
  chain: ChainId;
  executor: lib.String;
  parameters: lib.Option<Parameters>;
  instructions: lib.Vec<InstructionBox>;
  wasmDir: lib.String;
  wasmTriggers: lib.Vec<GenesisWasmTrigger>;
  topology: lib.Vec<PeerId>;
}
/**
 * Codec of the structure.
 */ export declare const RawGenesisTransaction: lib.CodecContainer<RawGenesisTransaction>;
/**
 * Structure with named fields.
 */ export interface SignedQueryV1 {
  signature: lib.Signature;
  payload: QueryRequestWithAuthority;
}
/**
 * Codec of the structure.
 */ export declare const SignedQueryV1: lib.CodecContainer<SignedQueryV1>;
/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `V1`
 * 
 * TODO how to construct, how to use
 */ export type SignedQuery = lib.Variant<'V1', SignedQueryV1>;
/**
 * Codec and constructors for enumeration {@link SignedQuery}.
 */ export declare const SignedQuery: lib.CodecContainer<SignedQuery> & {
  V1: <const T extends SignedQueryV1>(value: T) => lib.Variant<'V1', T>;
};
/**
 * Structure with named fields.
 */ export interface Uptime {
  secs: lib.Compact;
  nanos: lib.U32;
}
/**
 * Codec of the structure.
 */ export declare const Uptime: lib.CodecContainer<Uptime>;
/**
 * Structure with named fields.
 */ export interface Status {
  peers: lib.Compact;
  blocks: lib.Compact;
  blocksNonEmpty: lib.Compact;
  txsApproved: lib.Compact;
  txsRejected: lib.Compact;
  uptime: Uptime;
  viewChanges: lib.Compact;
  queueSize: lib.Compact;
}
/**
 * Codec of the structure.
 */ export declare const Status: lib.CodecContainer<Status>;
//# sourceMappingURL=types.generated.d.ts.map
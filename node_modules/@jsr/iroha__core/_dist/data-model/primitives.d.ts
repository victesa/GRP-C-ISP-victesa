import { type CodecContainer, GenCodec } from "../codec.js";
import { type IsZero, type Ord, type OrdKnown } from "../traits.js";
import { type CompareFn } from "../util.js";
export type U8 = number;
export declare const U8: CodecContainer<U8>;
export type U16 = number;
export declare const U16: CodecContainer<U16>;
export type U32 = number;
export declare const U32: CodecContainer<U32>;
export type U64 = bigint;
export declare const U64: CodecContainer<U64>;
export type U128 = bigint;
export declare const U128: CodecContainer<U128>;
export type BytesVec = Uint8Array;
export declare const BytesVec: CodecContainer<BytesVec>;
export type Bool = boolean;
export declare const Bool: CodecContainer<Bool>;
export type String = string;
export declare const String: CodecContainer<string>;
export type Compact = bigint;
export declare const Compact: CodecContainer<bigint>;
export declare class NonZero<T extends number | bigint | IsZero> {
  public static with<T extends number | bigint | IsZero>(codec: GenCodec<T>): GenCodec<NonZero<T>>;
  private _value: any;
  private __brand: any;
  public constructor(value: T);
  public get value(): T;
  public map<U extends number | bigint | IsZero>(fun: (value: T) => U): NonZero<U>;
  public toJSON(): T;
}
export type Option<T> = null | T;
export declare const Option: {
  readonly with: <T>(value: GenCodec<T>) => GenCodec<Option<T>>;
};
export type Vec<T> = globalThis.Array<T>;
export declare const Vec: {
  with<T>(item: GenCodec<T>): GenCodec<Vec<T>>;
};
/**
 * "Sorted vector".
 *
 * Represented as a plain array. The codec ensures that the entries are encoded in a deterministic manner,
 * by sorting and deduplicating items.
 */ export type BTreeSet<T> = Vec<T>;
/**
 * Codec factories for {@link BTreeSet:type}
 */ export declare const BTreeSet: {
  with<T extends Ord<T> | string>(type: GenCodec<T>): GenCodec<BTreeSet<T>>;
  withCmp<T>(codec: GenCodec<T>, compare: CompareFn<T>): GenCodec<BTreeSet<T>>;
};
export interface MapEntry<K, V> {
  key: K;
  value: V;
}
/**
 * "Sorted map".
 *
 * Represented as a plain array. The codec ensures that the entries are encoded in a deterministic manner, by sorting and deduplicating items.
 *
 * Items comparison is based on their keys.
 *
 * @example
 * ```ts
 * import { getCodec } from '../codec.ts'
 * import { assertEquals } from '@std/assert/equals'
 *
 * const map1: BTreeMap<string, number> = [
 *   { key: 'a', value: 5 },
 *   { key: 'c', value: 2 },
 *   { key: 'b', value: 3 }
 * ]
 *
 * const map2: BTreeMap<string, number> = [
 *   { key: 'c', value: 2 },
 *   { key: 'a', value: 2 },
 *   { key: 'a', value: 5 },
 *   { key: 'b', value: 3 }
 * ]
 *
 * const codec = BTreeMap.with(getCodec(String), getCodec(U8))
 *
 * assertEquals(codec.encode(map1), codec.encode(map2))
 * assertEquals(codec.decode(codec.encode(map1)), [
 *   { key: 'a', value: 5 },
 *   { key: 'b', value: 3 },
 *   { key: 'c', value: 2 }
 * ])
 * ```
 */ export type BTreeMap<K, V> = Array<MapEntry<K, V>>;
export declare const BTreeMap: {
  readonly with: <K extends Ord<K> | OrdKnown, V>(key: GenCodec<K>, value: GenCodec<V>) => GenCodec<BTreeMap<K, V>>;
  readonly withCmp: <K, V>(key: GenCodec<K>, value: GenCodec<V>, compareFn: CompareFn<MapEntry<K, V>>) => GenCodec<BTreeMap<K, V>>;
};
//# sourceMappingURL=primitives.d.ts.map
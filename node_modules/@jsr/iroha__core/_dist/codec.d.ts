/**
 * [SCALE](https://docs.polkadot.com/polkadot-protocol/basics/data-encoding) codec utilities.
 *
 * These are mostly used internally, but you can use it in case you need to extend codec functionality.
 *
 * This module is mostly based on the [`@scale-codec/core`](https://www.npmjs.com/package/@scale-codec/core) package.
 *
 * @module
 */ import * as scale from "@scale-codec/core";
import type { Variant, VariantUnit } from "./util.js";
export declare const SYMBOL_CODEC: '$codec';
/**
 * Extracts codec from its container.
 */ export declare function getCodec<T>(type: CodecContainer<T>): GenCodec<T>;
/**
 * Wraps a codec into {@link CodecContainer}.
 */ export declare function defineCodec<T>(codec: GenCodec<T>): CodecContainer<T>;
/**
 * A value that contains a codec under a "special" key ({@link SYMBOL_CODEC}).
 */ export interface CodecContainer<T> {
  [SYMBOL_CODEC]: GenCodec<T>;
}
export interface RawScaleCodec<T> {
  encode: scale.Encode<T>;
  decode: scale.Decode<T>;
}
/**
 * Generic codec.
 *
 * Unlike {@link RawScaleCodec}, provides higher-level encode/decode functions, as well as some composition utilities.
 */ export declare class GenCodec<T> {
  /**
   * Create a lazy codec, by only having a getter to the actual codec.
   *
   * The getter is called for each codec access and is not cached.
   */ public static lazy<T>(f: () => GenCodec<T>): GenCodec<T>;
  /**
   * Access lower-level SCALE codec
   */ public readonly raw: RawScaleCodec<T>;
  public constructor(raw: RawScaleCodec<T>);
  public encode(value: T): Uint8Array;
  public decode(data: string | ArrayBufferView): T;
  public wrap<U>({}: {
    toBase: (value: U) => T;
    fromBase: (value: T) => U;
  }): GenCodec<U>;
}
export declare class EnumCodec<E extends scale.EnumRecord> extends GenCodec<scale.Enumerate<E>> {
  public discriminated<T extends {
    [Tag in keyof E]: E[Tag] extends [] ? VariantUnit<Tag> : E[Tag] extends [infer Value] ? Variant<Tag, Value> : never;
  }[keyof E]>(): GenCodec<T>;
  public literalUnion(): GenCodec<{
    [Tag in keyof E]: E[Tag] extends [] ? Tag : never;
  }[keyof E]>;
}
export declare function lazyCodec<T>(f: () => GenCodec<T>): GenCodec<T>;
export type EnumCodecSchema<E extends scale.EnumRecord> = {
  [K in keyof E]: E[K] extends [infer V] ? [discriminant: number, codec: GenCodec<V>] : [discriminant: number];
};
export declare function enumCodec<E extends scale.EnumRecord>(schema: EnumCodecSchema<E>): EnumCodec<E>;
type TupleFromCodecs<T> = T extends [GenCodec<infer Head>, ...infer Tail] ? [Head, ...TupleFromCodecs<Tail>] : T extends [] ? [] : never;
export declare function tupleCodec<T extends [GenCodec<any>, ...GenCodec<any>[]]>(codecs: T): GenCodec<TupleFromCodecs<T>>;
export declare type StructCodecsSchema<T> = {
  [K in keyof T]: [K, GenCodec<T[K]>];
}[keyof T][];
export declare function structCodec<T>(order: (keyof T & string)[], schema: {
  [K in keyof T]: GenCodec<T[K]>;
}): GenCodec<T>;
export declare const neverCodec: GenCodec<never>;
export declare const nullCodec: GenCodec<null>;
export declare function bitmapCodec<Name extends string>(masks: {
  [K in Name]: number;
}): GenCodec<Set<Name>>;
//# sourceMappingURL=codec.d.ts.map
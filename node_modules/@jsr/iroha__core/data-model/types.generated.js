import * as lib from "./types.generated.prelude.js";
export const Metadata = lib.defineCodec(lib.BTreeMap.with(lib.getCodec(lib.Name), lib.getCodec(lib.Json)));
/**
 * Codec of the structure.
 */ export const Account = lib.defineCodec(lib.structCodec([
  'id',
  'metadata'
], {
  id: lib.getCodec(lib.AccountId),
  metadata: lib.getCodec(Metadata)
}));
/**
 * Codec of the structure.
 */ export const Numeric = lib.defineCodec(lib.structCodec([
  'mantissa',
  'scale'
], {
  mantissa: lib.getCodec(lib.Compact),
  scale: lib.getCodec(lib.Compact)
}));
/**
 * Codec of the structure.
 */ export const Asset = lib.defineCodec(lib.structCodec([
  'id',
  'value'
], {
  id: lib.getCodec(lib.AssetId),
  value: lib.getCodec(Numeric)
}));
/**
 * Codec of the structure.
 */ export const AssetChanged = lib.defineCodec(lib.structCodec([
  'asset',
  'amount'
], {
  asset: lib.getCodec(lib.AssetId),
  amount: lib.getCodec(Numeric)
}));
/**
 * Codec and constructors for enumeration {@link AssetEvent}.
 */ export const AssetEvent = {
  ...{
    Created: (value)=>({
        kind: 'Created',
        value
      }),
    Deleted: (value)=>({
        kind: 'Deleted',
        value
      }),
    Added: (value)=>({
        kind: 'Added',
        value
      }),
    Removed: (value)=>({
        kind: 'Removed',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Created: [
      0,
      lib.getCodec(Asset)
    ],
    Deleted: [
      1,
      lib.getCodec(lib.AssetId)
    ],
    Added: [
      2,
      lib.getCodec(AssetChanged)
    ],
    Removed: [
      3,
      lib.getCodec(AssetChanged)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const Permission = lib.defineCodec(lib.structCodec([
  'name',
  'payload'
], {
  name: lib.getCodec(lib.String),
  payload: lib.getCodec(lib.Json)
}));
/**
 * Codec of the structure.
 */ export const AccountPermissionChanged = lib.defineCodec(lib.structCodec([
  'account',
  'permission'
], {
  account: lib.getCodec(lib.AccountId),
  permission: lib.getCodec(Permission)
}));
export const RoleId = lib.Name;
/**
 * Codec of the structure.
 */ export const AccountRoleChanged = lib.defineCodec(lib.structCodec([
  'account',
  'role'
], {
  account: lib.getCodec(lib.AccountId),
  role: lib.getCodec(RoleId)
}));
/**
 * Codec constructor for the structure with generic parameters.
 */ export const MetadataChanged = {
  with: (t0)=>lib.structCodec([
      'target',
      'key',
      'value'
    ], {
      target: t0,
      key: lib.getCodec(lib.Name),
      value: lib.getCodec(lib.Json)
    })
};
/**
 * Codec and constructors for enumeration {@link AccountEvent}.
 */ export const AccountEvent = {
  ...{
    Created: (value)=>({
        kind: 'Created',
        value
      }),
    Deleted: (value)=>({
        kind: 'Deleted',
        value
      }),
    Asset: {
      Created: (value)=>({
          kind: 'Asset',
          value: AssetEvent.Created(value)
        }),
      Deleted: (value)=>({
          kind: 'Asset',
          value: AssetEvent.Deleted(value)
        }),
      Added: (value)=>({
          kind: 'Asset',
          value: AssetEvent.Added(value)
        }),
      Removed: (value)=>({
          kind: 'Asset',
          value: AssetEvent.Removed(value)
        })
    },
    PermissionAdded: (value)=>({
        kind: 'PermissionAdded',
        value
      }),
    PermissionRemoved: (value)=>({
        kind: 'PermissionRemoved',
        value
      }),
    RoleGranted: (value)=>({
        kind: 'RoleGranted',
        value
      }),
    RoleRevoked: (value)=>({
        kind: 'RoleRevoked',
        value
      }),
    MetadataInserted: (value)=>({
        kind: 'MetadataInserted',
        value
      }),
    MetadataRemoved: (value)=>({
        kind: 'MetadataRemoved',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Created: [
      0,
      lib.getCodec(Account)
    ],
    Deleted: [
      1,
      lib.getCodec(lib.AccountId)
    ],
    Asset: [
      2,
      lib.getCodec(AssetEvent)
    ],
    PermissionAdded: [
      3,
      lib.getCodec(AccountPermissionChanged)
    ],
    PermissionRemoved: [
      4,
      lib.getCodec(AccountPermissionChanged)
    ],
    RoleGranted: [
      5,
      lib.getCodec(AccountRoleChanged)
    ],
    RoleRevoked: [
      6,
      lib.getCodec(AccountRoleChanged)
    ],
    MetadataInserted: [
      7,
      MetadataChanged.with(lib.getCodec(lib.AccountId))
    ],
    MetadataRemoved: [
      8,
      MetadataChanged.with(lib.getCodec(lib.AccountId))
    ]
  }).discriminated())
};
export const AccountEventSet = lib.defineCodec(lib.bitmapCodec({
  Created: 1,
  Deleted: 2,
  AnyAsset: 4,
  PermissionAdded: 8,
  PermissionRemoved: 16,
  RoleGranted: 32,
  RoleRevoked: 64,
  MetadataInserted: 128,
  MetadataRemoved: 256
}));
/**
 * Codec of the structure.
 */ export const AccountEventFilter = lib.defineCodec(lib.structCodec([
  'idMatcher',
  'eventSet'
], {
  idMatcher: lib.Option.with(lib.getCodec(lib.AccountId)),
  eventSet: lib.getCodec(AccountEventSet)
}));
/**
 * Codec and constructors for enumeration {@link AccountIdPredicateAtom}.
 */ export const AccountIdPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(lib.AccountId)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link DomainIdPredicateAtom}.
 */ export const DomainIdPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(lib.DomainId)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link StringPredicateAtom}.
 */ export const StringPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      }),
    Contains: (value)=>({
        kind: 'Contains',
        value
      }),
    StartsWith: (value)=>({
        kind: 'StartsWith',
        value
      }),
    EndsWith: (value)=>({
        kind: 'EndsWith',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(lib.String)
    ],
    Contains: [
      1,
      lib.getCodec(lib.String)
    ],
    StartsWith: [
      2,
      lib.getCodec(lib.String)
    ],
    EndsWith: [
      3,
      lib.getCodec(lib.String)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link NameProjectionPredicate}.
 */ export const NameProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: StringPredicateAtom.Equals(value)
        }),
      Contains: (value)=>({
          kind: 'Atom',
          value: StringPredicateAtom.Contains(value)
        }),
      StartsWith: (value)=>({
          kind: 'Atom',
          value: StringPredicateAtom.StartsWith(value)
        }),
      EndsWith: (value)=>({
          kind: 'Atom',
          value: StringPredicateAtom.EndsWith(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(StringPredicateAtom)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link DomainIdProjectionPredicate}.
 */ export const DomainIdProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: DomainIdPredicateAtom.Equals(value)
        })
    },
    Name: {
      Atom: {
        Equals: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.Equals(value)
          }),
        Contains: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.Contains(value)
          }),
        StartsWith: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.StartsWith(value)
          }),
        EndsWith: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.EndsWith(value)
          })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(DomainIdPredicateAtom)
    ],
    Name: [
      1,
      lib.getCodec(NameProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link PublicKeyPredicateAtom}.
 */ export const PublicKeyPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(lib.PublicKey)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link PublicKeyProjectionPredicate}.
 */ export const PublicKeyProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: PublicKeyPredicateAtom.Equals(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(PublicKeyPredicateAtom)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AccountIdProjectionPredicate}.
 */ export const AccountIdProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: AccountIdPredicateAtom.Equals(value)
        })
    },
    Domain: {
      Atom: {
        Equals: (value)=>({
            kind: 'Domain',
            value: DomainIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Name: {
        Atom: {
          Equals: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.Equals(value)
            }),
          Contains: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.Contains(value)
            }),
          StartsWith: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.StartsWith(value)
            }),
          EndsWith: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.EndsWith(value)
            })
        }
      }
    },
    Signatory: {
      Atom: {
        Equals: (value)=>({
            kind: 'Signatory',
            value: PublicKeyProjectionPredicate.Atom.Equals(value)
          })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(AccountIdPredicateAtom)
    ],
    Domain: [
      1,
      lib.getCodec(DomainIdProjectionPredicate)
    ],
    Signatory: [
      2,
      lib.getCodec(PublicKeyProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link NameProjectionSelector}.
 */ export const NameProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link DomainIdProjectionSelector}.
 */ export const DomainIdProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Name: {
      Atom: Object.freeze({
        kind: 'Name',
        value: NameProjectionSelector.Atom
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Name: [
      1,
      lib.getCodec(NameProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link PublicKeyProjectionSelector}.
 */ export const PublicKeyProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AccountIdProjectionSelector}.
 */ export const AccountIdProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Domain: {
      Atom: Object.freeze({
        kind: 'Domain',
        value: DomainIdProjectionSelector.Atom
      }),
      Name: {
        Atom: Object.freeze({
          kind: 'Domain',
          value: DomainIdProjectionSelector.Name.Atom
        })
      }
    },
    Signatory: {
      Atom: Object.freeze({
        kind: 'Signatory',
        value: PublicKeyProjectionSelector.Atom
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Domain: [
      1,
      lib.getCodec(DomainIdProjectionSelector)
    ],
    Signatory: [
      2,
      lib.getCodec(PublicKeyProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec for {@link AccountPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const AccountPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec for {@link MetadataPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const MetadataPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link JsonPredicateAtom}.
 */ export const JsonPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(lib.Json)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link JsonProjectionPredicate}.
 */ export const JsonProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: JsonPredicateAtom.Equals(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(JsonPredicateAtom)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const MetadataKeyProjectionPredicate = lib.defineCodec(lib.structCodec([
  'key',
  'projection'
], {
  key: lib.getCodec(lib.Name),
  projection: lib.getCodec(JsonProjectionPredicate)
}));
/**
 * Codec and constructors for enumeration {@link MetadataProjectionPredicate}.
 */ export const MetadataProjectionPredicate = {
  ...{
    Key: (value)=>({
        kind: 'Key',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(MetadataPredicateAtom)
    ],
    Key: [
      1,
      lib.getCodec(MetadataKeyProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AccountProjectionPredicate}.
 */ export const AccountProjectionPredicate = {
  ...{
    Id: {
      Atom: {
        Equals: (value)=>({
            kind: 'Id',
            value: AccountIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Domain: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: AccountIdProjectionPredicate.Domain.Atom.Equals(value)
            })
        },
        Name: {
          Atom: {
            Equals: (value)=>({
                kind: 'Id',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.Equals(value)
              }),
            Contains: (value)=>({
                kind: 'Id',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.Contains(value)
              }),
            StartsWith: (value)=>({
                kind: 'Id',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.StartsWith(value)
              }),
            EndsWith: (value)=>({
                kind: 'Id',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.EndsWith(value)
              })
          }
        }
      },
      Signatory: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: AccountIdProjectionPredicate.Signatory.Atom.Equals(value)
            })
        }
      }
    },
    Metadata: {
      Key: (value)=>({
          kind: 'Metadata',
          value: MetadataProjectionPredicate.Key(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(AccountPredicateAtom)
    ],
    Id: [
      1,
      lib.getCodec(AccountIdProjectionPredicate)
    ],
    Metadata: [
      2,
      lib.getCodec(MetadataProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link JsonProjectionSelector}.
 */ export const JsonProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const MetadataKeyProjectionSelector = lib.defineCodec(lib.structCodec([
  'key',
  'projection'
], {
  key: lib.getCodec(lib.Name),
  projection: lib.getCodec(JsonProjectionSelector)
}));
/**
 * Codec and constructors for enumeration {@link MetadataProjectionSelector}.
 */ export const MetadataProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Key: (value)=>({
        kind: 'Key',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Key: [
      1,
      lib.getCodec(MetadataKeyProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AccountProjectionSelector}.
 */ export const AccountProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Id: {
      Atom: Object.freeze({
        kind: 'Id',
        value: AccountIdProjectionSelector.Atom
      }),
      Domain: {
        Atom: Object.freeze({
          kind: 'Id',
          value: AccountIdProjectionSelector.Domain.Atom
        }),
        Name: {
          Atom: Object.freeze({
            kind: 'Id',
            value: AccountIdProjectionSelector.Domain.Name.Atom
          })
        }
      },
      Signatory: {
        Atom: Object.freeze({
          kind: 'Id',
          value: AccountIdProjectionSelector.Signatory.Atom
        })
      }
    },
    Metadata: {
      Atom: Object.freeze({
        kind: 'Metadata',
        value: MetadataProjectionSelector.Atom
      }),
      Key: (value)=>({
          kind: 'Metadata',
          value: MetadataProjectionSelector.Key(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Id: [
      1,
      lib.getCodec(AccountIdProjectionSelector)
    ],
    Metadata: [
      2,
      lib.getCodec(MetadataProjectionSelector)
    ]
  }).discriminated())
};
export const WasmSmartContract = lib.BytesVec;
/**
 * Codec and constructors for enumeration {@link Executable}.
 */ export const Executable = {
  ...{
    Instructions: (value)=>({
        kind: 'Instructions',
        value
      }),
    Wasm: (value)=>({
        kind: 'Wasm',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Instructions: [
      0,
      lib.Vec.with(lib.lazyCodec(()=>lib.getCodec(InstructionBox)))
    ],
    Wasm: [
      1,
      lib.getCodec(WasmSmartContract)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link Repeats}.
 */ export const Repeats = {
  ...{
    Indefinitely: Object.freeze({
      kind: 'Indefinitely'
    }),
    Exactly: (value)=>({
        kind: 'Exactly',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Indefinitely: [
      0
    ],
    Exactly: [
      1,
      lib.getCodec(lib.U32)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const PeerId = lib.defineCodec(lib.structCodec([
  'publicKey'
], {
  publicKey: lib.getCodec(lib.PublicKey)
}));
export const TriggerId = lib.Name;
/**
 * Codec and constructors for enumeration {@link FindError}.
 */ export const FindError = {
  ...{
    Asset: (value)=>({
        kind: 'Asset',
        value
      }),
    AssetDefinition: (value)=>({
        kind: 'AssetDefinition',
        value
      }),
    Nft: (value)=>({
        kind: 'Nft',
        value
      }),
    Account: (value)=>({
        kind: 'Account',
        value
      }),
    Domain: (value)=>({
        kind: 'Domain',
        value
      }),
    MetadataKey: (value)=>({
        kind: 'MetadataKey',
        value
      }),
    Block: (value)=>({
        kind: 'Block',
        value
      }),
    Transaction: (value)=>({
        kind: 'Transaction',
        value
      }),
    Peer: (value)=>({
        kind: 'Peer',
        value
      }),
    Trigger: (value)=>({
        kind: 'Trigger',
        value
      }),
    Role: (value)=>({
        kind: 'Role',
        value
      }),
    Permission: (value)=>({
        kind: 'Permission',
        value
      }),
    PublicKey: (value)=>({
        kind: 'PublicKey',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Asset: [
      0,
      lib.getCodec(lib.AssetId)
    ],
    AssetDefinition: [
      1,
      lib.getCodec(lib.AssetDefinitionId)
    ],
    Nft: [
      2,
      lib.getCodec(lib.NftId)
    ],
    Account: [
      3,
      lib.getCodec(lib.AccountId)
    ],
    Domain: [
      4,
      lib.getCodec(lib.DomainId)
    ],
    MetadataKey: [
      5,
      lib.getCodec(lib.Name)
    ],
    Block: [
      6,
      lib.getCodec(lib.Hash)
    ],
    Transaction: [
      7,
      lib.getCodec(lib.Hash)
    ],
    Peer: [
      8,
      lib.getCodec(PeerId)
    ],
    Trigger: [
      9,
      lib.getCodec(TriggerId)
    ],
    Role: [
      10,
      lib.getCodec(RoleId)
    ],
    Permission: [
      11,
      lib.getCodec(Permission)
    ],
    PublicKey: [
      12,
      lib.getCodec(lib.PublicKey)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const TransactionLimitError = lib.defineCodec(lib.structCodec([
  'reason'
], {
  reason: lib.getCodec(lib.String)
}));
/**
 * Codec and constructors for enumeration {@link InstructionType}.
 */ export const InstructionType = {
  ...{
    Register: Object.freeze({
      kind: 'Register'
    }),
    Unregister: Object.freeze({
      kind: 'Unregister'
    }),
    Mint: Object.freeze({
      kind: 'Mint'
    }),
    Burn: Object.freeze({
      kind: 'Burn'
    }),
    Transfer: Object.freeze({
      kind: 'Transfer'
    }),
    SetKeyValue: Object.freeze({
      kind: 'SetKeyValue'
    }),
    RemoveKeyValue: Object.freeze({
      kind: 'RemoveKeyValue'
    }),
    Grant: Object.freeze({
      kind: 'Grant'
    }),
    Revoke: Object.freeze({
      kind: 'Revoke'
    }),
    ExecuteTrigger: Object.freeze({
      kind: 'ExecuteTrigger'
    }),
    SetParameter: Object.freeze({
      kind: 'SetParameter'
    }),
    Upgrade: Object.freeze({
      kind: 'Upgrade'
    }),
    Log: Object.freeze({
      kind: 'Log'
    }),
    Custom: Object.freeze({
      kind: 'Custom'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Register: [
      0
    ],
    Unregister: [
      1
    ],
    Mint: [
      2
    ],
    Burn: [
      3
    ],
    Transfer: [
      4
    ],
    SetKeyValue: [
      5
    ],
    RemoveKeyValue: [
      6
    ],
    Grant: [
      7
    ],
    Revoke: [
      8
    ],
    ExecuteTrigger: [
      9
    ],
    SetParameter: [
      10
    ],
    Upgrade: [
      11
    ],
    Log: [
      12
    ],
    Custom: [
      13
    ]
  }).discriminated())
};
/**
 * Codec constructor for the structure with generic parameters.
 */ export const Mismatch = {
  with: (t0)=>lib.structCodec([
      'expected',
      'actual'
    ], {
      expected: t0,
      actual: t0
    })
};
/**
 * Codec of the structure.
 */ export const NumericSpec = lib.defineCodec(lib.structCodec([
  'scale'
], {
  scale: lib.Option.with(lib.getCodec(lib.U32))
}));
/**
 * Codec and constructors for enumeration {@link TypeError}.
 */ export const TypeError = {
  ...{
    AssetNumericSpec: (value)=>({
        kind: 'AssetNumericSpec',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    AssetNumericSpec: [
      0,
      Mismatch.with(lib.getCodec(NumericSpec))
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link InstructionEvaluationError}.
 */ export const InstructionEvaluationError = {
  ...{
    Unsupported: {
      Register: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.Register
      }),
      Unregister: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.Unregister
      }),
      Mint: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.Mint
      }),
      Burn: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.Burn
      }),
      Transfer: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.Transfer
      }),
      SetKeyValue: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.SetKeyValue
      }),
      RemoveKeyValue: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.RemoveKeyValue
      }),
      Grant: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.Grant
      }),
      Revoke: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.Revoke
      }),
      ExecuteTrigger: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.ExecuteTrigger
      }),
      SetParameter: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.SetParameter
      }),
      Upgrade: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.Upgrade
      }),
      Log: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.Log
      }),
      Custom: Object.freeze({
        kind: 'Unsupported',
        value: InstructionType.Custom
      })
    },
    PermissionParameter: (value)=>({
        kind: 'PermissionParameter',
        value
      }),
    Type: {
      AssetNumericSpec: (value)=>({
          kind: 'Type',
          value: TypeError.AssetNumericSpec(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Unsupported: [
      0,
      lib.getCodec(InstructionType)
    ],
    PermissionParameter: [
      1,
      lib.getCodec(lib.String)
    ],
    Type: [
      2,
      lib.getCodec(TypeError)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link QueryExecutionFail}.
 */ export const QueryExecutionFail = {
  ...{
    Find: {
      Asset: (value)=>({
          kind: 'Find',
          value: FindError.Asset(value)
        }),
      AssetDefinition: (value)=>({
          kind: 'Find',
          value: FindError.AssetDefinition(value)
        }),
      Nft: (value)=>({
          kind: 'Find',
          value: FindError.Nft(value)
        }),
      Account: (value)=>({
          kind: 'Find',
          value: FindError.Account(value)
        }),
      Domain: (value)=>({
          kind: 'Find',
          value: FindError.Domain(value)
        }),
      MetadataKey: (value)=>({
          kind: 'Find',
          value: FindError.MetadataKey(value)
        }),
      Block: (value)=>({
          kind: 'Find',
          value: FindError.Block(value)
        }),
      Transaction: (value)=>({
          kind: 'Find',
          value: FindError.Transaction(value)
        }),
      Peer: (value)=>({
          kind: 'Find',
          value: FindError.Peer(value)
        }),
      Trigger: (value)=>({
          kind: 'Find',
          value: FindError.Trigger(value)
        }),
      Role: (value)=>({
          kind: 'Find',
          value: FindError.Role(value)
        }),
      Permission: (value)=>({
          kind: 'Find',
          value: FindError.Permission(value)
        }),
      PublicKey: (value)=>({
          kind: 'Find',
          value: FindError.PublicKey(value)
        })
    },
    Conversion: (value)=>({
        kind: 'Conversion',
        value
      }),
    NotFound: Object.freeze({
      kind: 'NotFound'
    }),
    CursorMismatch: Object.freeze({
      kind: 'CursorMismatch'
    }),
    CursorDone: Object.freeze({
      kind: 'CursorDone'
    }),
    FetchSizeTooBig: Object.freeze({
      kind: 'FetchSizeTooBig'
    }),
    InvalidSingularParameters: Object.freeze({
      kind: 'InvalidSingularParameters'
    }),
    CapacityLimit: Object.freeze({
      kind: 'CapacityLimit'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Find: [
      0,
      lib.getCodec(FindError)
    ],
    Conversion: [
      1,
      lib.getCodec(lib.String)
    ],
    NotFound: [
      2
    ],
    CursorMismatch: [
      3
    ],
    CursorDone: [
      4
    ],
    FetchSizeTooBig: [
      5
    ],
    InvalidSingularParameters: [
      6
    ],
    CapacityLimit: [
      7
    ]
  }).discriminated())
};
export const CustomParameterId = lib.Name;
/**
 * Codec and constructors for enumeration {@link IdBox}.
 */ export const IdBox = {
  ...{
    DomainId: (value)=>({
        kind: 'DomainId',
        value
      }),
    AccountId: (value)=>({
        kind: 'AccountId',
        value
      }),
    AssetDefinitionId: (value)=>({
        kind: 'AssetDefinitionId',
        value
      }),
    AssetId: (value)=>({
        kind: 'AssetId',
        value
      }),
    NftId: (value)=>({
        kind: 'NftId',
        value
      }),
    PeerId: (value)=>({
        kind: 'PeerId',
        value
      }),
    TriggerId: (value)=>({
        kind: 'TriggerId',
        value
      }),
    RoleId: (value)=>({
        kind: 'RoleId',
        value
      }),
    Permission: (value)=>({
        kind: 'Permission',
        value
      }),
    CustomParameterId: (value)=>({
        kind: 'CustomParameterId',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    DomainId: [
      0,
      lib.getCodec(lib.DomainId)
    ],
    AccountId: [
      1,
      lib.getCodec(lib.AccountId)
    ],
    AssetDefinitionId: [
      2,
      lib.getCodec(lib.AssetDefinitionId)
    ],
    AssetId: [
      3,
      lib.getCodec(lib.AssetId)
    ],
    NftId: [
      4,
      lib.getCodec(lib.NftId)
    ],
    PeerId: [
      5,
      lib.getCodec(PeerId)
    ],
    TriggerId: [
      6,
      lib.getCodec(TriggerId)
    ],
    RoleId: [
      7,
      lib.getCodec(RoleId)
    ],
    Permission: [
      8,
      lib.getCodec(Permission)
    ],
    CustomParameterId: [
      9,
      lib.getCodec(CustomParameterId)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const RepetitionError = lib.defineCodec(lib.structCodec([
  'instruction',
  'id'
], {
  instruction: lib.getCodec(InstructionType),
  id: lib.getCodec(IdBox)
}));
/**
 * Codec and constructors for enumeration {@link MintabilityError}.
 */ export const MintabilityError = {
  ...{
    MintUnmintable: Object.freeze({
      kind: 'MintUnmintable'
    }),
    ForbidMintOnMintable: Object.freeze({
      kind: 'ForbidMintOnMintable'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    MintUnmintable: [
      0
    ],
    ForbidMintOnMintable: [
      1
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link MathError}.
 */ export const MathError = {
  ...{
    Overflow: Object.freeze({
      kind: 'Overflow'
    }),
    NotEnoughQuantity: Object.freeze({
      kind: 'NotEnoughQuantity'
    }),
    DivideByZero: Object.freeze({
      kind: 'DivideByZero'
    }),
    NegativeValue: Object.freeze({
      kind: 'NegativeValue'
    }),
    DomainViolation: Object.freeze({
      kind: 'DomainViolation'
    }),
    Unknown: Object.freeze({
      kind: 'Unknown'
    }),
    FixedPointConversion: (value)=>({
        kind: 'FixedPointConversion',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Overflow: [
      0
    ],
    NotEnoughQuantity: [
      1
    ],
    DivideByZero: [
      2
    ],
    NegativeValue: [
      3
    ],
    DomainViolation: [
      4
    ],
    Unknown: [
      5
    ],
    FixedPointConversion: [
      6,
      lib.getCodec(lib.String)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link InvalidParameterError}.
 */ export const InvalidParameterError = {
  ...{
    Wasm: (value)=>({
        kind: 'Wasm',
        value
      }),
    TimeTriggerInThePast: Object.freeze({
      kind: 'TimeTriggerInThePast'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Wasm: [
      0,
      lib.getCodec(lib.String)
    ],
    TimeTriggerInThePast: [
      1
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link InstructionExecutionError}.
 */ export const InstructionExecutionError = {
  ...{
    Evaluate: {
      Unsupported: {
        Register: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.Register
        }),
        Unregister: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.Unregister
        }),
        Mint: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.Mint
        }),
        Burn: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.Burn
        }),
        Transfer: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.Transfer
        }),
        SetKeyValue: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.SetKeyValue
        }),
        RemoveKeyValue: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.RemoveKeyValue
        }),
        Grant: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.Grant
        }),
        Revoke: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.Revoke
        }),
        ExecuteTrigger: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.ExecuteTrigger
        }),
        SetParameter: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.SetParameter
        }),
        Upgrade: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.Upgrade
        }),
        Log: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.Log
        }),
        Custom: Object.freeze({
          kind: 'Evaluate',
          value: InstructionEvaluationError.Unsupported.Custom
        })
      },
      PermissionParameter: (value)=>({
          kind: 'Evaluate',
          value: InstructionEvaluationError.PermissionParameter(value)
        }),
      Type: {
        AssetNumericSpec: (value)=>({
            kind: 'Evaluate',
            value: InstructionEvaluationError.Type.AssetNumericSpec(value)
          })
      }
    },
    Query: {
      Find: {
        Asset: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.Asset(value)
          }),
        AssetDefinition: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.AssetDefinition(value)
          }),
        Nft: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.Nft(value)
          }),
        Account: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.Account(value)
          }),
        Domain: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.Domain(value)
          }),
        MetadataKey: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.MetadataKey(value)
          }),
        Block: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.Block(value)
          }),
        Transaction: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.Transaction(value)
          }),
        Peer: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.Peer(value)
          }),
        Trigger: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.Trigger(value)
          }),
        Role: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.Role(value)
          }),
        Permission: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.Permission(value)
          }),
        PublicKey: (value)=>({
            kind: 'Query',
            value: QueryExecutionFail.Find.PublicKey(value)
          })
      },
      Conversion: (value)=>({
          kind: 'Query',
          value: QueryExecutionFail.Conversion(value)
        }),
      NotFound: Object.freeze({
        kind: 'Query',
        value: QueryExecutionFail.NotFound
      }),
      CursorMismatch: Object.freeze({
        kind: 'Query',
        value: QueryExecutionFail.CursorMismatch
      }),
      CursorDone: Object.freeze({
        kind: 'Query',
        value: QueryExecutionFail.CursorDone
      }),
      FetchSizeTooBig: Object.freeze({
        kind: 'Query',
        value: QueryExecutionFail.FetchSizeTooBig
      }),
      InvalidSingularParameters: Object.freeze({
        kind: 'Query',
        value: QueryExecutionFail.InvalidSingularParameters
      }),
      CapacityLimit: Object.freeze({
        kind: 'Query',
        value: QueryExecutionFail.CapacityLimit
      })
    },
    Conversion: (value)=>({
        kind: 'Conversion',
        value
      }),
    Find: {
      Asset: (value)=>({
          kind: 'Find',
          value: FindError.Asset(value)
        }),
      AssetDefinition: (value)=>({
          kind: 'Find',
          value: FindError.AssetDefinition(value)
        }),
      Nft: (value)=>({
          kind: 'Find',
          value: FindError.Nft(value)
        }),
      Account: (value)=>({
          kind: 'Find',
          value: FindError.Account(value)
        }),
      Domain: (value)=>({
          kind: 'Find',
          value: FindError.Domain(value)
        }),
      MetadataKey: (value)=>({
          kind: 'Find',
          value: FindError.MetadataKey(value)
        }),
      Block: (value)=>({
          kind: 'Find',
          value: FindError.Block(value)
        }),
      Transaction: (value)=>({
          kind: 'Find',
          value: FindError.Transaction(value)
        }),
      Peer: (value)=>({
          kind: 'Find',
          value: FindError.Peer(value)
        }),
      Trigger: (value)=>({
          kind: 'Find',
          value: FindError.Trigger(value)
        }),
      Role: (value)=>({
          kind: 'Find',
          value: FindError.Role(value)
        }),
      Permission: (value)=>({
          kind: 'Find',
          value: FindError.Permission(value)
        }),
      PublicKey: (value)=>({
          kind: 'Find',
          value: FindError.PublicKey(value)
        })
    },
    Repetition: (value)=>({
        kind: 'Repetition',
        value
      }),
    Mintability: {
      MintUnmintable: Object.freeze({
        kind: 'Mintability',
        value: MintabilityError.MintUnmintable
      }),
      ForbidMintOnMintable: Object.freeze({
        kind: 'Mintability',
        value: MintabilityError.ForbidMintOnMintable
      })
    },
    Math: {
      Overflow: Object.freeze({
        kind: 'Math',
        value: MathError.Overflow
      }),
      NotEnoughQuantity: Object.freeze({
        kind: 'Math',
        value: MathError.NotEnoughQuantity
      }),
      DivideByZero: Object.freeze({
        kind: 'Math',
        value: MathError.DivideByZero
      }),
      NegativeValue: Object.freeze({
        kind: 'Math',
        value: MathError.NegativeValue
      }),
      DomainViolation: Object.freeze({
        kind: 'Math',
        value: MathError.DomainViolation
      }),
      Unknown: Object.freeze({
        kind: 'Math',
        value: MathError.Unknown
      }),
      FixedPointConversion: (value)=>({
          kind: 'Math',
          value: MathError.FixedPointConversion(value)
        })
    },
    InvalidParameter: {
      Wasm: (value)=>({
          kind: 'InvalidParameter',
          value: InvalidParameterError.Wasm(value)
        }),
      TimeTriggerInThePast: Object.freeze({
        kind: 'InvalidParameter',
        value: InvalidParameterError.TimeTriggerInThePast
      })
    },
    InvariantViolation: (value)=>({
        kind: 'InvariantViolation',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Evaluate: [
      0,
      lib.getCodec(InstructionEvaluationError)
    ],
    Query: [
      1,
      lib.getCodec(QueryExecutionFail)
    ],
    Conversion: [
      2,
      lib.getCodec(lib.String)
    ],
    Find: [
      3,
      lib.getCodec(FindError)
    ],
    Repetition: [
      4,
      lib.getCodec(RepetitionError)
    ],
    Mintability: [
      5,
      lib.getCodec(MintabilityError)
    ],
    Math: [
      6,
      lib.getCodec(MathError)
    ],
    InvalidParameter: [
      7,
      lib.getCodec(InvalidParameterError)
    ],
    InvariantViolation: [
      8,
      lib.getCodec(lib.String)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link ValidationFail}.
 */ export const ValidationFail = {
  ...{
    NotPermitted: (value)=>({
        kind: 'NotPermitted',
        value
      }),
    InstructionFailed: {
      Evaluate: {
        Unsupported: {
          Register: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.Register
          }),
          Unregister: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.Unregister
          }),
          Mint: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.Mint
          }),
          Burn: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.Burn
          }),
          Transfer: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.Transfer
          }),
          SetKeyValue: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.SetKeyValue
          }),
          RemoveKeyValue: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.RemoveKeyValue
          }),
          Grant: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.Grant
          }),
          Revoke: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.Revoke
          }),
          ExecuteTrigger: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.ExecuteTrigger
          }),
          SetParameter: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.SetParameter
          }),
          Upgrade: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.Upgrade
          }),
          Log: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.Log
          }),
          Custom: Object.freeze({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.Unsupported.Custom
          })
        },
        PermissionParameter: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Evaluate.PermissionParameter(value)
          }),
        Type: {
          AssetNumericSpec: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Evaluate.Type.AssetNumericSpec(value)
            })
        }
      },
      Query: {
        Find: {
          Asset: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.Asset(value)
            }),
          AssetDefinition: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.AssetDefinition(value)
            }),
          Nft: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.Nft(value)
            }),
          Account: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.Account(value)
            }),
          Domain: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.Domain(value)
            }),
          MetadataKey: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.MetadataKey(value)
            }),
          Block: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.Block(value)
            }),
          Transaction: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.Transaction(value)
            }),
          Peer: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.Peer(value)
            }),
          Trigger: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.Trigger(value)
            }),
          Role: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.Role(value)
            }),
          Permission: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.Permission(value)
            }),
          PublicKey: (value)=>({
              kind: 'InstructionFailed',
              value: InstructionExecutionError.Query.Find.PublicKey(value)
            })
        },
        Conversion: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Query.Conversion(value)
          }),
        NotFound: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Query.NotFound
        }),
        CursorMismatch: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Query.CursorMismatch
        }),
        CursorDone: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Query.CursorDone
        }),
        FetchSizeTooBig: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Query.FetchSizeTooBig
        }),
        InvalidSingularParameters: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Query.InvalidSingularParameters
        }),
        CapacityLimit: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Query.CapacityLimit
        })
      },
      Conversion: (value)=>({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Conversion(value)
        }),
      Find: {
        Asset: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.Asset(value)
          }),
        AssetDefinition: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.AssetDefinition(value)
          }),
        Nft: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.Nft(value)
          }),
        Account: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.Account(value)
          }),
        Domain: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.Domain(value)
          }),
        MetadataKey: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.MetadataKey(value)
          }),
        Block: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.Block(value)
          }),
        Transaction: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.Transaction(value)
          }),
        Peer: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.Peer(value)
          }),
        Trigger: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.Trigger(value)
          }),
        Role: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.Role(value)
          }),
        Permission: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.Permission(value)
          }),
        PublicKey: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Find.PublicKey(value)
          })
      },
      Repetition: (value)=>({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Repetition(value)
        }),
      Mintability: {
        MintUnmintable: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Mintability.MintUnmintable
        }),
        ForbidMintOnMintable: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Mintability.ForbidMintOnMintable
        })
      },
      Math: {
        Overflow: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Math.Overflow
        }),
        NotEnoughQuantity: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Math.NotEnoughQuantity
        }),
        DivideByZero: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Math.DivideByZero
        }),
        NegativeValue: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Math.NegativeValue
        }),
        DomainViolation: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Math.DomainViolation
        }),
        Unknown: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.Math.Unknown
        }),
        FixedPointConversion: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.Math.FixedPointConversion(value)
          })
      },
      InvalidParameter: {
        Wasm: (value)=>({
            kind: 'InstructionFailed',
            value: InstructionExecutionError.InvalidParameter.Wasm(value)
          }),
        TimeTriggerInThePast: Object.freeze({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.InvalidParameter.TimeTriggerInThePast
        })
      },
      InvariantViolation: (value)=>({
          kind: 'InstructionFailed',
          value: InstructionExecutionError.InvariantViolation(value)
        })
    },
    QueryFailed: {
      Find: {
        Asset: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.Asset(value)
          }),
        AssetDefinition: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.AssetDefinition(value)
          }),
        Nft: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.Nft(value)
          }),
        Account: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.Account(value)
          }),
        Domain: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.Domain(value)
          }),
        MetadataKey: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.MetadataKey(value)
          }),
        Block: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.Block(value)
          }),
        Transaction: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.Transaction(value)
          }),
        Peer: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.Peer(value)
          }),
        Trigger: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.Trigger(value)
          }),
        Role: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.Role(value)
          }),
        Permission: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.Permission(value)
          }),
        PublicKey: (value)=>({
            kind: 'QueryFailed',
            value: QueryExecutionFail.Find.PublicKey(value)
          })
      },
      Conversion: (value)=>({
          kind: 'QueryFailed',
          value: QueryExecutionFail.Conversion(value)
        }),
      NotFound: Object.freeze({
        kind: 'QueryFailed',
        value: QueryExecutionFail.NotFound
      }),
      CursorMismatch: Object.freeze({
        kind: 'QueryFailed',
        value: QueryExecutionFail.CursorMismatch
      }),
      CursorDone: Object.freeze({
        kind: 'QueryFailed',
        value: QueryExecutionFail.CursorDone
      }),
      FetchSizeTooBig: Object.freeze({
        kind: 'QueryFailed',
        value: QueryExecutionFail.FetchSizeTooBig
      }),
      InvalidSingularParameters: Object.freeze({
        kind: 'QueryFailed',
        value: QueryExecutionFail.InvalidSingularParameters
      }),
      CapacityLimit: Object.freeze({
        kind: 'QueryFailed',
        value: QueryExecutionFail.CapacityLimit
      })
    },
    TooComplex: Object.freeze({
      kind: 'TooComplex'
    }),
    InternalError: Object.freeze({
      kind: 'InternalError'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    NotPermitted: [
      0,
      lib.getCodec(lib.String)
    ],
    InstructionFailed: [
      1,
      lib.getCodec(InstructionExecutionError)
    ],
    QueryFailed: [
      2,
      lib.getCodec(QueryExecutionFail)
    ],
    TooComplex: [
      3
    ],
    InternalError: [
      4
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const InstructionExecutionFail = lib.defineCodec(lib.structCodec([
  'instruction',
  'reason'
], {
  instruction: lib.lazyCodec(()=>lib.getCodec(InstructionBox)),
  reason: lib.getCodec(lib.String)
}));
/**
 * Codec of the structure.
 */ export const WasmExecutionFail = lib.defineCodec(lib.structCodec([
  'reason'
], {
  reason: lib.getCodec(lib.String)
}));
/**
 * Codec and constructors for enumeration {@link TransactionRejectionReason}.
 */ export const TransactionRejectionReason = {
  ...{
    AccountDoesNotExist: {
      Asset: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.Asset(value)
        }),
      AssetDefinition: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.AssetDefinition(value)
        }),
      Nft: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.Nft(value)
        }),
      Account: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.Account(value)
        }),
      Domain: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.Domain(value)
        }),
      MetadataKey: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.MetadataKey(value)
        }),
      Block: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.Block(value)
        }),
      Transaction: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.Transaction(value)
        }),
      Peer: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.Peer(value)
        }),
      Trigger: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.Trigger(value)
        }),
      Role: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.Role(value)
        }),
      Permission: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.Permission(value)
        }),
      PublicKey: (value)=>({
          kind: 'AccountDoesNotExist',
          value: FindError.PublicKey(value)
        })
    },
    LimitCheck: (value)=>({
        kind: 'LimitCheck',
        value
      }),
    Validation: {
      NotPermitted: (value)=>({
          kind: 'Validation',
          value: ValidationFail.NotPermitted(value)
        }),
      InstructionFailed: {
        Evaluate: {
          Unsupported: {
            Register: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Register
            }),
            Unregister: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Unregister
            }),
            Mint: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Mint
            }),
            Burn: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Burn
            }),
            Transfer: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Transfer
            }),
            SetKeyValue: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.SetKeyValue
            }),
            RemoveKeyValue: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.RemoveKeyValue
            }),
            Grant: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Grant
            }),
            Revoke: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Revoke
            }),
            ExecuteTrigger: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.ExecuteTrigger
            }),
            SetParameter: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.SetParameter
            }),
            Upgrade: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Upgrade
            }),
            Log: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Log
            }),
            Custom: Object.freeze({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Custom
            })
          },
          PermissionParameter: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Evaluate.PermissionParameter(value)
            }),
          Type: {
            AssetNumericSpec: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Evaluate.Type.AssetNumericSpec(value)
              })
          }
        },
        Query: {
          Find: {
            Asset: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.Asset(value)
              }),
            AssetDefinition: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.AssetDefinition(value)
              }),
            Nft: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.Nft(value)
              }),
            Account: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.Account(value)
              }),
            Domain: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.Domain(value)
              }),
            MetadataKey: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.MetadataKey(value)
              }),
            Block: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.Block(value)
              }),
            Transaction: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.Transaction(value)
              }),
            Peer: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.Peer(value)
              }),
            Trigger: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.Trigger(value)
              }),
            Role: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.Role(value)
              }),
            Permission: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.Permission(value)
              }),
            PublicKey: (value)=>({
                kind: 'Validation',
                value: ValidationFail.InstructionFailed.Query.Find.PublicKey(value)
              })
          },
          Conversion: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Query.Conversion(value)
            }),
          NotFound: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Query.NotFound
          }),
          CursorMismatch: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Query.CursorMismatch
          }),
          CursorDone: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Query.CursorDone
          }),
          FetchSizeTooBig: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Query.FetchSizeTooBig
          }),
          InvalidSingularParameters: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Query.InvalidSingularParameters
          }),
          CapacityLimit: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Query.CapacityLimit
          })
        },
        Conversion: (value)=>({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Conversion(value)
          }),
        Find: {
          Asset: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.Asset(value)
            }),
          AssetDefinition: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.AssetDefinition(value)
            }),
          Nft: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.Nft(value)
            }),
          Account: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.Account(value)
            }),
          Domain: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.Domain(value)
            }),
          MetadataKey: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.MetadataKey(value)
            }),
          Block: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.Block(value)
            }),
          Transaction: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.Transaction(value)
            }),
          Peer: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.Peer(value)
            }),
          Trigger: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.Trigger(value)
            }),
          Role: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.Role(value)
            }),
          Permission: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.Permission(value)
            }),
          PublicKey: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Find.PublicKey(value)
            })
        },
        Repetition: (value)=>({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Repetition(value)
          }),
        Mintability: {
          MintUnmintable: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Mintability.MintUnmintable
          }),
          ForbidMintOnMintable: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Mintability.ForbidMintOnMintable
          })
        },
        Math: {
          Overflow: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Math.Overflow
          }),
          NotEnoughQuantity: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Math.NotEnoughQuantity
          }),
          DivideByZero: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Math.DivideByZero
          }),
          NegativeValue: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Math.NegativeValue
          }),
          DomainViolation: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Math.DomainViolation
          }),
          Unknown: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.Math.Unknown
          }),
          FixedPointConversion: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.Math.FixedPointConversion(value)
            })
        },
        InvalidParameter: {
          Wasm: (value)=>({
              kind: 'Validation',
              value: ValidationFail.InstructionFailed.InvalidParameter.Wasm(value)
            }),
          TimeTriggerInThePast: Object.freeze({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.InvalidParameter.TimeTriggerInThePast
          })
        },
        InvariantViolation: (value)=>({
            kind: 'Validation',
            value: ValidationFail.InstructionFailed.InvariantViolation(value)
          })
      },
      QueryFailed: {
        Find: {
          Asset: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.Asset(value)
            }),
          AssetDefinition: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.AssetDefinition(value)
            }),
          Nft: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.Nft(value)
            }),
          Account: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.Account(value)
            }),
          Domain: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.Domain(value)
            }),
          MetadataKey: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.MetadataKey(value)
            }),
          Block: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.Block(value)
            }),
          Transaction: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.Transaction(value)
            }),
          Peer: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.Peer(value)
            }),
          Trigger: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.Trigger(value)
            }),
          Role: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.Role(value)
            }),
          Permission: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.Permission(value)
            }),
          PublicKey: (value)=>({
              kind: 'Validation',
              value: ValidationFail.QueryFailed.Find.PublicKey(value)
            })
        },
        Conversion: (value)=>({
            kind: 'Validation',
            value: ValidationFail.QueryFailed.Conversion(value)
          }),
        NotFound: Object.freeze({
          kind: 'Validation',
          value: ValidationFail.QueryFailed.NotFound
        }),
        CursorMismatch: Object.freeze({
          kind: 'Validation',
          value: ValidationFail.QueryFailed.CursorMismatch
        }),
        CursorDone: Object.freeze({
          kind: 'Validation',
          value: ValidationFail.QueryFailed.CursorDone
        }),
        FetchSizeTooBig: Object.freeze({
          kind: 'Validation',
          value: ValidationFail.QueryFailed.FetchSizeTooBig
        }),
        InvalidSingularParameters: Object.freeze({
          kind: 'Validation',
          value: ValidationFail.QueryFailed.InvalidSingularParameters
        }),
        CapacityLimit: Object.freeze({
          kind: 'Validation',
          value: ValidationFail.QueryFailed.CapacityLimit
        })
      },
      TooComplex: Object.freeze({
        kind: 'Validation',
        value: ValidationFail.TooComplex
      }),
      InternalError: Object.freeze({
        kind: 'Validation',
        value: ValidationFail.InternalError
      })
    },
    InstructionExecution: (value)=>({
        kind: 'InstructionExecution',
        value
      }),
    WasmExecution: (value)=>({
        kind: 'WasmExecution',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    AccountDoesNotExist: [
      0,
      lib.getCodec(FindError)
    ],
    LimitCheck: [
      1,
      lib.getCodec(TransactionLimitError)
    ],
    Validation: [
      2,
      lib.getCodec(ValidationFail)
    ],
    InstructionExecution: [
      3,
      lib.getCodec(InstructionExecutionFail)
    ],
    WasmExecution: [
      4,
      lib.getCodec(WasmExecutionFail)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TransactionStatus}.
 */ export const TransactionStatus = {
  ...{
    Queued: Object.freeze({
      kind: 'Queued'
    }),
    Expired: Object.freeze({
      kind: 'Expired'
    }),
    Approved: Object.freeze({
      kind: 'Approved'
    }),
    Rejected: {
      AccountDoesNotExist: {
        Asset: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.Asset(value)
          }),
        AssetDefinition: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.AssetDefinition(value)
          }),
        Nft: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.Nft(value)
          }),
        Account: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.Account(value)
          }),
        Domain: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.Domain(value)
          }),
        MetadataKey: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.MetadataKey(value)
          }),
        Block: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.Block(value)
          }),
        Transaction: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.Transaction(value)
          }),
        Peer: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.Peer(value)
          }),
        Trigger: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.Trigger(value)
          }),
        Role: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.Role(value)
          }),
        Permission: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.Permission(value)
          }),
        PublicKey: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.AccountDoesNotExist.PublicKey(value)
          })
      },
      LimitCheck: (value)=>({
          kind: 'Rejected',
          value: TransactionRejectionReason.LimitCheck(value)
        }),
      Validation: {
        NotPermitted: (value)=>({
            kind: 'Rejected',
            value: TransactionRejectionReason.Validation.NotPermitted(value)
          }),
        InstructionFailed: {
          Evaluate: {
            Unsupported: {
              Register: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Register
              }),
              Unregister: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Unregister
              }),
              Mint: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Mint
              }),
              Burn: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Burn
              }),
              Transfer: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Transfer
              }),
              SetKeyValue: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.SetKeyValue
              }),
              RemoveKeyValue: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.RemoveKeyValue
              }),
              Grant: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Grant
              }),
              Revoke: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Revoke
              }),
              ExecuteTrigger: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.ExecuteTrigger
              }),
              SetParameter: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.SetParameter
              }),
              Upgrade: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Upgrade
              }),
              Log: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Log
              }),
              Custom: Object.freeze({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Custom
              })
            },
            PermissionParameter: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.PermissionParameter(value)
              }),
            Type: {
              AssetNumericSpec: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Type.AssetNumericSpec(value)
                })
            }
          },
          Query: {
            Find: {
              Asset: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Asset(value)
                }),
              AssetDefinition: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.AssetDefinition(value)
                }),
              Nft: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Nft(value)
                }),
              Account: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Account(value)
                }),
              Domain: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Domain(value)
                }),
              MetadataKey: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.MetadataKey(value)
                }),
              Block: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Block(value)
                }),
              Transaction: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Transaction(value)
                }),
              Peer: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Peer(value)
                }),
              Trigger: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Trigger(value)
                }),
              Role: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Role(value)
                }),
              Permission: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Permission(value)
                }),
              PublicKey: (value)=>({
                  kind: 'Rejected',
                  value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.PublicKey(value)
                })
            },
            Conversion: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Query.Conversion(value)
              }),
            NotFound: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Query.NotFound
            }),
            CursorMismatch: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Query.CursorMismatch
            }),
            CursorDone: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Query.CursorDone
            }),
            FetchSizeTooBig: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Query.FetchSizeTooBig
            }),
            InvalidSingularParameters: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Query.InvalidSingularParameters
            }),
            CapacityLimit: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Query.CapacityLimit
            })
          },
          Conversion: (value)=>({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Conversion(value)
            }),
          Find: {
            Asset: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.Asset(value)
              }),
            AssetDefinition: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.AssetDefinition(value)
              }),
            Nft: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.Nft(value)
              }),
            Account: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.Account(value)
              }),
            Domain: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.Domain(value)
              }),
            MetadataKey: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.MetadataKey(value)
              }),
            Block: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.Block(value)
              }),
            Transaction: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.Transaction(value)
              }),
            Peer: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.Peer(value)
              }),
            Trigger: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.Trigger(value)
              }),
            Role: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.Role(value)
              }),
            Permission: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.Permission(value)
              }),
            PublicKey: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Find.PublicKey(value)
              })
          },
          Repetition: (value)=>({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Repetition(value)
            }),
          Mintability: {
            MintUnmintable: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Mintability.MintUnmintable
            }),
            ForbidMintOnMintable: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Mintability.ForbidMintOnMintable
            })
          },
          Math: {
            Overflow: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Math.Overflow
            }),
            NotEnoughQuantity: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Math.NotEnoughQuantity
            }),
            DivideByZero: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Math.DivideByZero
            }),
            NegativeValue: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Math.NegativeValue
            }),
            DomainViolation: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Math.DomainViolation
            }),
            Unknown: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.Math.Unknown
            }),
            FixedPointConversion: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.Math.FixedPointConversion(value)
              })
          },
          InvalidParameter: {
            Wasm: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.InstructionFailed.InvalidParameter.Wasm(value)
              }),
            TimeTriggerInThePast: Object.freeze({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.InvalidParameter.TimeTriggerInThePast
            })
          },
          InvariantViolation: (value)=>({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.InstructionFailed.InvariantViolation(value)
            })
        },
        QueryFailed: {
          Find: {
            Asset: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.Asset(value)
              }),
            AssetDefinition: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.AssetDefinition(value)
              }),
            Nft: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.Nft(value)
              }),
            Account: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.Account(value)
              }),
            Domain: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.Domain(value)
              }),
            MetadataKey: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.MetadataKey(value)
              }),
            Block: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.Block(value)
              }),
            Transaction: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.Transaction(value)
              }),
            Peer: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.Peer(value)
              }),
            Trigger: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.Trigger(value)
              }),
            Role: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.Role(value)
              }),
            Permission: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.Permission(value)
              }),
            PublicKey: (value)=>({
                kind: 'Rejected',
                value: TransactionRejectionReason.Validation.QueryFailed.Find.PublicKey(value)
              })
          },
          Conversion: (value)=>({
              kind: 'Rejected',
              value: TransactionRejectionReason.Validation.QueryFailed.Conversion(value)
            }),
          NotFound: Object.freeze({
            kind: 'Rejected',
            value: TransactionRejectionReason.Validation.QueryFailed.NotFound
          }),
          CursorMismatch: Object.freeze({
            kind: 'Rejected',
            value: TransactionRejectionReason.Validation.QueryFailed.CursorMismatch
          }),
          CursorDone: Object.freeze({
            kind: 'Rejected',
            value: TransactionRejectionReason.Validation.QueryFailed.CursorDone
          }),
          FetchSizeTooBig: Object.freeze({
            kind: 'Rejected',
            value: TransactionRejectionReason.Validation.QueryFailed.FetchSizeTooBig
          }),
          InvalidSingularParameters: Object.freeze({
            kind: 'Rejected',
            value: TransactionRejectionReason.Validation.QueryFailed.InvalidSingularParameters
          }),
          CapacityLimit: Object.freeze({
            kind: 'Rejected',
            value: TransactionRejectionReason.Validation.QueryFailed.CapacityLimit
          })
        },
        TooComplex: Object.freeze({
          kind: 'Rejected',
          value: TransactionRejectionReason.Validation.TooComplex
        }),
        InternalError: Object.freeze({
          kind: 'Rejected',
          value: TransactionRejectionReason.Validation.InternalError
        })
      },
      InstructionExecution: (value)=>({
          kind: 'Rejected',
          value: TransactionRejectionReason.InstructionExecution(value)
        }),
      WasmExecution: (value)=>({
          kind: 'Rejected',
          value: TransactionRejectionReason.WasmExecution(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Queued: [
      0
    ],
    Expired: [
      1
    ],
    Approved: [
      2
    ],
    Rejected: [
      3,
      lib.getCodec(TransactionRejectionReason)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const TransactionEventFilter = lib.defineCodec(lib.structCodec([
  'hash',
  'blockHeight',
  'status'
], {
  hash: lib.Option.with(lib.getCodec(lib.Hash)),
  blockHeight: lib.Option.with(lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U64)))),
  status: lib.Option.with(lib.getCodec(TransactionStatus))
}));
/**
 * Codec and constructors for enumeration {@link BlockRejectionReason}.
 */ export const BlockRejectionReason = {
  ...{
    ConsensusBlockRejection: Object.freeze({
      kind: 'ConsensusBlockRejection'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    ConsensusBlockRejection: [
      0
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link BlockStatus}.
 */ export const BlockStatus = {
  ...{
    Created: Object.freeze({
      kind: 'Created'
    }),
    Approved: Object.freeze({
      kind: 'Approved'
    }),
    Rejected: {
      ConsensusBlockRejection: Object.freeze({
        kind: 'Rejected',
        value: BlockRejectionReason.ConsensusBlockRejection
      })
    },
    Committed: Object.freeze({
      kind: 'Committed'
    }),
    Applied: Object.freeze({
      kind: 'Applied'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Created: [
      0
    ],
    Approved: [
      1
    ],
    Rejected: [
      2,
      lib.getCodec(BlockRejectionReason)
    ],
    Committed: [
      3
    ],
    Applied: [
      4
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const BlockEventFilter = lib.defineCodec(lib.structCodec([
  'height',
  'status'
], {
  height: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U64))),
  status: lib.Option.with(lib.getCodec(BlockStatus))
}));
/**
 * Codec and constructors for enumeration {@link PipelineEventFilterBox}.
 */ export const PipelineEventFilterBox = {
  ...{
    Transaction: (value)=>({
        kind: 'Transaction',
        value
      }),
    Block: (value)=>({
        kind: 'Block',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Transaction: [
      0,
      lib.getCodec(TransactionEventFilter)
    ],
    Block: [
      1,
      lib.getCodec(BlockEventFilter)
    ]
  }).discriminated())
};
export const PeerEventSet = lib.defineCodec(lib.bitmapCodec({
  Added: 1,
  Removed: 2
}));
/**
 * Codec of the structure.
 */ export const PeerEventFilter = lib.defineCodec(lib.structCodec([
  'idMatcher',
  'eventSet'
], {
  idMatcher: lib.Option.with(lib.getCodec(PeerId)),
  eventSet: lib.getCodec(PeerEventSet)
}));
export const DomainEventSet = lib.defineCodec(lib.bitmapCodec({
  Created: 1,
  Deleted: 2,
  AnyAssetDefinition: 4,
  AnyNft: 8,
  AnyAccount: 16,
  MetadataInserted: 32,
  MetadataRemoved: 64,
  OwnerChanged: 128
}));
/**
 * Codec of the structure.
 */ export const DomainEventFilter = lib.defineCodec(lib.structCodec([
  'idMatcher',
  'eventSet'
], {
  idMatcher: lib.Option.with(lib.getCodec(lib.DomainId)),
  eventSet: lib.getCodec(DomainEventSet)
}));
export const AssetEventSet = lib.defineCodec(lib.bitmapCodec({
  Created: 1,
  Deleted: 2,
  Added: 4,
  Removed: 8
}));
/**
 * Codec of the structure.
 */ export const AssetEventFilter = lib.defineCodec(lib.structCodec([
  'idMatcher',
  'eventSet'
], {
  idMatcher: lib.Option.with(lib.getCodec(lib.AssetId)),
  eventSet: lib.getCodec(AssetEventSet)
}));
export const AssetDefinitionEventSet = lib.defineCodec(lib.bitmapCodec({
  Created: 1,
  Deleted: 2,
  MetadataInserted: 4,
  MetadataRemoved: 8,
  MintabilityChanged: 16,
  TotalQuantityChanged: 32,
  OwnerChanged: 64
}));
/**
 * Codec of the structure.
 */ export const AssetDefinitionEventFilter = lib.defineCodec(lib.structCodec([
  'idMatcher',
  'eventSet'
], {
  idMatcher: lib.Option.with(lib.getCodec(lib.AssetDefinitionId)),
  eventSet: lib.getCodec(AssetDefinitionEventSet)
}));
export const NftEventSet = lib.defineCodec(lib.bitmapCodec({
  Created: 1,
  Deleted: 2,
  MetadataInserted: 4,
  MetadataRemoved: 8,
  OwnerChanged: 16
}));
/**
 * Codec of the structure.
 */ export const NftEventFilter = lib.defineCodec(lib.structCodec([
  'idMatcher',
  'eventSet'
], {
  idMatcher: lib.Option.with(lib.getCodec(lib.NftId)),
  eventSet: lib.getCodec(NftEventSet)
}));
export const TriggerEventSet = lib.defineCodec(lib.bitmapCodec({
  Created: 1,
  Deleted: 2,
  Extended: 4,
  Shortened: 8,
  MetadataInserted: 16,
  MetadataRemoved: 32
}));
/**
 * Codec of the structure.
 */ export const TriggerEventFilter = lib.defineCodec(lib.structCodec([
  'idMatcher',
  'eventSet'
], {
  idMatcher: lib.Option.with(lib.getCodec(TriggerId)),
  eventSet: lib.getCodec(TriggerEventSet)
}));
export const RoleEventSet = lib.defineCodec(lib.bitmapCodec({
  Created: 1,
  Deleted: 2,
  PermissionAdded: 4,
  PermissionRemoved: 8
}));
/**
 * Codec of the structure.
 */ export const RoleEventFilter = lib.defineCodec(lib.structCodec([
  'idMatcher',
  'eventSet'
], {
  idMatcher: lib.Option.with(lib.getCodec(RoleId)),
  eventSet: lib.getCodec(RoleEventSet)
}));
export const ConfigurationEventSet = lib.defineCodec(lib.bitmapCodec({
  Changed: 1
}));
/**
 * Codec of the structure.
 */ export const ConfigurationEventFilter = lib.defineCodec(lib.structCodec([
  'eventSet'
], {
  eventSet: lib.getCodec(ConfigurationEventSet)
}));
export const ExecutorEventSet = lib.defineCodec(lib.bitmapCodec({
  Upgraded: 1
}));
/**
 * Codec of the structure.
 */ export const ExecutorEventFilter = lib.defineCodec(lib.structCodec([
  'eventSet'
], {
  eventSet: lib.getCodec(ExecutorEventSet)
}));
/**
 * Codec and constructors for enumeration {@link DataEventFilter}.
 */ export const DataEventFilter = {
  ...{
    Any: Object.freeze({
      kind: 'Any'
    }),
    Peer: (value)=>({
        kind: 'Peer',
        value
      }),
    Domain: (value)=>({
        kind: 'Domain',
        value
      }),
    Account: (value)=>({
        kind: 'Account',
        value
      }),
    Asset: (value)=>({
        kind: 'Asset',
        value
      }),
    AssetDefinition: (value)=>({
        kind: 'AssetDefinition',
        value
      }),
    Nft: (value)=>({
        kind: 'Nft',
        value
      }),
    Trigger: (value)=>({
        kind: 'Trigger',
        value
      }),
    Role: (value)=>({
        kind: 'Role',
        value
      }),
    Configuration: (value)=>({
        kind: 'Configuration',
        value
      }),
    Executor: (value)=>({
        kind: 'Executor',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Any: [
      0
    ],
    Peer: [
      1,
      lib.getCodec(PeerEventFilter)
    ],
    Domain: [
      2,
      lib.getCodec(DomainEventFilter)
    ],
    Account: [
      3,
      lib.getCodec(AccountEventFilter)
    ],
    Asset: [
      4,
      lib.getCodec(AssetEventFilter)
    ],
    AssetDefinition: [
      5,
      lib.getCodec(AssetDefinitionEventFilter)
    ],
    Nft: [
      6,
      lib.getCodec(NftEventFilter)
    ],
    Trigger: [
      7,
      lib.getCodec(TriggerEventFilter)
    ],
    Role: [
      8,
      lib.getCodec(RoleEventFilter)
    ],
    Configuration: [
      9,
      lib.getCodec(ConfigurationEventFilter)
    ],
    Executor: [
      10,
      lib.getCodec(ExecutorEventFilter)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const Schedule = lib.defineCodec(lib.structCodec([
  'start',
  'period'
], {
  start: lib.getCodec(lib.Timestamp),
  period: lib.Option.with(lib.getCodec(lib.Duration))
}));
/**
 * Codec and constructors for enumeration {@link ExecutionTime}.
 */ export const ExecutionTime = {
  ...{
    PreCommit: Object.freeze({
      kind: 'PreCommit'
    }),
    Schedule: (value)=>({
        kind: 'Schedule',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    PreCommit: [
      0
    ],
    Schedule: [
      1,
      lib.getCodec(Schedule)
    ]
  }).discriminated())
};
export const TimeEventFilter = ExecutionTime;
/**
 * Codec of the structure.
 */ export const ExecuteTriggerEventFilter = lib.defineCodec(lib.structCodec([
  'triggerId',
  'authority'
], {
  triggerId: lib.Option.with(lib.getCodec(TriggerId)),
  authority: lib.Option.with(lib.getCodec(lib.AccountId))
}));
/**
 * Codec and constructors for enumeration {@link TriggerCompletedOutcomeType}.
 */ export const TriggerCompletedOutcomeType = {
  ...{
    Success: Object.freeze({
      kind: 'Success'
    }),
    Failure: Object.freeze({
      kind: 'Failure'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Success: [
      0
    ],
    Failure: [
      1
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const TriggerCompletedEventFilter = lib.defineCodec(lib.structCodec([
  'triggerId',
  'outcomeType'
], {
  triggerId: lib.Option.with(lib.getCodec(TriggerId)),
  outcomeType: lib.Option.with(lib.getCodec(TriggerCompletedOutcomeType))
}));
/**
 * Codec and constructors for enumeration {@link EventFilterBox}.
 */ export const EventFilterBox = {
  ...{
    Pipeline: {
      Transaction: (value)=>({
          kind: 'Pipeline',
          value: PipelineEventFilterBox.Transaction(value)
        }),
      Block: (value)=>({
          kind: 'Pipeline',
          value: PipelineEventFilterBox.Block(value)
        })
    },
    Data: {
      Any: Object.freeze({
        kind: 'Data',
        value: DataEventFilter.Any
      }),
      Peer: (value)=>({
          kind: 'Data',
          value: DataEventFilter.Peer(value)
        }),
      Domain: (value)=>({
          kind: 'Data',
          value: DataEventFilter.Domain(value)
        }),
      Account: (value)=>({
          kind: 'Data',
          value: DataEventFilter.Account(value)
        }),
      Asset: (value)=>({
          kind: 'Data',
          value: DataEventFilter.Asset(value)
        }),
      AssetDefinition: (value)=>({
          kind: 'Data',
          value: DataEventFilter.AssetDefinition(value)
        }),
      Nft: (value)=>({
          kind: 'Data',
          value: DataEventFilter.Nft(value)
        }),
      Trigger: (value)=>({
          kind: 'Data',
          value: DataEventFilter.Trigger(value)
        }),
      Role: (value)=>({
          kind: 'Data',
          value: DataEventFilter.Role(value)
        }),
      Configuration: (value)=>({
          kind: 'Data',
          value: DataEventFilter.Configuration(value)
        }),
      Executor: (value)=>({
          kind: 'Data',
          value: DataEventFilter.Executor(value)
        })
    },
    Time: {
      PreCommit: Object.freeze({
        kind: 'Time',
        value: TimeEventFilter.PreCommit
      }),
      Schedule: (value)=>({
          kind: 'Time',
          value: TimeEventFilter.Schedule(value)
        })
    },
    ExecuteTrigger: (value)=>({
        kind: 'ExecuteTrigger',
        value
      }),
    TriggerCompleted: (value)=>({
        kind: 'TriggerCompleted',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Pipeline: [
      0,
      lib.getCodec(PipelineEventFilterBox)
    ],
    Data: [
      1,
      lib.getCodec(DataEventFilter)
    ],
    Time: [
      2,
      lib.getCodec(TimeEventFilter)
    ],
    ExecuteTrigger: [
      3,
      lib.getCodec(ExecuteTriggerEventFilter)
    ],
    TriggerCompleted: [
      4,
      lib.getCodec(TriggerCompletedEventFilter)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const Action = lib.defineCodec(lib.structCodec([
  'executable',
  'repeats',
  'authority',
  'filter',
  'metadata'
], {
  executable: lib.getCodec(Executable),
  repeats: lib.getCodec(Repeats),
  authority: lib.getCodec(lib.AccountId),
  filter: lib.getCodec(EventFilterBox),
  metadata: lib.getCodec(Metadata)
}));
/**
 * Codec for {@link ActionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const ActionPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link ActionProjectionPredicate}.
 */ export const ActionProjectionPredicate = {
  ...{
    Metadata: {
      Key: (value)=>({
          kind: 'Metadata',
          value: MetadataProjectionPredicate.Key(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(ActionPredicateAtom)
    ],
    Metadata: [
      1,
      lib.getCodec(MetadataProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link ActionProjectionSelector}.
 */ export const ActionProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Metadata: {
      Atom: Object.freeze({
        kind: 'Metadata',
        value: MetadataProjectionSelector.Atom
      }),
      Key: (value)=>({
          kind: 'Metadata',
          value: MetadataProjectionSelector.Key(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Metadata: [
      1,
      lib.getCodec(MetadataProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link Mintable}.
 */ export const Mintable = {
  ...{
    Infinitely: Object.freeze({
      kind: 'Infinitely'
    }),
    Once: Object.freeze({
      kind: 'Once'
    }),
    Not: Object.freeze({
      kind: 'Not'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Infinitely: [
      0
    ],
    Once: [
      1
    ],
    Not: [
      2
    ]
  }).discriminated())
};
export const IpfsPath = lib.String;
/**
 * Codec of the structure.
 */ export const AssetDefinition = lib.defineCodec(lib.structCodec([
  'id',
  'spec',
  'mintable',
  'logo',
  'metadata',
  'ownedBy',
  'totalQuantity'
], {
  id: lib.getCodec(lib.AssetDefinitionId),
  spec: lib.getCodec(NumericSpec),
  mintable: lib.getCodec(Mintable),
  logo: lib.Option.with(lib.getCodec(IpfsPath)),
  metadata: lib.getCodec(Metadata),
  ownedBy: lib.getCodec(lib.AccountId),
  totalQuantity: lib.getCodec(Numeric)
}));
/**
 * Codec of the structure.
 */ export const AssetDefinitionTotalQuantityChanged = lib.defineCodec(lib.structCodec([
  'assetDefinition',
  'totalAmount'
], {
  assetDefinition: lib.getCodec(lib.AssetDefinitionId),
  totalAmount: lib.getCodec(Numeric)
}));
/**
 * Codec of the structure.
 */ export const AssetDefinitionOwnerChanged = lib.defineCodec(lib.structCodec([
  'assetDefinition',
  'newOwner'
], {
  assetDefinition: lib.getCodec(lib.AssetDefinitionId),
  newOwner: lib.getCodec(lib.AccountId)
}));
/**
 * Codec and constructors for enumeration {@link AssetDefinitionEvent}.
 */ export const AssetDefinitionEvent = {
  ...{
    Created: (value)=>({
        kind: 'Created',
        value
      }),
    Deleted: (value)=>({
        kind: 'Deleted',
        value
      }),
    MetadataInserted: (value)=>({
        kind: 'MetadataInserted',
        value
      }),
    MetadataRemoved: (value)=>({
        kind: 'MetadataRemoved',
        value
      }),
    MintabilityChanged: (value)=>({
        kind: 'MintabilityChanged',
        value
      }),
    TotalQuantityChanged: (value)=>({
        kind: 'TotalQuantityChanged',
        value
      }),
    OwnerChanged: (value)=>({
        kind: 'OwnerChanged',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Created: [
      0,
      lib.getCodec(AssetDefinition)
    ],
    Deleted: [
      1,
      lib.getCodec(lib.AssetDefinitionId)
    ],
    MetadataInserted: [
      2,
      MetadataChanged.with(lib.getCodec(lib.AssetDefinitionId))
    ],
    MetadataRemoved: [
      3,
      MetadataChanged.with(lib.getCodec(lib.AssetDefinitionId))
    ],
    MintabilityChanged: [
      4,
      lib.getCodec(lib.AssetDefinitionId)
    ],
    TotalQuantityChanged: [
      5,
      lib.getCodec(AssetDefinitionTotalQuantityChanged)
    ],
    OwnerChanged: [
      6,
      lib.getCodec(AssetDefinitionOwnerChanged)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AssetDefinitionIdPredicateAtom}.
 */ export const AssetDefinitionIdPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(lib.AssetDefinitionId)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AssetDefinitionIdProjectionPredicate}.
 */ export const AssetDefinitionIdProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: AssetDefinitionIdPredicateAtom.Equals(value)
        })
    },
    Domain: {
      Atom: {
        Equals: (value)=>({
            kind: 'Domain',
            value: DomainIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Name: {
        Atom: {
          Equals: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.Equals(value)
            }),
          Contains: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.Contains(value)
            }),
          StartsWith: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.StartsWith(value)
            }),
          EndsWith: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.EndsWith(value)
            })
        }
      }
    },
    Name: {
      Atom: {
        Equals: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.Equals(value)
          }),
        Contains: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.Contains(value)
          }),
        StartsWith: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.StartsWith(value)
          }),
        EndsWith: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.EndsWith(value)
          })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(AssetDefinitionIdPredicateAtom)
    ],
    Domain: [
      1,
      lib.getCodec(DomainIdProjectionPredicate)
    ],
    Name: [
      2,
      lib.getCodec(NameProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AssetDefinitionIdProjectionSelector}.
 */ export const AssetDefinitionIdProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Domain: {
      Atom: Object.freeze({
        kind: 'Domain',
        value: DomainIdProjectionSelector.Atom
      }),
      Name: {
        Atom: Object.freeze({
          kind: 'Domain',
          value: DomainIdProjectionSelector.Name.Atom
        })
      }
    },
    Name: {
      Atom: Object.freeze({
        kind: 'Name',
        value: NameProjectionSelector.Atom
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Domain: [
      1,
      lib.getCodec(DomainIdProjectionSelector)
    ],
    Name: [
      2,
      lib.getCodec(NameProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec for {@link AssetDefinitionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const AssetDefinitionPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link AssetDefinitionProjectionPredicate}.
 */ export const AssetDefinitionProjectionPredicate = {
  ...{
    Id: {
      Atom: {
        Equals: (value)=>({
            kind: 'Id',
            value: AssetDefinitionIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Domain: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: AssetDefinitionIdProjectionPredicate.Domain.Atom.Equals(value)
            })
        },
        Name: {
          Atom: {
            Equals: (value)=>({
                kind: 'Id',
                value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.Equals(value)
              }),
            Contains: (value)=>({
                kind: 'Id',
                value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.Contains(value)
              }),
            StartsWith: (value)=>({
                kind: 'Id',
                value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.StartsWith(value)
              }),
            EndsWith: (value)=>({
                kind: 'Id',
                value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.EndsWith(value)
              })
          }
        }
      },
      Name: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: AssetDefinitionIdProjectionPredicate.Name.Atom.Equals(value)
            }),
          Contains: (value)=>({
              kind: 'Id',
              value: AssetDefinitionIdProjectionPredicate.Name.Atom.Contains(value)
            }),
          StartsWith: (value)=>({
              kind: 'Id',
              value: AssetDefinitionIdProjectionPredicate.Name.Atom.StartsWith(value)
            }),
          EndsWith: (value)=>({
              kind: 'Id',
              value: AssetDefinitionIdProjectionPredicate.Name.Atom.EndsWith(value)
            })
        }
      }
    },
    Metadata: {
      Key: (value)=>({
          kind: 'Metadata',
          value: MetadataProjectionPredicate.Key(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(AssetDefinitionPredicateAtom)
    ],
    Id: [
      1,
      lib.getCodec(AssetDefinitionIdProjectionPredicate)
    ],
    Metadata: [
      2,
      lib.getCodec(MetadataProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AssetDefinitionProjectionSelector}.
 */ export const AssetDefinitionProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Id: {
      Atom: Object.freeze({
        kind: 'Id',
        value: AssetDefinitionIdProjectionSelector.Atom
      }),
      Domain: {
        Atom: Object.freeze({
          kind: 'Id',
          value: AssetDefinitionIdProjectionSelector.Domain.Atom
        }),
        Name: {
          Atom: Object.freeze({
            kind: 'Id',
            value: AssetDefinitionIdProjectionSelector.Domain.Name.Atom
          })
        }
      },
      Name: {
        Atom: Object.freeze({
          kind: 'Id',
          value: AssetDefinitionIdProjectionSelector.Name.Atom
        })
      }
    },
    Metadata: {
      Atom: Object.freeze({
        kind: 'Metadata',
        value: MetadataProjectionSelector.Atom
      }),
      Key: (value)=>({
          kind: 'Metadata',
          value: MetadataProjectionSelector.Key(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Id: [
      1,
      lib.getCodec(AssetDefinitionIdProjectionSelector)
    ],
    Metadata: [
      2,
      lib.getCodec(MetadataProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AssetIdPredicateAtom}.
 */ export const AssetIdPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(lib.AssetId)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AssetIdProjectionPredicate}.
 */ export const AssetIdProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: AssetIdPredicateAtom.Equals(value)
        })
    },
    Account: {
      Atom: {
        Equals: (value)=>({
            kind: 'Account',
            value: AccountIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Domain: {
        Atom: {
          Equals: (value)=>({
              kind: 'Account',
              value: AccountIdProjectionPredicate.Domain.Atom.Equals(value)
            })
        },
        Name: {
          Atom: {
            Equals: (value)=>({
                kind: 'Account',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.Equals(value)
              }),
            Contains: (value)=>({
                kind: 'Account',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.Contains(value)
              }),
            StartsWith: (value)=>({
                kind: 'Account',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.StartsWith(value)
              }),
            EndsWith: (value)=>({
                kind: 'Account',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.EndsWith(value)
              })
          }
        }
      },
      Signatory: {
        Atom: {
          Equals: (value)=>({
              kind: 'Account',
              value: AccountIdProjectionPredicate.Signatory.Atom.Equals(value)
            })
        }
      }
    },
    Definition: {
      Atom: {
        Equals: (value)=>({
            kind: 'Definition',
            value: AssetDefinitionIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Domain: {
        Atom: {
          Equals: (value)=>({
              kind: 'Definition',
              value: AssetDefinitionIdProjectionPredicate.Domain.Atom.Equals(value)
            })
        },
        Name: {
          Atom: {
            Equals: (value)=>({
                kind: 'Definition',
                value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.Equals(value)
              }),
            Contains: (value)=>({
                kind: 'Definition',
                value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.Contains(value)
              }),
            StartsWith: (value)=>({
                kind: 'Definition',
                value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.StartsWith(value)
              }),
            EndsWith: (value)=>({
                kind: 'Definition',
                value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.EndsWith(value)
              })
          }
        }
      },
      Name: {
        Atom: {
          Equals: (value)=>({
              kind: 'Definition',
              value: AssetDefinitionIdProjectionPredicate.Name.Atom.Equals(value)
            }),
          Contains: (value)=>({
              kind: 'Definition',
              value: AssetDefinitionIdProjectionPredicate.Name.Atom.Contains(value)
            }),
          StartsWith: (value)=>({
              kind: 'Definition',
              value: AssetDefinitionIdProjectionPredicate.Name.Atom.StartsWith(value)
            }),
          EndsWith: (value)=>({
              kind: 'Definition',
              value: AssetDefinitionIdProjectionPredicate.Name.Atom.EndsWith(value)
            })
        }
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(AssetIdPredicateAtom)
    ],
    Account: [
      1,
      lib.getCodec(AccountIdProjectionPredicate)
    ],
    Definition: [
      2,
      lib.getCodec(AssetDefinitionIdProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AssetIdProjectionSelector}.
 */ export const AssetIdProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Account: {
      Atom: Object.freeze({
        kind: 'Account',
        value: AccountIdProjectionSelector.Atom
      }),
      Domain: {
        Atom: Object.freeze({
          kind: 'Account',
          value: AccountIdProjectionSelector.Domain.Atom
        }),
        Name: {
          Atom: Object.freeze({
            kind: 'Account',
            value: AccountIdProjectionSelector.Domain.Name.Atom
          })
        }
      },
      Signatory: {
        Atom: Object.freeze({
          kind: 'Account',
          value: AccountIdProjectionSelector.Signatory.Atom
        })
      }
    },
    Definition: {
      Atom: Object.freeze({
        kind: 'Definition',
        value: AssetDefinitionIdProjectionSelector.Atom
      }),
      Domain: {
        Atom: Object.freeze({
          kind: 'Definition',
          value: AssetDefinitionIdProjectionSelector.Domain.Atom
        }),
        Name: {
          Atom: Object.freeze({
            kind: 'Definition',
            value: AssetDefinitionIdProjectionSelector.Domain.Name.Atom
          })
        }
      },
      Name: {
        Atom: Object.freeze({
          kind: 'Definition',
          value: AssetDefinitionIdProjectionSelector.Name.Atom
        })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Account: [
      1,
      lib.getCodec(AccountIdProjectionSelector)
    ],
    Definition: [
      2,
      lib.getCodec(AssetDefinitionIdProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec for {@link AssetPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const AssetPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec for {@link NumericProjectionPredicate}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const NumericProjectionPredicate = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link AssetProjectionPredicate}.
 */ export const AssetProjectionPredicate = {
  ...{
    Id: {
      Atom: {
        Equals: (value)=>({
            kind: 'Id',
            value: AssetIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Account: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: AssetIdProjectionPredicate.Account.Atom.Equals(value)
            })
        },
        Domain: {
          Atom: {
            Equals: (value)=>({
                kind: 'Id',
                value: AssetIdProjectionPredicate.Account.Domain.Atom.Equals(value)
              })
          },
          Name: {
            Atom: {
              Equals: (value)=>({
                  kind: 'Id',
                  value: AssetIdProjectionPredicate.Account.Domain.Name.Atom.Equals(value)
                }),
              Contains: (value)=>({
                  kind: 'Id',
                  value: AssetIdProjectionPredicate.Account.Domain.Name.Atom.Contains(value)
                }),
              StartsWith: (value)=>({
                  kind: 'Id',
                  value: AssetIdProjectionPredicate.Account.Domain.Name.Atom.StartsWith(value)
                }),
              EndsWith: (value)=>({
                  kind: 'Id',
                  value: AssetIdProjectionPredicate.Account.Domain.Name.Atom.EndsWith(value)
                })
            }
          }
        },
        Signatory: {
          Atom: {
            Equals: (value)=>({
                kind: 'Id',
                value: AssetIdProjectionPredicate.Account.Signatory.Atom.Equals(value)
              })
          }
        }
      },
      Definition: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: AssetIdProjectionPredicate.Definition.Atom.Equals(value)
            })
        },
        Domain: {
          Atom: {
            Equals: (value)=>({
                kind: 'Id',
                value: AssetIdProjectionPredicate.Definition.Domain.Atom.Equals(value)
              })
          },
          Name: {
            Atom: {
              Equals: (value)=>({
                  kind: 'Id',
                  value: AssetIdProjectionPredicate.Definition.Domain.Name.Atom.Equals(value)
                }),
              Contains: (value)=>({
                  kind: 'Id',
                  value: AssetIdProjectionPredicate.Definition.Domain.Name.Atom.Contains(value)
                }),
              StartsWith: (value)=>({
                  kind: 'Id',
                  value: AssetIdProjectionPredicate.Definition.Domain.Name.Atom.StartsWith(value)
                }),
              EndsWith: (value)=>({
                  kind: 'Id',
                  value: AssetIdProjectionPredicate.Definition.Domain.Name.Atom.EndsWith(value)
                })
            }
          }
        },
        Name: {
          Atom: {
            Equals: (value)=>({
                kind: 'Id',
                value: AssetIdProjectionPredicate.Definition.Name.Atom.Equals(value)
              }),
            Contains: (value)=>({
                kind: 'Id',
                value: AssetIdProjectionPredicate.Definition.Name.Atom.Contains(value)
              }),
            StartsWith: (value)=>({
                kind: 'Id',
                value: AssetIdProjectionPredicate.Definition.Name.Atom.StartsWith(value)
              }),
            EndsWith: (value)=>({
                kind: 'Id',
                value: AssetIdProjectionPredicate.Definition.Name.Atom.EndsWith(value)
              })
          }
        }
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(AssetPredicateAtom)
    ],
    Id: [
      1,
      lib.getCodec(AssetIdProjectionPredicate)
    ],
    Value: [
      2,
      lib.getCodec(NumericProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link NumericProjectionSelector}.
 */ export const NumericProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link AssetProjectionSelector}.
 */ export const AssetProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Id: {
      Atom: Object.freeze({
        kind: 'Id',
        value: AssetIdProjectionSelector.Atom
      }),
      Account: {
        Atom: Object.freeze({
          kind: 'Id',
          value: AssetIdProjectionSelector.Account.Atom
        }),
        Domain: {
          Atom: Object.freeze({
            kind: 'Id',
            value: AssetIdProjectionSelector.Account.Domain.Atom
          }),
          Name: {
            Atom: Object.freeze({
              kind: 'Id',
              value: AssetIdProjectionSelector.Account.Domain.Name.Atom
            })
          }
        },
        Signatory: {
          Atom: Object.freeze({
            kind: 'Id',
            value: AssetIdProjectionSelector.Account.Signatory.Atom
          })
        }
      },
      Definition: {
        Atom: Object.freeze({
          kind: 'Id',
          value: AssetIdProjectionSelector.Definition.Atom
        }),
        Domain: {
          Atom: Object.freeze({
            kind: 'Id',
            value: AssetIdProjectionSelector.Definition.Domain.Atom
          }),
          Name: {
            Atom: Object.freeze({
              kind: 'Id',
              value: AssetIdProjectionSelector.Definition.Domain.Name.Atom
            })
          }
        },
        Name: {
          Atom: Object.freeze({
            kind: 'Id',
            value: AssetIdProjectionSelector.Definition.Name.Atom
          })
        }
      }
    },
    Value: {
      Atom: Object.freeze({
        kind: 'Value',
        value: NumericProjectionSelector.Atom
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Id: [
      1,
      lib.getCodec(AssetIdProjectionSelector)
    ],
    Value: [
      2,
      lib.getCodec(NumericProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const BlockHeader = lib.defineCodec(lib.structCodec([
  'height',
  'prevBlockHash',
  'transactionsHash',
  'creationTime',
  'viewChangeIndex'
], {
  height: lib.NonZero.with(lib.getCodec(lib.U64)),
  prevBlockHash: lib.Option.with(lib.getCodec(lib.Hash)),
  transactionsHash: lib.Option.with(lib.getCodec(lib.Hash)),
  creationTime: lib.getCodec(lib.Timestamp),
  viewChangeIndex: lib.getCodec(lib.U32)
}));
/**
 * Codec of the structure.
 */ export const BlockEvent = lib.defineCodec(lib.structCodec([
  'header',
  'status'
], {
  header: lib.getCodec(BlockHeader),
  status: lib.getCodec(BlockStatus)
}));
/**
 * Codec and constructors for enumeration {@link BlockHeaderHashPredicateAtom}.
 */ export const BlockHeaderHashPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(lib.Hash)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link BlockHeaderHashProjectionPredicate}.
 */ export const BlockHeaderHashProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: BlockHeaderHashPredicateAtom.Equals(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(BlockHeaderHashPredicateAtom)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link BlockHeaderHashProjectionSelector}.
 */ export const BlockHeaderHashProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ]
  }).discriminated())
};
/**
 * Codec for {@link BlockHeaderPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const BlockHeaderPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link BlockHeaderProjectionPredicate}.
 */ export const BlockHeaderProjectionPredicate = {
  ...{
    Hash: {
      Atom: {
        Equals: (value)=>({
            kind: 'Hash',
            value: BlockHeaderHashProjectionPredicate.Atom.Equals(value)
          })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(BlockHeaderPredicateAtom)
    ],
    Hash: [
      1,
      lib.getCodec(BlockHeaderHashProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link BlockHeaderProjectionSelector}.
 */ export const BlockHeaderProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Hash: {
      Atom: Object.freeze({
        kind: 'Hash',
        value: BlockHeaderHashProjectionSelector.Atom
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Hash: [
      1,
      lib.getCodec(BlockHeaderHashProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const BlockSignature = lib.defineCodec(lib.structCodec([
  'peerTopologyIndex',
  'signature'
], {
  peerTopologyIndex: lib.getCodec(lib.U64),
  signature: lib.getCodec(lib.Signature)
}));
export const ChainId = lib.String;
/**
 * Codec of the structure.
 */ export const TransactionPayload = lib.defineCodec(lib.structCodec([
  'chain',
  'authority',
  'creationTime',
  'instructions',
  'timeToLive',
  'nonce',
  'metadata'
], {
  chain: lib.getCodec(ChainId),
  authority: lib.getCodec(lib.AccountId),
  creationTime: lib.getCodec(lib.Timestamp),
  instructions: lib.getCodec(Executable),
  timeToLive: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.Duration))),
  nonce: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U32))),
  metadata: lib.getCodec(Metadata)
}));
/**
 * Codec of the structure.
 */ export const SignedTransactionV1 = lib.defineCodec(lib.structCodec([
  'signature',
  'payload'
], {
  signature: lib.getCodec(lib.Signature),
  payload: lib.getCodec(TransactionPayload)
}));
/**
 * Codec and constructors for enumeration {@link SignedTransaction}.
 */ export const SignedTransaction = {
  ...{
    V1: (value)=>({
        kind: 'V1',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    V1: [
      1,
      lib.getCodec(SignedTransactionV1)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const BlockPayload = lib.defineCodec(lib.structCodec([
  'header',
  'transactions'
], {
  header: lib.getCodec(BlockHeader),
  transactions: lib.Vec.with(lib.getCodec(SignedTransaction))
}));
/**
 * Codec of the structure.
 */ export const TransactionErrorWithIndex = lib.defineCodec(lib.structCodec([
  'index',
  'error'
], {
  index: lib.getCodec(lib.U64),
  error: lib.getCodec(TransactionRejectionReason)
}));
export const TransactionErrors = lib.defineCodec(lib.BTreeSet.withCmp(lib.getCodec(TransactionErrorWithIndex), (a, b)=>lib.ordCompare(a.index, b.index)));
/**
 * Codec of the structure.
 */ export const SignedBlockV1 = lib.defineCodec(lib.structCodec([
  'signatures',
  'payload',
  'errors'
], {
  signatures: lib.Vec.with(lib.getCodec(BlockSignature)),
  payload: lib.getCodec(BlockPayload),
  errors: lib.getCodec(TransactionErrors)
}));
/**
 * Codec and constructors for enumeration {@link SignedBlock}.
 */ export const SignedBlock = {
  ...{
    V1: (value)=>({
        kind: 'V1',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    V1: [
      1,
      lib.getCodec(SignedBlockV1)
    ]
  }).discriminated())
};
export const BlockMessage = SignedBlock;
/**
 * Codec and constructors for enumeration {@link BlockParameter}.
 */ export const BlockParameter = {
  ...{
    MaxTransactions: (value)=>({
        kind: 'MaxTransactions',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    MaxTransactions: [
      0,
      lib.NonZero.with(lib.getCodec(lib.U64))
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const BlockParameters = lib.defineCodec(lib.structCodec([
  'maxTransactions'
], {
  maxTransactions: lib.NonZero.with(lib.getCodec(lib.U64))
}));
/**
 * Codec of the structure.
 */ export const BlockSubscriptionRequest = lib.defineCodec(lib.structCodec([
  'fromBlockHeight'
], {
  fromBlockHeight: lib.NonZero.with(lib.getCodec(lib.U64))
}));
/**
 * Codec constructor for the structure with generic parameters.
 */ export const Burn = {
  with: (t0, t1)=>lib.structCodec([
      'object',
      'destination'
    ], {
      object: t0,
      destination: t1
    })
};
/**
 * Codec and constructors for enumeration {@link BurnBox}.
 */ export const BurnBox = {
  ...{
    Asset: (value)=>({
        kind: 'Asset',
        value
      }),
    TriggerRepetitions: (value)=>({
        kind: 'TriggerRepetitions',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Asset: [
      0,
      Burn.with(lib.getCodec(Numeric), lib.getCodec(lib.AssetId))
    ],
    TriggerRepetitions: [
      1,
      Burn.with(lib.getCodec(lib.U32), lib.getCodec(TriggerId))
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const CanBurnAsset = lib.defineCodec(lib.structCodec([
  'asset'
], {
  asset: lib.getCodec(lib.AssetId)
}));
/**
 * Codec of the structure.
 */ export const CanBurnAssetWithDefinition = lib.defineCodec(lib.structCodec([
  'assetDefinition'
], {
  assetDefinition: lib.getCodec(lib.AssetDefinitionId)
}));
/**
 * Codec of the structure.
 */ export const CanExecuteTrigger = lib.defineCodec(lib.structCodec([
  'trigger'
], {
  trigger: lib.getCodec(TriggerId)
}));
/**
 * Codec of the structure.
 */ export const CanMintAsset = lib.defineCodec(lib.structCodec([
  'asset'
], {
  asset: lib.getCodec(lib.AssetId)
}));
/**
 * Codec of the structure.
 */ export const CanMintAssetWithDefinition = lib.defineCodec(lib.structCodec([
  'assetDefinition'
], {
  assetDefinition: lib.getCodec(lib.AssetDefinitionId)
}));
/**
 * Codec of the structure.
 */ export const CanModifyAccountMetadata = lib.defineCodec(lib.structCodec([
  'account'
], {
  account: lib.getCodec(lib.AccountId)
}));
/**
 * Codec of the structure.
 */ export const CanModifyAssetDefinitionMetadata = lib.defineCodec(lib.structCodec([
  'assetDefinition'
], {
  assetDefinition: lib.getCodec(lib.AssetDefinitionId)
}));
/**
 * Codec of the structure.
 */ export const CanModifyDomainMetadata = lib.defineCodec(lib.structCodec([
  'domain'
], {
  domain: lib.getCodec(lib.DomainId)
}));
/**
 * Codec of the structure.
 */ export const CanModifyNftMetadata = lib.defineCodec(lib.structCodec([
  'nft'
], {
  nft: lib.getCodec(lib.NftId)
}));
/**
 * Codec of the structure.
 */ export const CanModifyTrigger = lib.defineCodec(lib.structCodec([
  'trigger'
], {
  trigger: lib.getCodec(TriggerId)
}));
/**
 * Codec of the structure.
 */ export const CanModifyTriggerMetadata = lib.defineCodec(lib.structCodec([
  'trigger'
], {
  trigger: lib.getCodec(TriggerId)
}));
/**
 * Codec of the structure.
 */ export const CanRegisterAccount = lib.defineCodec(lib.structCodec([
  'domain'
], {
  domain: lib.getCodec(lib.DomainId)
}));
/**
 * Codec of the structure.
 */ export const CanRegisterAssetDefinition = lib.defineCodec(lib.structCodec([
  'domain'
], {
  domain: lib.getCodec(lib.DomainId)
}));
/**
 * Codec of the structure.
 */ export const CanRegisterNft = lib.defineCodec(lib.structCodec([
  'domain'
], {
  domain: lib.getCodec(lib.DomainId)
}));
/**
 * Codec of the structure.
 */ export const CanRegisterTrigger = lib.defineCodec(lib.structCodec([
  'authority'
], {
  authority: lib.getCodec(lib.AccountId)
}));
/**
 * Codec of the structure.
 */ export const CanTransferAsset = lib.defineCodec(lib.structCodec([
  'asset'
], {
  asset: lib.getCodec(lib.AssetId)
}));
/**
 * Codec of the structure.
 */ export const CanTransferAssetWithDefinition = lib.defineCodec(lib.structCodec([
  'assetDefinition'
], {
  assetDefinition: lib.getCodec(lib.AssetDefinitionId)
}));
/**
 * Codec of the structure.
 */ export const CanTransferNft = lib.defineCodec(lib.structCodec([
  'nft'
], {
  nft: lib.getCodec(lib.NftId)
}));
/**
 * Codec of the structure.
 */ export const CanUnregisterAccount = lib.defineCodec(lib.structCodec([
  'account'
], {
  account: lib.getCodec(lib.AccountId)
}));
/**
 * Codec of the structure.
 */ export const CanUnregisterAssetDefinition = lib.defineCodec(lib.structCodec([
  'assetDefinition'
], {
  assetDefinition: lib.getCodec(lib.AssetDefinitionId)
}));
/**
 * Codec of the structure.
 */ export const CanUnregisterDomain = lib.defineCodec(lib.structCodec([
  'domain'
], {
  domain: lib.getCodec(lib.DomainId)
}));
/**
 * Codec of the structure.
 */ export const CanUnregisterNft = lib.defineCodec(lib.structCodec([
  'nft'
], {
  nft: lib.getCodec(lib.NftId)
}));
/**
 * Codec of the structure.
 */ export const CanUnregisterTrigger = lib.defineCodec(lib.structCodec([
  'trigger'
], {
  trigger: lib.getCodec(TriggerId)
}));
/**
 * Codec of the structure.
 */ export const CommittedTransaction = lib.defineCodec(lib.structCodec([
  'blockHash',
  'value',
  'error'
], {
  blockHash: lib.getCodec(lib.Hash),
  value: lib.getCodec(SignedTransaction),
  error: lib.Option.with(lib.getCodec(TransactionRejectionReason))
}));
/**
 * Codec for {@link CommittedTransactionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const CommittedTransactionPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec for {@link SignedTransactionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const SignedTransactionPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link TransactionHashPredicateAtom}.
 */ export const TransactionHashPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(lib.Hash)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TransactionHashProjectionPredicate}.
 */ export const TransactionHashProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: TransactionHashPredicateAtom.Equals(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(TransactionHashPredicateAtom)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link SignedTransactionProjectionPredicate}.
 */ export const SignedTransactionProjectionPredicate = {
  ...{
    Hash: {
      Atom: {
        Equals: (value)=>({
            kind: 'Hash',
            value: TransactionHashProjectionPredicate.Atom.Equals(value)
          })
      }
    },
    Authority: {
      Atom: {
        Equals: (value)=>({
            kind: 'Authority',
            value: AccountIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Domain: {
        Atom: {
          Equals: (value)=>({
              kind: 'Authority',
              value: AccountIdProjectionPredicate.Domain.Atom.Equals(value)
            })
        },
        Name: {
          Atom: {
            Equals: (value)=>({
                kind: 'Authority',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.Equals(value)
              }),
            Contains: (value)=>({
                kind: 'Authority',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.Contains(value)
              }),
            StartsWith: (value)=>({
                kind: 'Authority',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.StartsWith(value)
              }),
            EndsWith: (value)=>({
                kind: 'Authority',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.EndsWith(value)
              })
          }
        }
      },
      Signatory: {
        Atom: {
          Equals: (value)=>({
              kind: 'Authority',
              value: AccountIdProjectionPredicate.Signatory.Atom.Equals(value)
            })
        }
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(SignedTransactionPredicateAtom)
    ],
    Hash: [
      1,
      lib.getCodec(TransactionHashProjectionPredicate)
    ],
    Authority: [
      2,
      lib.getCodec(AccountIdProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TransactionErrorPredicateAtom}.
 */ export const TransactionErrorPredicateAtom = {
  ...{
    IsSome: Object.freeze({
      kind: 'IsSome'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    IsSome: [
      0
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TransactionErrorProjectionPredicate}.
 */ export const TransactionErrorProjectionPredicate = {
  ...{
    Atom: {
      IsSome: Object.freeze({
        kind: 'Atom',
        value: TransactionErrorPredicateAtom.IsSome
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(TransactionErrorPredicateAtom)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link CommittedTransactionProjectionPredicate}.
 */ export const CommittedTransactionProjectionPredicate = {
  ...{
    BlockHash: {
      Atom: {
        Equals: (value)=>({
            kind: 'BlockHash',
            value: BlockHeaderHashProjectionPredicate.Atom.Equals(value)
          })
      }
    },
    Value: {
      Hash: {
        Atom: {
          Equals: (value)=>({
              kind: 'Value',
              value: SignedTransactionProjectionPredicate.Hash.Atom.Equals(value)
            })
        }
      },
      Authority: {
        Atom: {
          Equals: (value)=>({
              kind: 'Value',
              value: SignedTransactionProjectionPredicate.Authority.Atom.Equals(value)
            })
        },
        Domain: {
          Atom: {
            Equals: (value)=>({
                kind: 'Value',
                value: SignedTransactionProjectionPredicate.Authority.Domain.Atom.Equals(value)
              })
          },
          Name: {
            Atom: {
              Equals: (value)=>({
                  kind: 'Value',
                  value: SignedTransactionProjectionPredicate.Authority.Domain.Name.Atom.Equals(value)
                }),
              Contains: (value)=>({
                  kind: 'Value',
                  value: SignedTransactionProjectionPredicate.Authority.Domain.Name.Atom.Contains(value)
                }),
              StartsWith: (value)=>({
                  kind: 'Value',
                  value: SignedTransactionProjectionPredicate.Authority.Domain.Name.Atom.StartsWith(value)
                }),
              EndsWith: (value)=>({
                  kind: 'Value',
                  value: SignedTransactionProjectionPredicate.Authority.Domain.Name.Atom.EndsWith(value)
                })
            }
          }
        },
        Signatory: {
          Atom: {
            Equals: (value)=>({
                kind: 'Value',
                value: SignedTransactionProjectionPredicate.Authority.Signatory.Atom.Equals(value)
              })
          }
        }
      }
    },
    Error: {
      Atom: {
        IsSome: Object.freeze({
          kind: 'Error',
          value: TransactionErrorProjectionPredicate.Atom.IsSome
        })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(CommittedTransactionPredicateAtom)
    ],
    BlockHash: [
      1,
      lib.getCodec(BlockHeaderHashProjectionPredicate)
    ],
    Value: [
      2,
      lib.getCodec(SignedTransactionProjectionPredicate)
    ],
    Error: [
      3,
      lib.getCodec(TransactionErrorProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TransactionHashProjectionSelector}.
 */ export const TransactionHashProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link SignedTransactionProjectionSelector}.
 */ export const SignedTransactionProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Hash: {
      Atom: Object.freeze({
        kind: 'Hash',
        value: TransactionHashProjectionSelector.Atom
      })
    },
    Authority: {
      Atom: Object.freeze({
        kind: 'Authority',
        value: AccountIdProjectionSelector.Atom
      }),
      Domain: {
        Atom: Object.freeze({
          kind: 'Authority',
          value: AccountIdProjectionSelector.Domain.Atom
        }),
        Name: {
          Atom: Object.freeze({
            kind: 'Authority',
            value: AccountIdProjectionSelector.Domain.Name.Atom
          })
        }
      },
      Signatory: {
        Atom: Object.freeze({
          kind: 'Authority',
          value: AccountIdProjectionSelector.Signatory.Atom
        })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Hash: [
      1,
      lib.getCodec(TransactionHashProjectionSelector)
    ],
    Authority: [
      2,
      lib.getCodec(AccountIdProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TransactionErrorProjectionSelector}.
 */ export const TransactionErrorProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link CommittedTransactionProjectionSelector}.
 */ export const CommittedTransactionProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    BlockHash: {
      Atom: Object.freeze({
        kind: 'BlockHash',
        value: BlockHeaderHashProjectionSelector.Atom
      })
    },
    Value: {
      Atom: Object.freeze({
        kind: 'Value',
        value: SignedTransactionProjectionSelector.Atom
      }),
      Hash: {
        Atom: Object.freeze({
          kind: 'Value',
          value: SignedTransactionProjectionSelector.Hash.Atom
        })
      },
      Authority: {
        Atom: Object.freeze({
          kind: 'Value',
          value: SignedTransactionProjectionSelector.Authority.Atom
        }),
        Domain: {
          Atom: Object.freeze({
            kind: 'Value',
            value: SignedTransactionProjectionSelector.Authority.Domain.Atom
          }),
          Name: {
            Atom: Object.freeze({
              kind: 'Value',
              value: SignedTransactionProjectionSelector.Authority.Domain.Name.Atom
            })
          }
        },
        Signatory: {
          Atom: Object.freeze({
            kind: 'Value',
            value: SignedTransactionProjectionSelector.Authority.Signatory.Atom
          })
        }
      }
    },
    Error: {
      Atom: Object.freeze({
        kind: 'Error',
        value: TransactionErrorProjectionSelector.Atom
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    BlockHash: [
      1,
      lib.getCodec(BlockHeaderHashProjectionSelector)
    ],
    Value: [
      2,
      lib.getCodec(SignedTransactionProjectionSelector)
    ],
    Error: [
      3,
      lib.getCodec(TransactionErrorProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec for {@link DomainPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const DomainPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link DomainProjectionPredicate}.
 */ export const DomainProjectionPredicate = {
  ...{
    Id: {
      Atom: {
        Equals: (value)=>({
            kind: 'Id',
            value: DomainIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Name: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: DomainIdProjectionPredicate.Name.Atom.Equals(value)
            }),
          Contains: (value)=>({
              kind: 'Id',
              value: DomainIdProjectionPredicate.Name.Atom.Contains(value)
            }),
          StartsWith: (value)=>({
              kind: 'Id',
              value: DomainIdProjectionPredicate.Name.Atom.StartsWith(value)
            }),
          EndsWith: (value)=>({
              kind: 'Id',
              value: DomainIdProjectionPredicate.Name.Atom.EndsWith(value)
            })
        }
      }
    },
    Metadata: {
      Key: (value)=>({
          kind: 'Metadata',
          value: MetadataProjectionPredicate.Key(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(DomainPredicateAtom)
    ],
    Id: [
      1,
      lib.getCodec(DomainIdProjectionPredicate)
    ],
    Metadata: [
      2,
      lib.getCodec(MetadataProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec for {@link NftPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const NftPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link NftIdPredicateAtom}.
 */ export const NftIdPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(lib.NftId)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link NftIdProjectionPredicate}.
 */ export const NftIdProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: NftIdPredicateAtom.Equals(value)
        })
    },
    Domain: {
      Atom: {
        Equals: (value)=>({
            kind: 'Domain',
            value: DomainIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Name: {
        Atom: {
          Equals: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.Equals(value)
            }),
          Contains: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.Contains(value)
            }),
          StartsWith: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.StartsWith(value)
            }),
          EndsWith: (value)=>({
              kind: 'Domain',
              value: DomainIdProjectionPredicate.Name.Atom.EndsWith(value)
            })
        }
      }
    },
    Name: {
      Atom: {
        Equals: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.Equals(value)
          }),
        Contains: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.Contains(value)
          }),
        StartsWith: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.StartsWith(value)
          }),
        EndsWith: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.EndsWith(value)
          })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(NftIdPredicateAtom)
    ],
    Domain: [
      1,
      lib.getCodec(DomainIdProjectionPredicate)
    ],
    Name: [
      2,
      lib.getCodec(NameProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link NftProjectionPredicate}.
 */ export const NftProjectionPredicate = {
  ...{
    Id: {
      Atom: {
        Equals: (value)=>({
            kind: 'Id',
            value: NftIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Domain: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: NftIdProjectionPredicate.Domain.Atom.Equals(value)
            })
        },
        Name: {
          Atom: {
            Equals: (value)=>({
                kind: 'Id',
                value: NftIdProjectionPredicate.Domain.Name.Atom.Equals(value)
              }),
            Contains: (value)=>({
                kind: 'Id',
                value: NftIdProjectionPredicate.Domain.Name.Atom.Contains(value)
              }),
            StartsWith: (value)=>({
                kind: 'Id',
                value: NftIdProjectionPredicate.Domain.Name.Atom.StartsWith(value)
              }),
            EndsWith: (value)=>({
                kind: 'Id',
                value: NftIdProjectionPredicate.Domain.Name.Atom.EndsWith(value)
              })
          }
        }
      },
      Name: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: NftIdProjectionPredicate.Name.Atom.Equals(value)
            }),
          Contains: (value)=>({
              kind: 'Id',
              value: NftIdProjectionPredicate.Name.Atom.Contains(value)
            }),
          StartsWith: (value)=>({
              kind: 'Id',
              value: NftIdProjectionPredicate.Name.Atom.StartsWith(value)
            }),
          EndsWith: (value)=>({
              kind: 'Id',
              value: NftIdProjectionPredicate.Name.Atom.EndsWith(value)
            })
        }
      }
    },
    Metadata: {
      Key: (value)=>({
          kind: 'Metadata',
          value: MetadataProjectionPredicate.Key(value)
        })
    },
    AccountId: {
      Atom: {
        Equals: (value)=>({
            kind: 'AccountId',
            value: AccountIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Domain: {
        Atom: {
          Equals: (value)=>({
              kind: 'AccountId',
              value: AccountIdProjectionPredicate.Domain.Atom.Equals(value)
            })
        },
        Name: {
          Atom: {
            Equals: (value)=>({
                kind: 'AccountId',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.Equals(value)
              }),
            Contains: (value)=>({
                kind: 'AccountId',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.Contains(value)
              }),
            StartsWith: (value)=>({
                kind: 'AccountId',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.StartsWith(value)
              }),
            EndsWith: (value)=>({
                kind: 'AccountId',
                value: AccountIdProjectionPredicate.Domain.Name.Atom.EndsWith(value)
              })
          }
        }
      },
      Signatory: {
        Atom: {
          Equals: (value)=>({
              kind: 'AccountId',
              value: AccountIdProjectionPredicate.Signatory.Atom.Equals(value)
            })
        }
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(NftPredicateAtom)
    ],
    Id: [
      1,
      lib.getCodec(NftIdProjectionPredicate)
    ],
    Metadata: [
      2,
      lib.getCodec(MetadataProjectionPredicate)
    ],
    AccountId: [
      3,
      lib.getCodec(AccountIdProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec for {@link PeerIdPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const PeerIdPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link PeerIdProjectionPredicate}.
 */ export const PeerIdProjectionPredicate = {
  ...{
    PublicKey: {
      Atom: {
        Equals: (value)=>({
            kind: 'PublicKey',
            value: PublicKeyProjectionPredicate.Atom.Equals(value)
          })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(PeerIdPredicateAtom)
    ],
    PublicKey: [
      1,
      lib.getCodec(PublicKeyProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec for {@link PermissionProjectionPredicate}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const PermissionProjectionPredicate = lib.defineCodec(lib.neverCodec);
/**
 * Codec for {@link RolePredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const RolePredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link RoleIdPredicateAtom}.
 */ export const RoleIdPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(RoleId)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link RoleIdProjectionPredicate}.
 */ export const RoleIdProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: RoleIdPredicateAtom.Equals(value)
        })
    },
    Name: {
      Atom: {
        Equals: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.Equals(value)
          }),
        Contains: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.Contains(value)
          }),
        StartsWith: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.StartsWith(value)
          }),
        EndsWith: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.EndsWith(value)
          })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(RoleIdPredicateAtom)
    ],
    Name: [
      1,
      lib.getCodec(NameProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link RoleProjectionPredicate}.
 */ export const RoleProjectionPredicate = {
  ...{
    Id: {
      Atom: {
        Equals: (value)=>({
            kind: 'Id',
            value: RoleIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Name: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: RoleIdProjectionPredicate.Name.Atom.Equals(value)
            }),
          Contains: (value)=>({
              kind: 'Id',
              value: RoleIdProjectionPredicate.Name.Atom.Contains(value)
            }),
          StartsWith: (value)=>({
              kind: 'Id',
              value: RoleIdProjectionPredicate.Name.Atom.StartsWith(value)
            }),
          EndsWith: (value)=>({
              kind: 'Id',
              value: RoleIdProjectionPredicate.Name.Atom.EndsWith(value)
            })
        }
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(RolePredicateAtom)
    ],
    Id: [
      1,
      lib.getCodec(RoleIdProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link SignedBlockPredicateAtom}.
 */ export const SignedBlockPredicateAtom = {
  ...{
    IsEmpty: Object.freeze({
      kind: 'IsEmpty'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    IsEmpty: [
      0
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link SignedBlockProjectionPredicate}.
 */ export const SignedBlockProjectionPredicate = {
  ...{
    Atom: {
      IsEmpty: Object.freeze({
        kind: 'Atom',
        value: SignedBlockPredicateAtom.IsEmpty
      })
    },
    Header: {
      Hash: {
        Atom: {
          Equals: (value)=>({
              kind: 'Header',
              value: BlockHeaderProjectionPredicate.Hash.Atom.Equals(value)
            })
        }
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(SignedBlockPredicateAtom)
    ],
    Header: [
      1,
      lib.getCodec(BlockHeaderProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec for {@link TriggerPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const TriggerPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link TriggerIdPredicateAtom}.
 */ export const TriggerIdPredicateAtom = {
  ...{
    Equals: (value)=>({
        kind: 'Equals',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Equals: [
      0,
      lib.getCodec(TriggerId)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TriggerIdProjectionPredicate}.
 */ export const TriggerIdProjectionPredicate = {
  ...{
    Atom: {
      Equals: (value)=>({
          kind: 'Atom',
          value: TriggerIdPredicateAtom.Equals(value)
        })
    },
    Name: {
      Atom: {
        Equals: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.Equals(value)
          }),
        Contains: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.Contains(value)
          }),
        StartsWith: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.StartsWith(value)
          }),
        EndsWith: (value)=>({
            kind: 'Name',
            value: NameProjectionPredicate.Atom.EndsWith(value)
          })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(TriggerIdPredicateAtom)
    ],
    Name: [
      1,
      lib.getCodec(NameProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TriggerProjectionPredicate}.
 */ export const TriggerProjectionPredicate = {
  ...{
    Id: {
      Atom: {
        Equals: (value)=>({
            kind: 'Id',
            value: TriggerIdProjectionPredicate.Atom.Equals(value)
          })
      },
      Name: {
        Atom: {
          Equals: (value)=>({
              kind: 'Id',
              value: TriggerIdProjectionPredicate.Name.Atom.Equals(value)
            }),
          Contains: (value)=>({
              kind: 'Id',
              value: TriggerIdProjectionPredicate.Name.Atom.Contains(value)
            }),
          StartsWith: (value)=>({
              kind: 'Id',
              value: TriggerIdProjectionPredicate.Name.Atom.StartsWith(value)
            }),
          EndsWith: (value)=>({
              kind: 'Id',
              value: TriggerIdProjectionPredicate.Name.Atom.EndsWith(value)
            })
        }
      }
    },
    Action: {
      Metadata: {
        Key: (value)=>({
            kind: 'Action',
            value: ActionProjectionPredicate.Metadata.Key(value)
          })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0,
      lib.getCodec(TriggerPredicateAtom)
    ],
    Id: [
      1,
      lib.getCodec(TriggerIdProjectionPredicate)
    ],
    Action: [
      2,
      lib.getCodec(ActionProjectionPredicate)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link SumeragiParameter}.
 */ export const SumeragiParameter = {
  ...{
    BlockTime: (value)=>({
        kind: 'BlockTime',
        value
      }),
    CommitTime: (value)=>({
        kind: 'CommitTime',
        value
      }),
    MaxClockDrift: (value)=>({
        kind: 'MaxClockDrift',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    BlockTime: [
      0,
      lib.getCodec(lib.Duration)
    ],
    CommitTime: [
      1,
      lib.getCodec(lib.Duration)
    ],
    MaxClockDrift: [
      2,
      lib.getCodec(lib.Duration)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TransactionParameter}.
 */ export const TransactionParameter = {
  ...{
    MaxInstructions: (value)=>({
        kind: 'MaxInstructions',
        value
      }),
    SmartContractSize: (value)=>({
        kind: 'SmartContractSize',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    MaxInstructions: [
      0,
      lib.NonZero.with(lib.getCodec(lib.U64))
    ],
    SmartContractSize: [
      1,
      lib.NonZero.with(lib.getCodec(lib.U64))
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link SmartContractParameter}.
 */ export const SmartContractParameter = {
  ...{
    Fuel: (value)=>({
        kind: 'Fuel',
        value
      }),
    Memory: (value)=>({
        kind: 'Memory',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Fuel: [
      0,
      lib.NonZero.with(lib.getCodec(lib.U64))
    ],
    Memory: [
      1,
      lib.NonZero.with(lib.getCodec(lib.U64))
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const CustomParameter = lib.defineCodec(lib.structCodec([
  'id',
  'payload'
], {
  id: lib.getCodec(CustomParameterId),
  payload: lib.getCodec(lib.Json)
}));
/**
 * Codec and constructors for enumeration {@link Parameter}.
 */ export const Parameter = {
  ...{
    Sumeragi: {
      BlockTime: (value)=>({
          kind: 'Sumeragi',
          value: SumeragiParameter.BlockTime(value)
        }),
      CommitTime: (value)=>({
          kind: 'Sumeragi',
          value: SumeragiParameter.CommitTime(value)
        }),
      MaxClockDrift: (value)=>({
          kind: 'Sumeragi',
          value: SumeragiParameter.MaxClockDrift(value)
        })
    },
    Block: {
      MaxTransactions: (value)=>({
          kind: 'Block',
          value: BlockParameter.MaxTransactions(value)
        })
    },
    Transaction: {
      MaxInstructions: (value)=>({
          kind: 'Transaction',
          value: TransactionParameter.MaxInstructions(value)
        }),
      SmartContractSize: (value)=>({
          kind: 'Transaction',
          value: TransactionParameter.SmartContractSize(value)
        })
    },
    SmartContract: {
      Fuel: (value)=>({
          kind: 'SmartContract',
          value: SmartContractParameter.Fuel(value)
        }),
      Memory: (value)=>({
          kind: 'SmartContract',
          value: SmartContractParameter.Memory(value)
        })
    },
    Executor: {
      Fuel: (value)=>({
          kind: 'Executor',
          value: SmartContractParameter.Fuel(value)
        }),
      Memory: (value)=>({
          kind: 'Executor',
          value: SmartContractParameter.Memory(value)
        })
    },
    Custom: (value)=>({
        kind: 'Custom',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Sumeragi: [
      0,
      lib.getCodec(SumeragiParameter)
    ],
    Block: [
      1,
      lib.getCodec(BlockParameter)
    ],
    Transaction: [
      2,
      lib.getCodec(TransactionParameter)
    ],
    SmartContract: [
      3,
      lib.getCodec(SmartContractParameter)
    ],
    Executor: [
      4,
      lib.getCodec(SmartContractParameter)
    ],
    Custom: [
      5,
      lib.getCodec(CustomParameter)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const ParameterChanged = lib.defineCodec(lib.structCodec([
  'oldValue',
  'newValue'
], {
  oldValue: lib.getCodec(Parameter),
  newValue: lib.getCodec(Parameter)
}));
/**
 * Codec and constructors for enumeration {@link ConfigurationEvent}.
 */ export const ConfigurationEvent = {
  ...{
    Changed: (value)=>({
        kind: 'Changed',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Changed: [
      0,
      lib.getCodec(ParameterChanged)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const CustomInstruction = lib.defineCodec(lib.structCodec([
  'payload'
], {
  payload: lib.getCodec(lib.Json)
}));
/**
 * Codec and constructors for enumeration {@link PeerEvent}.
 */ export const PeerEvent = {
  ...{
    Added: (value)=>({
        kind: 'Added',
        value
      }),
    Removed: (value)=>({
        kind: 'Removed',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Added: [
      0,
      lib.getCodec(PeerId)
    ],
    Removed: [
      1,
      lib.getCodec(PeerId)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const Domain = lib.defineCodec(lib.structCodec([
  'id',
  'logo',
  'metadata',
  'ownedBy'
], {
  id: lib.getCodec(lib.DomainId),
  logo: lib.Option.with(lib.getCodec(IpfsPath)),
  metadata: lib.getCodec(Metadata),
  ownedBy: lib.getCodec(lib.AccountId)
}));
/**
 * Codec of the structure.
 */ export const Nft = lib.defineCodec(lib.structCodec([
  'id',
  'content',
  'ownedBy'
], {
  id: lib.getCodec(lib.NftId),
  content: lib.getCodec(Metadata),
  ownedBy: lib.getCodec(lib.AccountId)
}));
/**
 * Codec of the structure.
 */ export const NftOwnerChanged = lib.defineCodec(lib.structCodec([
  'nft',
  'newOwner'
], {
  nft: lib.getCodec(lib.NftId),
  newOwner: lib.getCodec(lib.AccountId)
}));
/**
 * Codec and constructors for enumeration {@link NftEvent}.
 */ export const NftEvent = {
  ...{
    Created: (value)=>({
        kind: 'Created',
        value
      }),
    Deleted: (value)=>({
        kind: 'Deleted',
        value
      }),
    MetadataInserted: (value)=>({
        kind: 'MetadataInserted',
        value
      }),
    MetadataRemoved: (value)=>({
        kind: 'MetadataRemoved',
        value
      }),
    OwnerChanged: (value)=>({
        kind: 'OwnerChanged',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Created: [
      0,
      lib.getCodec(Nft)
    ],
    Deleted: [
      1,
      lib.getCodec(lib.NftId)
    ],
    MetadataInserted: [
      2,
      MetadataChanged.with(lib.getCodec(lib.NftId))
    ],
    MetadataRemoved: [
      3,
      MetadataChanged.with(lib.getCodec(lib.NftId))
    ],
    OwnerChanged: [
      4,
      lib.getCodec(NftOwnerChanged)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const DomainOwnerChanged = lib.defineCodec(lib.structCodec([
  'domain',
  'newOwner'
], {
  domain: lib.getCodec(lib.DomainId),
  newOwner: lib.getCodec(lib.AccountId)
}));
/**
 * Codec and constructors for enumeration {@link DomainEvent}.
 */ export const DomainEvent = {
  ...{
    Created: (value)=>({
        kind: 'Created',
        value
      }),
    Deleted: (value)=>({
        kind: 'Deleted',
        value
      }),
    AssetDefinition: {
      Created: (value)=>({
          kind: 'AssetDefinition',
          value: AssetDefinitionEvent.Created(value)
        }),
      Deleted: (value)=>({
          kind: 'AssetDefinition',
          value: AssetDefinitionEvent.Deleted(value)
        }),
      MetadataInserted: (value)=>({
          kind: 'AssetDefinition',
          value: AssetDefinitionEvent.MetadataInserted(value)
        }),
      MetadataRemoved: (value)=>({
          kind: 'AssetDefinition',
          value: AssetDefinitionEvent.MetadataRemoved(value)
        }),
      MintabilityChanged: (value)=>({
          kind: 'AssetDefinition',
          value: AssetDefinitionEvent.MintabilityChanged(value)
        }),
      TotalQuantityChanged: (value)=>({
          kind: 'AssetDefinition',
          value: AssetDefinitionEvent.TotalQuantityChanged(value)
        }),
      OwnerChanged: (value)=>({
          kind: 'AssetDefinition',
          value: AssetDefinitionEvent.OwnerChanged(value)
        })
    },
    Nft: {
      Created: (value)=>({
          kind: 'Nft',
          value: NftEvent.Created(value)
        }),
      Deleted: (value)=>({
          kind: 'Nft',
          value: NftEvent.Deleted(value)
        }),
      MetadataInserted: (value)=>({
          kind: 'Nft',
          value: NftEvent.MetadataInserted(value)
        }),
      MetadataRemoved: (value)=>({
          kind: 'Nft',
          value: NftEvent.MetadataRemoved(value)
        }),
      OwnerChanged: (value)=>({
          kind: 'Nft',
          value: NftEvent.OwnerChanged(value)
        })
    },
    Account: {
      Created: (value)=>({
          kind: 'Account',
          value: AccountEvent.Created(value)
        }),
      Deleted: (value)=>({
          kind: 'Account',
          value: AccountEvent.Deleted(value)
        }),
      Asset: {
        Created: (value)=>({
            kind: 'Account',
            value: AccountEvent.Asset.Created(value)
          }),
        Deleted: (value)=>({
            kind: 'Account',
            value: AccountEvent.Asset.Deleted(value)
          }),
        Added: (value)=>({
            kind: 'Account',
            value: AccountEvent.Asset.Added(value)
          }),
        Removed: (value)=>({
            kind: 'Account',
            value: AccountEvent.Asset.Removed(value)
          })
      },
      PermissionAdded: (value)=>({
          kind: 'Account',
          value: AccountEvent.PermissionAdded(value)
        }),
      PermissionRemoved: (value)=>({
          kind: 'Account',
          value: AccountEvent.PermissionRemoved(value)
        }),
      RoleGranted: (value)=>({
          kind: 'Account',
          value: AccountEvent.RoleGranted(value)
        }),
      RoleRevoked: (value)=>({
          kind: 'Account',
          value: AccountEvent.RoleRevoked(value)
        }),
      MetadataInserted: (value)=>({
          kind: 'Account',
          value: AccountEvent.MetadataInserted(value)
        }),
      MetadataRemoved: (value)=>({
          kind: 'Account',
          value: AccountEvent.MetadataRemoved(value)
        })
    },
    MetadataInserted: (value)=>({
        kind: 'MetadataInserted',
        value
      }),
    MetadataRemoved: (value)=>({
        kind: 'MetadataRemoved',
        value
      }),
    OwnerChanged: (value)=>({
        kind: 'OwnerChanged',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Created: [
      0,
      lib.getCodec(Domain)
    ],
    Deleted: [
      1,
      lib.getCodec(lib.DomainId)
    ],
    AssetDefinition: [
      2,
      lib.getCodec(AssetDefinitionEvent)
    ],
    Nft: [
      3,
      lib.getCodec(NftEvent)
    ],
    Account: [
      4,
      lib.getCodec(AccountEvent)
    ],
    MetadataInserted: [
      5,
      MetadataChanged.with(lib.getCodec(lib.DomainId))
    ],
    MetadataRemoved: [
      6,
      MetadataChanged.with(lib.getCodec(lib.DomainId))
    ],
    OwnerChanged: [
      7,
      lib.getCodec(DomainOwnerChanged)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const TriggerNumberOfExecutionsChanged = lib.defineCodec(lib.structCodec([
  'trigger',
  'by'
], {
  trigger: lib.getCodec(TriggerId),
  by: lib.getCodec(lib.U32)
}));
/**
 * Codec and constructors for enumeration {@link TriggerEvent}.
 */ export const TriggerEvent = {
  ...{
    Created: (value)=>({
        kind: 'Created',
        value
      }),
    Deleted: (value)=>({
        kind: 'Deleted',
        value
      }),
    Extended: (value)=>({
        kind: 'Extended',
        value
      }),
    Shortened: (value)=>({
        kind: 'Shortened',
        value
      }),
    MetadataInserted: (value)=>({
        kind: 'MetadataInserted',
        value
      }),
    MetadataRemoved: (value)=>({
        kind: 'MetadataRemoved',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Created: [
      0,
      lib.getCodec(TriggerId)
    ],
    Deleted: [
      1,
      lib.getCodec(TriggerId)
    ],
    Extended: [
      2,
      lib.getCodec(TriggerNumberOfExecutionsChanged)
    ],
    Shortened: [
      3,
      lib.getCodec(TriggerNumberOfExecutionsChanged)
    ],
    MetadataInserted: [
      4,
      MetadataChanged.with(lib.getCodec(TriggerId))
    ],
    MetadataRemoved: [
      5,
      MetadataChanged.with(lib.getCodec(TriggerId))
    ]
  }).discriminated())
};
export const PermissionsSet = lib.defineCodec(lib.BTreeSet.withCmp(lib.getCodec(Permission), (a, b)=>{
  const names = lib.ordCompare(a.name, b.name);
  if (names !== 0) return names;
  return lib.ordCompare(a.payload, b.payload);
}));
/**
 * Codec of the structure.
 */ export const Role = lib.defineCodec(lib.structCodec([
  'id',
  'permissions'
], {
  id: lib.getCodec(RoleId),
  permissions: lib.getCodec(PermissionsSet)
}));
/**
 * Codec of the structure.
 */ export const RolePermissionChanged = lib.defineCodec(lib.structCodec([
  'role',
  'permission'
], {
  role: lib.getCodec(RoleId),
  permission: lib.getCodec(Permission)
}));
/**
 * Codec and constructors for enumeration {@link RoleEvent}.
 */ export const RoleEvent = {
  ...{
    Created: (value)=>({
        kind: 'Created',
        value
      }),
    Deleted: (value)=>({
        kind: 'Deleted',
        value
      }),
    PermissionAdded: (value)=>({
        kind: 'PermissionAdded',
        value
      }),
    PermissionRemoved: (value)=>({
        kind: 'PermissionRemoved',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Created: [
      0,
      lib.getCodec(Role)
    ],
    Deleted: [
      1,
      lib.getCodec(RoleId)
    ],
    PermissionAdded: [
      2,
      lib.getCodec(RolePermissionChanged)
    ],
    PermissionRemoved: [
      3,
      lib.getCodec(RolePermissionChanged)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const ExecutorDataModel = lib.defineCodec(lib.structCodec([
  'parameters',
  'instructions',
  'permissions',
  'schema'
], {
  parameters: lib.BTreeMap.with(lib.getCodec(CustomParameterId), lib.getCodec(CustomParameter)),
  instructions: lib.BTreeSet.with(lib.getCodec(lib.String)),
  permissions: lib.BTreeSet.with(lib.getCodec(lib.String)),
  schema: lib.getCodec(lib.Json)
}));
/**
 * Codec of the structure.
 */ export const ExecutorUpgrade = lib.defineCodec(lib.structCodec([
  'newDataModel'
], {
  newDataModel: lib.getCodec(ExecutorDataModel)
}));
/**
 * Codec and constructors for enumeration {@link ExecutorEvent}.
 */ export const ExecutorEvent = {
  ...{
    Upgraded: (value)=>({
        kind: 'Upgraded',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Upgraded: [
      0,
      lib.getCodec(ExecutorUpgrade)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link DataEvent}.
 */ export const DataEvent = {
  ...{
    Peer: {
      Added: (value)=>({
          kind: 'Peer',
          value: PeerEvent.Added(value)
        }),
      Removed: (value)=>({
          kind: 'Peer',
          value: PeerEvent.Removed(value)
        })
    },
    Domain: {
      Created: (value)=>({
          kind: 'Domain',
          value: DomainEvent.Created(value)
        }),
      Deleted: (value)=>({
          kind: 'Domain',
          value: DomainEvent.Deleted(value)
        }),
      AssetDefinition: {
        Created: (value)=>({
            kind: 'Domain',
            value: DomainEvent.AssetDefinition.Created(value)
          }),
        Deleted: (value)=>({
            kind: 'Domain',
            value: DomainEvent.AssetDefinition.Deleted(value)
          }),
        MetadataInserted: (value)=>({
            kind: 'Domain',
            value: DomainEvent.AssetDefinition.MetadataInserted(value)
          }),
        MetadataRemoved: (value)=>({
            kind: 'Domain',
            value: DomainEvent.AssetDefinition.MetadataRemoved(value)
          }),
        MintabilityChanged: (value)=>({
            kind: 'Domain',
            value: DomainEvent.AssetDefinition.MintabilityChanged(value)
          }),
        TotalQuantityChanged: (value)=>({
            kind: 'Domain',
            value: DomainEvent.AssetDefinition.TotalQuantityChanged(value)
          }),
        OwnerChanged: (value)=>({
            kind: 'Domain',
            value: DomainEvent.AssetDefinition.OwnerChanged(value)
          })
      },
      Nft: {
        Created: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Nft.Created(value)
          }),
        Deleted: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Nft.Deleted(value)
          }),
        MetadataInserted: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Nft.MetadataInserted(value)
          }),
        MetadataRemoved: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Nft.MetadataRemoved(value)
          }),
        OwnerChanged: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Nft.OwnerChanged(value)
          })
      },
      Account: {
        Created: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Account.Created(value)
          }),
        Deleted: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Account.Deleted(value)
          }),
        Asset: {
          Created: (value)=>({
              kind: 'Domain',
              value: DomainEvent.Account.Asset.Created(value)
            }),
          Deleted: (value)=>({
              kind: 'Domain',
              value: DomainEvent.Account.Asset.Deleted(value)
            }),
          Added: (value)=>({
              kind: 'Domain',
              value: DomainEvent.Account.Asset.Added(value)
            }),
          Removed: (value)=>({
              kind: 'Domain',
              value: DomainEvent.Account.Asset.Removed(value)
            })
        },
        PermissionAdded: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Account.PermissionAdded(value)
          }),
        PermissionRemoved: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Account.PermissionRemoved(value)
          }),
        RoleGranted: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Account.RoleGranted(value)
          }),
        RoleRevoked: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Account.RoleRevoked(value)
          }),
        MetadataInserted: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Account.MetadataInserted(value)
          }),
        MetadataRemoved: (value)=>({
            kind: 'Domain',
            value: DomainEvent.Account.MetadataRemoved(value)
          })
      },
      MetadataInserted: (value)=>({
          kind: 'Domain',
          value: DomainEvent.MetadataInserted(value)
        }),
      MetadataRemoved: (value)=>({
          kind: 'Domain',
          value: DomainEvent.MetadataRemoved(value)
        }),
      OwnerChanged: (value)=>({
          kind: 'Domain',
          value: DomainEvent.OwnerChanged(value)
        })
    },
    Trigger: {
      Created: (value)=>({
          kind: 'Trigger',
          value: TriggerEvent.Created(value)
        }),
      Deleted: (value)=>({
          kind: 'Trigger',
          value: TriggerEvent.Deleted(value)
        }),
      Extended: (value)=>({
          kind: 'Trigger',
          value: TriggerEvent.Extended(value)
        }),
      Shortened: (value)=>({
          kind: 'Trigger',
          value: TriggerEvent.Shortened(value)
        }),
      MetadataInserted: (value)=>({
          kind: 'Trigger',
          value: TriggerEvent.MetadataInserted(value)
        }),
      MetadataRemoved: (value)=>({
          kind: 'Trigger',
          value: TriggerEvent.MetadataRemoved(value)
        })
    },
    Role: {
      Created: (value)=>({
          kind: 'Role',
          value: RoleEvent.Created(value)
        }),
      Deleted: (value)=>({
          kind: 'Role',
          value: RoleEvent.Deleted(value)
        }),
      PermissionAdded: (value)=>({
          kind: 'Role',
          value: RoleEvent.PermissionAdded(value)
        }),
      PermissionRemoved: (value)=>({
          kind: 'Role',
          value: RoleEvent.PermissionRemoved(value)
        })
    },
    Configuration: {
      Changed: (value)=>({
          kind: 'Configuration',
          value: ConfigurationEvent.Changed(value)
        })
    },
    Executor: {
      Upgraded: (value)=>({
          kind: 'Executor',
          value: ExecutorEvent.Upgraded(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Peer: [
      0,
      lib.getCodec(PeerEvent)
    ],
    Domain: [
      1,
      lib.getCodec(DomainEvent)
    ],
    Trigger: [
      2,
      lib.getCodec(TriggerEvent)
    ],
    Role: [
      3,
      lib.getCodec(RoleEvent)
    ],
    Configuration: [
      4,
      lib.getCodec(ConfigurationEvent)
    ],
    Executor: [
      5,
      lib.getCodec(ExecutorEvent)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link DomainProjectionSelector}.
 */ export const DomainProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Id: {
      Atom: Object.freeze({
        kind: 'Id',
        value: DomainIdProjectionSelector.Atom
      }),
      Name: {
        Atom: Object.freeze({
          kind: 'Id',
          value: DomainIdProjectionSelector.Name.Atom
        })
      }
    },
    Metadata: {
      Atom: Object.freeze({
        kind: 'Metadata',
        value: MetadataProjectionSelector.Atom
      }),
      Key: (value)=>({
          kind: 'Metadata',
          value: MetadataProjectionSelector.Key(value)
        })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Id: [
      1,
      lib.getCodec(DomainIdProjectionSelector)
    ],
    Metadata: [
      2,
      lib.getCodec(MetadataProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const TransactionEvent = lib.defineCodec(lib.structCodec([
  'hash',
  'blockHeight',
  'status'
], {
  hash: lib.getCodec(lib.Hash),
  blockHeight: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U64))),
  status: lib.getCodec(TransactionStatus)
}));
/**
 * Codec and constructors for enumeration {@link PipelineEventBox}.
 */ export const PipelineEventBox = {
  ...{
    Transaction: (value)=>({
        kind: 'Transaction',
        value
      }),
    Block: (value)=>({
        kind: 'Block',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Transaction: [
      0,
      lib.getCodec(TransactionEvent)
    ],
    Block: [
      1,
      lib.getCodec(BlockEvent)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const TimeInterval = lib.defineCodec(lib.structCodec([
  'since',
  'length'
], {
  since: lib.getCodec(lib.Timestamp),
  length: lib.getCodec(lib.Duration)
}));
/**
 * Codec of the structure.
 */ export const TimeEvent = lib.defineCodec(lib.structCodec([
  'interval'
], {
  interval: lib.getCodec(TimeInterval)
}));
/**
 * Codec of the structure.
 */ export const ExecuteTriggerEvent = lib.defineCodec(lib.structCodec([
  'triggerId',
  'authority',
  'args'
], {
  triggerId: lib.getCodec(TriggerId),
  authority: lib.getCodec(lib.AccountId),
  args: lib.getCodec(lib.Json)
}));
/**
 * Codec and constructors for enumeration {@link TriggerCompletedOutcome}.
 */ export const TriggerCompletedOutcome = {
  ...{
    Success: Object.freeze({
      kind: 'Success'
    }),
    Failure: (value)=>({
        kind: 'Failure',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Success: [
      0
    ],
    Failure: [
      1,
      lib.getCodec(lib.String)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const TriggerCompletedEvent = lib.defineCodec(lib.structCodec([
  'triggerId',
  'outcome'
], {
  triggerId: lib.getCodec(TriggerId),
  outcome: lib.getCodec(TriggerCompletedOutcome)
}));
/**
 * Codec and constructors for enumeration {@link EventBox}.
 */ export const EventBox = {
  ...{
    Pipeline: {
      Transaction: (value)=>({
          kind: 'Pipeline',
          value: PipelineEventBox.Transaction(value)
        }),
      Block: (value)=>({
          kind: 'Pipeline',
          value: PipelineEventBox.Block(value)
        })
    },
    Data: {
      Peer: {
        Added: (value)=>({
            kind: 'Data',
            value: DataEvent.Peer.Added(value)
          }),
        Removed: (value)=>({
            kind: 'Data',
            value: DataEvent.Peer.Removed(value)
          })
      },
      Domain: {
        Created: (value)=>({
            kind: 'Data',
            value: DataEvent.Domain.Created(value)
          }),
        Deleted: (value)=>({
            kind: 'Data',
            value: DataEvent.Domain.Deleted(value)
          }),
        AssetDefinition: {
          Created: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.AssetDefinition.Created(value)
            }),
          Deleted: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.AssetDefinition.Deleted(value)
            }),
          MetadataInserted: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.AssetDefinition.MetadataInserted(value)
            }),
          MetadataRemoved: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.AssetDefinition.MetadataRemoved(value)
            }),
          MintabilityChanged: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.AssetDefinition.MintabilityChanged(value)
            }),
          TotalQuantityChanged: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.AssetDefinition.TotalQuantityChanged(value)
            }),
          OwnerChanged: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.AssetDefinition.OwnerChanged(value)
            })
        },
        Nft: {
          Created: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Nft.Created(value)
            }),
          Deleted: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Nft.Deleted(value)
            }),
          MetadataInserted: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Nft.MetadataInserted(value)
            }),
          MetadataRemoved: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Nft.MetadataRemoved(value)
            }),
          OwnerChanged: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Nft.OwnerChanged(value)
            })
        },
        Account: {
          Created: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Account.Created(value)
            }),
          Deleted: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Account.Deleted(value)
            }),
          Asset: {
            Created: (value)=>({
                kind: 'Data',
                value: DataEvent.Domain.Account.Asset.Created(value)
              }),
            Deleted: (value)=>({
                kind: 'Data',
                value: DataEvent.Domain.Account.Asset.Deleted(value)
              }),
            Added: (value)=>({
                kind: 'Data',
                value: DataEvent.Domain.Account.Asset.Added(value)
              }),
            Removed: (value)=>({
                kind: 'Data',
                value: DataEvent.Domain.Account.Asset.Removed(value)
              })
          },
          PermissionAdded: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Account.PermissionAdded(value)
            }),
          PermissionRemoved: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Account.PermissionRemoved(value)
            }),
          RoleGranted: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Account.RoleGranted(value)
            }),
          RoleRevoked: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Account.RoleRevoked(value)
            }),
          MetadataInserted: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Account.MetadataInserted(value)
            }),
          MetadataRemoved: (value)=>({
              kind: 'Data',
              value: DataEvent.Domain.Account.MetadataRemoved(value)
            })
        },
        MetadataInserted: (value)=>({
            kind: 'Data',
            value: DataEvent.Domain.MetadataInserted(value)
          }),
        MetadataRemoved: (value)=>({
            kind: 'Data',
            value: DataEvent.Domain.MetadataRemoved(value)
          }),
        OwnerChanged: (value)=>({
            kind: 'Data',
            value: DataEvent.Domain.OwnerChanged(value)
          })
      },
      Trigger: {
        Created: (value)=>({
            kind: 'Data',
            value: DataEvent.Trigger.Created(value)
          }),
        Deleted: (value)=>({
            kind: 'Data',
            value: DataEvent.Trigger.Deleted(value)
          }),
        Extended: (value)=>({
            kind: 'Data',
            value: DataEvent.Trigger.Extended(value)
          }),
        Shortened: (value)=>({
            kind: 'Data',
            value: DataEvent.Trigger.Shortened(value)
          }),
        MetadataInserted: (value)=>({
            kind: 'Data',
            value: DataEvent.Trigger.MetadataInserted(value)
          }),
        MetadataRemoved: (value)=>({
            kind: 'Data',
            value: DataEvent.Trigger.MetadataRemoved(value)
          })
      },
      Role: {
        Created: (value)=>({
            kind: 'Data',
            value: DataEvent.Role.Created(value)
          }),
        Deleted: (value)=>({
            kind: 'Data',
            value: DataEvent.Role.Deleted(value)
          }),
        PermissionAdded: (value)=>({
            kind: 'Data',
            value: DataEvent.Role.PermissionAdded(value)
          }),
        PermissionRemoved: (value)=>({
            kind: 'Data',
            value: DataEvent.Role.PermissionRemoved(value)
          })
      },
      Configuration: {
        Changed: (value)=>({
            kind: 'Data',
            value: DataEvent.Configuration.Changed(value)
          })
      },
      Executor: {
        Upgraded: (value)=>({
            kind: 'Data',
            value: DataEvent.Executor.Upgraded(value)
          })
      }
    },
    Time: (value)=>({
        kind: 'Time',
        value
      }),
    ExecuteTrigger: (value)=>({
        kind: 'ExecuteTrigger',
        value
      }),
    TriggerCompleted: (value)=>({
        kind: 'TriggerCompleted',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Pipeline: [
      0,
      lib.getCodec(PipelineEventBox)
    ],
    Data: [
      1,
      lib.getCodec(DataEvent)
    ],
    Time: [
      2,
      lib.getCodec(TimeEvent)
    ],
    ExecuteTrigger: [
      3,
      lib.getCodec(ExecuteTriggerEvent)
    ],
    TriggerCompleted: [
      4,
      lib.getCodec(TriggerCompletedEvent)
    ]
  }).discriminated())
};
export const EventMessage = EventBox;
/**
 * Codec of the structure.
 */ export const EventSubscriptionRequest = lib.defineCodec(lib.structCodec([
  'filters'
], {
  filters: lib.Vec.with(lib.getCodec(EventFilterBox))
}));
/**
 * Codec of the structure.
 */ export const ExecuteTrigger = lib.defineCodec(lib.structCodec([
  'trigger',
  'args'
], {
  trigger: lib.getCodec(TriggerId),
  args: lib.getCodec(lib.Json)
}));
/**
 * Codec of the structure.
 */ export const Executor = lib.defineCodec(lib.structCodec([
  'wasm'
], {
  wasm: lib.getCodec(WasmSmartContract)
}));
/**
 * Codec of the structure.
 */ export const FindAccountsWithAsset = lib.defineCodec(lib.structCodec([
  'assetDefinition'
], {
  assetDefinition: lib.getCodec(lib.AssetDefinitionId)
}));
/**
 * Codec of the structure.
 */ export const FindPermissionsByAccountId = lib.defineCodec(lib.structCodec([
  'id'
], {
  id: lib.getCodec(lib.AccountId)
}));
/**
 * Codec of the structure.
 */ export const FindRolesByAccountId = lib.defineCodec(lib.structCodec([
  'id'
], {
  id: lib.getCodec(lib.AccountId)
}));
/**
 * Codec of the structure.
 */ export const ForwardCursor = lib.defineCodec(lib.structCodec([
  'query',
  'cursor'
], {
  query: lib.getCodec(lib.String),
  cursor: lib.NonZero.with(lib.getCodec(lib.U64))
}));
/**
 * Codec of the structure.
 */ export const GenesisWasmAction = lib.defineCodec(lib.structCodec([
  'executable',
  'repeats',
  'authority',
  'filter'
], {
  executable: lib.getCodec(lib.String),
  repeats: lib.getCodec(Repeats),
  authority: lib.getCodec(lib.AccountId),
  filter: lib.getCodec(EventFilterBox)
}));
/**
 * Codec of the structure.
 */ export const GenesisWasmTrigger = lib.defineCodec(lib.structCodec([
  'id',
  'action'
], {
  id: lib.getCodec(TriggerId),
  action: lib.getCodec(GenesisWasmAction)
}));
/**
 * Codec constructor for the structure with generic parameters.
 */ export const Grant = {
  with: (t0, t1)=>lib.structCodec([
      'object',
      'destination'
    ], {
      object: t0,
      destination: t1
    })
};
/**
 * Codec and constructors for enumeration {@link GrantBox}.
 */ export const GrantBox = {
  ...{
    Permission: (value)=>({
        kind: 'Permission',
        value
      }),
    Role: (value)=>({
        kind: 'Role',
        value
      }),
    RolePermission: (value)=>({
        kind: 'RolePermission',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Permission: [
      0,
      Grant.with(lib.getCodec(Permission), lib.getCodec(lib.AccountId))
    ],
    Role: [
      1,
      Grant.with(lib.getCodec(RoleId), lib.getCodec(lib.AccountId))
    ],
    RolePermission: [
      2,
      Grant.with(lib.getCodec(Permission), lib.getCodec(RoleId))
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const NewDomain = lib.defineCodec(lib.structCodec([
  'id',
  'logo',
  'metadata'
], {
  id: lib.getCodec(lib.DomainId),
  logo: lib.Option.with(lib.getCodec(IpfsPath)),
  metadata: lib.getCodec(Metadata)
}));
/**
 * Codec of the structure.
 */ export const NewAccount = lib.defineCodec(lib.structCodec([
  'id',
  'metadata'
], {
  id: lib.getCodec(lib.AccountId),
  metadata: lib.getCodec(Metadata)
}));
/**
 * Codec of the structure.
 */ export const NewAssetDefinition = lib.defineCodec(lib.structCodec([
  'id',
  'spec',
  'mintable',
  'logo',
  'metadata'
], {
  id: lib.getCodec(lib.AssetDefinitionId),
  spec: lib.getCodec(NumericSpec),
  mintable: lib.getCodec(Mintable),
  logo: lib.Option.with(lib.getCodec(IpfsPath)),
  metadata: lib.getCodec(Metadata)
}));
/**
 * Codec of the structure.
 */ export const NewNft = lib.defineCodec(lib.structCodec([
  'id',
  'content'
], {
  id: lib.getCodec(lib.NftId),
  content: lib.getCodec(Metadata)
}));
/**
 * Codec of the structure.
 */ export const NewRole = lib.defineCodec(lib.structCodec([
  'inner',
  'grantTo'
], {
  inner: lib.getCodec(Role),
  grantTo: lib.getCodec(lib.AccountId)
}));
/**
 * Codec of the structure.
 */ export const Trigger = lib.defineCodec(lib.structCodec([
  'id',
  'action'
], {
  id: lib.getCodec(TriggerId),
  action: lib.getCodec(Action)
}));
/**
 * Codec and constructors for enumeration {@link RegisterBox}.
 */ export const RegisterBox = {
  ...{
    Peer: (value)=>({
        kind: 'Peer',
        value
      }),
    Domain: (value)=>({
        kind: 'Domain',
        value
      }),
    Account: (value)=>({
        kind: 'Account',
        value
      }),
    AssetDefinition: (value)=>({
        kind: 'AssetDefinition',
        value
      }),
    Nft: (value)=>({
        kind: 'Nft',
        value
      }),
    Role: (value)=>({
        kind: 'Role',
        value
      }),
    Trigger: (value)=>({
        kind: 'Trigger',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Peer: [
      0,
      lib.getCodec(PeerId)
    ],
    Domain: [
      1,
      lib.getCodec(NewDomain)
    ],
    Account: [
      2,
      lib.getCodec(NewAccount)
    ],
    AssetDefinition: [
      3,
      lib.getCodec(NewAssetDefinition)
    ],
    Nft: [
      4,
      lib.getCodec(NewNft)
    ],
    Role: [
      5,
      lib.getCodec(NewRole)
    ],
    Trigger: [
      6,
      lib.getCodec(Trigger)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link UnregisterBox}.
 */ export const UnregisterBox = {
  ...{
    Peer: (value)=>({
        kind: 'Peer',
        value
      }),
    Domain: (value)=>({
        kind: 'Domain',
        value
      }),
    Account: (value)=>({
        kind: 'Account',
        value
      }),
    AssetDefinition: (value)=>({
        kind: 'AssetDefinition',
        value
      }),
    Nft: (value)=>({
        kind: 'Nft',
        value
      }),
    Role: (value)=>({
        kind: 'Role',
        value
      }),
    Trigger: (value)=>({
        kind: 'Trigger',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Peer: [
      0,
      lib.getCodec(PeerId)
    ],
    Domain: [
      1,
      lib.getCodec(lib.DomainId)
    ],
    Account: [
      2,
      lib.getCodec(lib.AccountId)
    ],
    AssetDefinition: [
      3,
      lib.getCodec(lib.AssetDefinitionId)
    ],
    Nft: [
      4,
      lib.getCodec(lib.NftId)
    ],
    Role: [
      5,
      lib.getCodec(RoleId)
    ],
    Trigger: [
      6,
      lib.getCodec(TriggerId)
    ]
  }).discriminated())
};
/**
 * Codec constructor for the structure with generic parameters.
 */ export const Mint = {
  with: (t0, t1)=>lib.structCodec([
      'object',
      'destination'
    ], {
      object: t0,
      destination: t1
    })
};
/**
 * Codec and constructors for enumeration {@link MintBox}.
 */ export const MintBox = {
  ...{
    Asset: (value)=>({
        kind: 'Asset',
        value
      }),
    TriggerRepetitions: (value)=>({
        kind: 'TriggerRepetitions',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Asset: [
      0,
      Mint.with(lib.getCodec(Numeric), lib.getCodec(lib.AssetId))
    ],
    TriggerRepetitions: [
      1,
      Mint.with(lib.getCodec(lib.U32), lib.getCodec(TriggerId))
    ]
  }).discriminated())
};
/**
 * Codec constructor for the structure with generic parameters.
 */ export const Transfer = {
  with: (t0, t1, t2)=>lib.structCodec([
      'source',
      'object',
      'destination'
    ], {
      source: t0,
      object: t1,
      destination: t2
    })
};
/**
 * Codec and constructors for enumeration {@link TransferBox}.
 */ export const TransferBox = {
  ...{
    Domain: (value)=>({
        kind: 'Domain',
        value
      }),
    AssetDefinition: (value)=>({
        kind: 'AssetDefinition',
        value
      }),
    Asset: (value)=>({
        kind: 'Asset',
        value
      }),
    Nft: (value)=>({
        kind: 'Nft',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Domain: [
      0,
      Transfer.with(lib.getCodec(lib.AccountId), lib.getCodec(lib.DomainId), lib.getCodec(lib.AccountId))
    ],
    AssetDefinition: [
      1,
      Transfer.with(lib.getCodec(lib.AccountId), lib.getCodec(lib.AssetDefinitionId), lib.getCodec(lib.AccountId))
    ],
    Asset: [
      2,
      Transfer.with(lib.getCodec(lib.AssetId), lib.getCodec(Numeric), lib.getCodec(lib.AccountId))
    ],
    Nft: [
      3,
      Transfer.with(lib.getCodec(lib.AccountId), lib.getCodec(lib.NftId), lib.getCodec(lib.AccountId))
    ]
  }).discriminated())
};
/**
 * Codec constructor for the structure with generic parameters.
 */ export const SetKeyValue = {
  with: (t0)=>lib.structCodec([
      'object',
      'key',
      'value'
    ], {
      object: t0,
      key: lib.getCodec(lib.Name),
      value: lib.getCodec(lib.Json)
    })
};
/**
 * Codec and constructors for enumeration {@link SetKeyValueBox}.
 */ export const SetKeyValueBox = {
  ...{
    Domain: (value)=>({
        kind: 'Domain',
        value
      }),
    Account: (value)=>({
        kind: 'Account',
        value
      }),
    AssetDefinition: (value)=>({
        kind: 'AssetDefinition',
        value
      }),
    Nft: (value)=>({
        kind: 'Nft',
        value
      }),
    Trigger: (value)=>({
        kind: 'Trigger',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Domain: [
      0,
      SetKeyValue.with(lib.getCodec(lib.DomainId))
    ],
    Account: [
      1,
      SetKeyValue.with(lib.getCodec(lib.AccountId))
    ],
    AssetDefinition: [
      2,
      SetKeyValue.with(lib.getCodec(lib.AssetDefinitionId))
    ],
    Nft: [
      3,
      SetKeyValue.with(lib.getCodec(lib.NftId))
    ],
    Trigger: [
      4,
      SetKeyValue.with(lib.getCodec(TriggerId))
    ]
  }).discriminated())
};
/**
 * Codec constructor for the structure with generic parameters.
 */ export const RemoveKeyValue = {
  with: (t0)=>lib.structCodec([
      'object',
      'key'
    ], {
      object: t0,
      key: lib.getCodec(lib.Name)
    })
};
/**
 * Codec and constructors for enumeration {@link RemoveKeyValueBox}.
 */ export const RemoveKeyValueBox = {
  ...{
    Domain: (value)=>({
        kind: 'Domain',
        value
      }),
    Account: (value)=>({
        kind: 'Account',
        value
      }),
    AssetDefinition: (value)=>({
        kind: 'AssetDefinition',
        value
      }),
    Nft: (value)=>({
        kind: 'Nft',
        value
      }),
    Trigger: (value)=>({
        kind: 'Trigger',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Domain: [
      0,
      RemoveKeyValue.with(lib.getCodec(lib.DomainId))
    ],
    Account: [
      1,
      RemoveKeyValue.with(lib.getCodec(lib.AccountId))
    ],
    AssetDefinition: [
      2,
      RemoveKeyValue.with(lib.getCodec(lib.AssetDefinitionId))
    ],
    Nft: [
      3,
      RemoveKeyValue.with(lib.getCodec(lib.NftId))
    ],
    Trigger: [
      4,
      RemoveKeyValue.with(lib.getCodec(TriggerId))
    ]
  }).discriminated())
};
/**
 * Codec constructor for the structure with generic parameters.
 */ export const Revoke = {
  with: (t0, t1)=>lib.structCodec([
      'object',
      'destination'
    ], {
      object: t0,
      destination: t1
    })
};
/**
 * Codec and constructors for enumeration {@link RevokeBox}.
 */ export const RevokeBox = {
  ...{
    Permission: (value)=>({
        kind: 'Permission',
        value
      }),
    Role: (value)=>({
        kind: 'Role',
        value
      }),
    RolePermission: (value)=>({
        kind: 'RolePermission',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Permission: [
      0,
      Revoke.with(lib.getCodec(Permission), lib.getCodec(lib.AccountId))
    ],
    Role: [
      1,
      Revoke.with(lib.getCodec(RoleId), lib.getCodec(lib.AccountId))
    ],
    RolePermission: [
      2,
      Revoke.with(lib.getCodec(Permission), lib.getCodec(RoleId))
    ]
  }).discriminated())
};
export const SetParameter = Parameter;
/**
 * Codec of the structure.
 */ export const Upgrade = lib.defineCodec(lib.structCodec([
  'executor'
], {
  executor: lib.getCodec(Executor)
}));
/**
 * Codec and constructors for enumeration {@link Level}.
 */ export const Level = {
  ...{
    TRACE: Object.freeze({
      kind: 'TRACE'
    }),
    DEBUG: Object.freeze({
      kind: 'DEBUG'
    }),
    INFO: Object.freeze({
      kind: 'INFO'
    }),
    WARN: Object.freeze({
      kind: 'WARN'
    }),
    ERROR: Object.freeze({
      kind: 'ERROR'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    TRACE: [
      0
    ],
    DEBUG: [
      1
    ],
    INFO: [
      2
    ],
    WARN: [
      3
    ],
    ERROR: [
      4
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const Log = lib.defineCodec(lib.structCodec([
  'level',
  'msg'
], {
  level: lib.getCodec(Level),
  msg: lib.getCodec(lib.String)
}));
/**
 * Codec and constructors for enumeration {@link InstructionBox}.
 */ export const InstructionBox = {
  ...{
    Register: {
      Peer: (value)=>({
          kind: 'Register',
          value: RegisterBox.Peer(value)
        }),
      Domain: (value)=>({
          kind: 'Register',
          value: RegisterBox.Domain(value)
        }),
      Account: (value)=>({
          kind: 'Register',
          value: RegisterBox.Account(value)
        }),
      AssetDefinition: (value)=>({
          kind: 'Register',
          value: RegisterBox.AssetDefinition(value)
        }),
      Nft: (value)=>({
          kind: 'Register',
          value: RegisterBox.Nft(value)
        }),
      Role: (value)=>({
          kind: 'Register',
          value: RegisterBox.Role(value)
        }),
      Trigger: (value)=>({
          kind: 'Register',
          value: RegisterBox.Trigger(value)
        })
    },
    Unregister: {
      Peer: (value)=>({
          kind: 'Unregister',
          value: UnregisterBox.Peer(value)
        }),
      Domain: (value)=>({
          kind: 'Unregister',
          value: UnregisterBox.Domain(value)
        }),
      Account: (value)=>({
          kind: 'Unregister',
          value: UnregisterBox.Account(value)
        }),
      AssetDefinition: (value)=>({
          kind: 'Unregister',
          value: UnregisterBox.AssetDefinition(value)
        }),
      Nft: (value)=>({
          kind: 'Unregister',
          value: UnregisterBox.Nft(value)
        }),
      Role: (value)=>({
          kind: 'Unregister',
          value: UnregisterBox.Role(value)
        }),
      Trigger: (value)=>({
          kind: 'Unregister',
          value: UnregisterBox.Trigger(value)
        })
    },
    Mint: {
      Asset: (value)=>({
          kind: 'Mint',
          value: MintBox.Asset(value)
        }),
      TriggerRepetitions: (value)=>({
          kind: 'Mint',
          value: MintBox.TriggerRepetitions(value)
        })
    },
    Burn: {
      Asset: (value)=>({
          kind: 'Burn',
          value: BurnBox.Asset(value)
        }),
      TriggerRepetitions: (value)=>({
          kind: 'Burn',
          value: BurnBox.TriggerRepetitions(value)
        })
    },
    Transfer: {
      Domain: (value)=>({
          kind: 'Transfer',
          value: TransferBox.Domain(value)
        }),
      AssetDefinition: (value)=>({
          kind: 'Transfer',
          value: TransferBox.AssetDefinition(value)
        }),
      Asset: (value)=>({
          kind: 'Transfer',
          value: TransferBox.Asset(value)
        }),
      Nft: (value)=>({
          kind: 'Transfer',
          value: TransferBox.Nft(value)
        })
    },
    SetKeyValue: {
      Domain: (value)=>({
          kind: 'SetKeyValue',
          value: SetKeyValueBox.Domain(value)
        }),
      Account: (value)=>({
          kind: 'SetKeyValue',
          value: SetKeyValueBox.Account(value)
        }),
      AssetDefinition: (value)=>({
          kind: 'SetKeyValue',
          value: SetKeyValueBox.AssetDefinition(value)
        }),
      Nft: (value)=>({
          kind: 'SetKeyValue',
          value: SetKeyValueBox.Nft(value)
        }),
      Trigger: (value)=>({
          kind: 'SetKeyValue',
          value: SetKeyValueBox.Trigger(value)
        })
    },
    RemoveKeyValue: {
      Domain: (value)=>({
          kind: 'RemoveKeyValue',
          value: RemoveKeyValueBox.Domain(value)
        }),
      Account: (value)=>({
          kind: 'RemoveKeyValue',
          value: RemoveKeyValueBox.Account(value)
        }),
      AssetDefinition: (value)=>({
          kind: 'RemoveKeyValue',
          value: RemoveKeyValueBox.AssetDefinition(value)
        }),
      Nft: (value)=>({
          kind: 'RemoveKeyValue',
          value: RemoveKeyValueBox.Nft(value)
        }),
      Trigger: (value)=>({
          kind: 'RemoveKeyValue',
          value: RemoveKeyValueBox.Trigger(value)
        })
    },
    Grant: {
      Permission: (value)=>({
          kind: 'Grant',
          value: GrantBox.Permission(value)
        }),
      Role: (value)=>({
          kind: 'Grant',
          value: GrantBox.Role(value)
        }),
      RolePermission: (value)=>({
          kind: 'Grant',
          value: GrantBox.RolePermission(value)
        })
    },
    Revoke: {
      Permission: (value)=>({
          kind: 'Revoke',
          value: RevokeBox.Permission(value)
        }),
      Role: (value)=>({
          kind: 'Revoke',
          value: RevokeBox.Role(value)
        }),
      RolePermission: (value)=>({
          kind: 'Revoke',
          value: RevokeBox.RolePermission(value)
        })
    },
    ExecuteTrigger: (value)=>({
        kind: 'ExecuteTrigger',
        value
      }),
    SetParameter: {
      Sumeragi: {
        BlockTime: (value)=>({
            kind: 'SetParameter',
            value: SetParameter.Sumeragi.BlockTime(value)
          }),
        CommitTime: (value)=>({
            kind: 'SetParameter',
            value: SetParameter.Sumeragi.CommitTime(value)
          }),
        MaxClockDrift: (value)=>({
            kind: 'SetParameter',
            value: SetParameter.Sumeragi.MaxClockDrift(value)
          })
      },
      Block: {
        MaxTransactions: (value)=>({
            kind: 'SetParameter',
            value: SetParameter.Block.MaxTransactions(value)
          })
      },
      Transaction: {
        MaxInstructions: (value)=>({
            kind: 'SetParameter',
            value: SetParameter.Transaction.MaxInstructions(value)
          }),
        SmartContractSize: (value)=>({
            kind: 'SetParameter',
            value: SetParameter.Transaction.SmartContractSize(value)
          })
      },
      SmartContract: {
        Fuel: (value)=>({
            kind: 'SetParameter',
            value: SetParameter.SmartContract.Fuel(value)
          }),
        Memory: (value)=>({
            kind: 'SetParameter',
            value: SetParameter.SmartContract.Memory(value)
          })
      },
      Executor: {
        Fuel: (value)=>({
            kind: 'SetParameter',
            value: SetParameter.Executor.Fuel(value)
          }),
        Memory: (value)=>({
            kind: 'SetParameter',
            value: SetParameter.Executor.Memory(value)
          })
      },
      Custom: (value)=>({
          kind: 'SetParameter',
          value: SetParameter.Custom(value)
        })
    },
    Upgrade: (value)=>({
        kind: 'Upgrade',
        value
      }),
    Log: (value)=>({
        kind: 'Log',
        value
      }),
    Custom: (value)=>({
        kind: 'Custom',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Register: [
      0,
      lib.getCodec(RegisterBox)
    ],
    Unregister: [
      1,
      lib.getCodec(UnregisterBox)
    ],
    Mint: [
      2,
      lib.getCodec(MintBox)
    ],
    Burn: [
      3,
      lib.getCodec(BurnBox)
    ],
    Transfer: [
      4,
      lib.getCodec(TransferBox)
    ],
    SetKeyValue: [
      5,
      lib.getCodec(SetKeyValueBox)
    ],
    RemoveKeyValue: [
      6,
      lib.getCodec(RemoveKeyValueBox)
    ],
    Grant: [
      7,
      lib.getCodec(GrantBox)
    ],
    Revoke: [
      8,
      lib.getCodec(RevokeBox)
    ],
    ExecuteTrigger: [
      9,
      lib.getCodec(ExecuteTrigger)
    ],
    SetParameter: [
      10,
      lib.getCodec(SetParameter)
    ],
    Upgrade: [
      11,
      lib.getCodec(Upgrade)
    ],
    Log: [
      12,
      lib.getCodec(Log)
    ],
    Custom: [
      13,
      lib.getCodec(CustomInstruction)
    ]
  }).discriminated())
};
export const Ipv4Addr = lib.defineCodec(lib.tupleCodec([
  lib.getCodec(lib.U8),
  lib.getCodec(lib.U8),
  lib.getCodec(lib.U8),
  lib.getCodec(lib.U8)
]));
export const Ipv6Addr = lib.defineCodec(lib.tupleCodec([
  lib.getCodec(lib.U16),
  lib.getCodec(lib.U16),
  lib.getCodec(lib.U16),
  lib.getCodec(lib.U16),
  lib.getCodec(lib.U16),
  lib.getCodec(lib.U16),
  lib.getCodec(lib.U16),
  lib.getCodec(lib.U16)
]));
/**
 * Codec of the structure.
 */ export const MultisigApprove = lib.defineCodec(lib.structCodec([
  'account',
  'instructionsHash'
], {
  account: lib.getCodec(lib.AccountId),
  instructionsHash: lib.getCodec(lib.Hash)
}));
/**
 * Codec of the structure.
 */ export const MultisigSpec = lib.defineCodec(lib.structCodec([
  'signatories',
  'quorum',
  'transactionTtl'
], {
  signatories: lib.BTreeMap.with(lib.getCodec(lib.AccountId), lib.getCodec(lib.U8)),
  quorum: lib.NonZero.with(lib.getCodec(lib.U16)),
  transactionTtl: lib.NonZero.with(lib.getCodec(lib.Duration))
}));
/**
 * Codec of the structure.
 */ export const MultisigRegister = lib.defineCodec(lib.structCodec([
  'account',
  'spec'
], {
  account: lib.getCodec(lib.AccountId),
  spec: lib.getCodec(MultisigSpec)
}));
/**
 * Codec of the structure.
 */ export const MultisigPropose = lib.defineCodec(lib.structCodec([
  'account',
  'instructions',
  'transactionTtl'
], {
  account: lib.getCodec(lib.AccountId),
  instructions: lib.Vec.with(lib.lazyCodec(()=>lib.getCodec(InstructionBox))),
  transactionTtl: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.Duration)))
}));
/**
 * Codec and constructors for enumeration {@link MultisigInstructionBox}.
 */ export const MultisigInstructionBox = {
  ...{
    Register: (value)=>({
        kind: 'Register',
        value
      }),
    Propose: (value)=>({
        kind: 'Propose',
        value
      }),
    Approve: (value)=>({
        kind: 'Approve',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Register: [
      0,
      lib.getCodec(MultisigRegister)
    ],
    Propose: [
      1,
      lib.getCodec(MultisigPropose)
    ],
    Approve: [
      2,
      lib.getCodec(MultisigApprove)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const MultisigProposalValue = lib.defineCodec(lib.structCodec([
  'instructions',
  'proposedAt',
  'expiresAt',
  'approvals',
  'isRelayed'
], {
  instructions: lib.Vec.with(lib.lazyCodec(()=>lib.getCodec(InstructionBox))),
  proposedAt: lib.getCodec(lib.Timestamp),
  expiresAt: lib.getCodec(lib.Timestamp),
  approvals: lib.BTreeSet.with(lib.getCodec(lib.AccountId)),
  isRelayed: lib.Option.with(lib.getCodec(lib.Bool))
}));
/**
 * Codec and constructors for enumeration {@link NftIdProjectionSelector}.
 */ export const NftIdProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Domain: {
      Atom: Object.freeze({
        kind: 'Domain',
        value: DomainIdProjectionSelector.Atom
      }),
      Name: {
        Atom: Object.freeze({
          kind: 'Domain',
          value: DomainIdProjectionSelector.Name.Atom
        })
      }
    },
    Name: {
      Atom: Object.freeze({
        kind: 'Name',
        value: NameProjectionSelector.Atom
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Domain: [
      1,
      lib.getCodec(DomainIdProjectionSelector)
    ],
    Name: [
      2,
      lib.getCodec(NameProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link NftProjectionSelector}.
 */ export const NftProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Id: {
      Atom: Object.freeze({
        kind: 'Id',
        value: NftIdProjectionSelector.Atom
      }),
      Domain: {
        Atom: Object.freeze({
          kind: 'Id',
          value: NftIdProjectionSelector.Domain.Atom
        }),
        Name: {
          Atom: Object.freeze({
            kind: 'Id',
            value: NftIdProjectionSelector.Domain.Name.Atom
          })
        }
      },
      Name: {
        Atom: Object.freeze({
          kind: 'Id',
          value: NftIdProjectionSelector.Name.Atom
        })
      }
    },
    Metadata: {
      Atom: Object.freeze({
        kind: 'Metadata',
        value: MetadataProjectionSelector.Atom
      }),
      Key: (value)=>({
          kind: 'Metadata',
          value: MetadataProjectionSelector.Key(value)
        })
    },
    AccountId: {
      Atom: Object.freeze({
        kind: 'AccountId',
        value: AccountIdProjectionSelector.Atom
      }),
      Domain: {
        Atom: Object.freeze({
          kind: 'AccountId',
          value: AccountIdProjectionSelector.Domain.Atom
        }),
        Name: {
          Atom: Object.freeze({
            kind: 'AccountId',
            value: AccountIdProjectionSelector.Domain.Name.Atom
          })
        }
      },
      Signatory: {
        Atom: Object.freeze({
          kind: 'AccountId',
          value: AccountIdProjectionSelector.Signatory.Atom
        })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Id: [
      1,
      lib.getCodec(NftIdProjectionSelector)
    ],
    Metadata: [
      2,
      lib.getCodec(MetadataProjectionSelector)
    ],
    AccountId: [
      3,
      lib.getCodec(AccountIdProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec for {@link NumericPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const NumericPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec of the structure.
 */ export const SumeragiParameters = lib.defineCodec(lib.structCodec([
  'blockTime',
  'commitTime',
  'maxClockDrift'
], {
  blockTime: lib.getCodec(lib.Duration),
  commitTime: lib.getCodec(lib.Duration),
  maxClockDrift: lib.getCodec(lib.Duration)
}));
/**
 * Codec of the structure.
 */ export const TransactionParameters = lib.defineCodec(lib.structCodec([
  'maxInstructions',
  'smartContractSize'
], {
  maxInstructions: lib.NonZero.with(lib.getCodec(lib.U64)),
  smartContractSize: lib.NonZero.with(lib.getCodec(lib.U64))
}));
/**
 * Codec of the structure.
 */ export const SmartContractParameters = lib.defineCodec(lib.structCodec([
  'fuel',
  'memory'
], {
  fuel: lib.NonZero.with(lib.getCodec(lib.U64)),
  memory: lib.NonZero.with(lib.getCodec(lib.U64))
}));
/**
 * Codec of the structure.
 */ export const Parameters = lib.defineCodec(lib.structCodec([
  'sumeragi',
  'block',
  'transaction',
  'executor',
  'smartContract',
  'custom'
], {
  sumeragi: lib.getCodec(SumeragiParameters),
  block: lib.getCodec(BlockParameters),
  transaction: lib.getCodec(TransactionParameters),
  executor: lib.getCodec(SmartContractParameters),
  smartContract: lib.getCodec(SmartContractParameters),
  custom: lib.BTreeMap.with(lib.getCodec(CustomParameterId), lib.getCodec(CustomParameter))
}));
/**
 * Codec of the structure.
 */ export const Pagination = lib.defineCodec(lib.structCodec([
  'limit',
  'offset'
], {
  limit: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U64))),
  offset: lib.getCodec(lib.U64)
}));
/**
 * Codec of the structure.
 */ export const SocketAddrV4 = lib.defineCodec(lib.structCodec([
  'ip',
  'port'
], {
  ip: lib.getCodec(Ipv4Addr),
  port: lib.getCodec(lib.U16)
}));
/**
 * Codec of the structure.
 */ export const SocketAddrV6 = lib.defineCodec(lib.structCodec([
  'ip',
  'port'
], {
  ip: lib.getCodec(Ipv6Addr),
  port: lib.getCodec(lib.U16)
}));
/**
 * Codec of the structure.
 */ export const SocketAddrHost = lib.defineCodec(lib.structCodec([
  'host',
  'port'
], {
  host: lib.getCodec(lib.String),
  port: lib.getCodec(lib.U16)
}));
/**
 * Codec and constructors for enumeration {@link SocketAddr}.
 */ export const SocketAddr = {
  ...{
    Ipv4: (value)=>({
        kind: 'Ipv4',
        value
      }),
    Ipv6: (value)=>({
        kind: 'Ipv6',
        value
      }),
    Host: (value)=>({
        kind: 'Host',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Ipv4: [
      0,
      lib.getCodec(SocketAddrV4)
    ],
    Ipv6: [
      1,
      lib.getCodec(SocketAddrV6)
    ],
    Host: [
      2,
      lib.getCodec(SocketAddrHost)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const Peer = lib.defineCodec(lib.structCodec([
  'address',
  'id'
], {
  address: lib.getCodec(SocketAddr),
  id: lib.getCodec(PeerId)
}));
/**
 * Codec and constructors for enumeration {@link PeerIdProjectionSelector}.
 */ export const PeerIdProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    PublicKey: {
      Atom: Object.freeze({
        kind: 'PublicKey',
        value: PublicKeyProjectionSelector.Atom
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    PublicKey: [
      1,
      lib.getCodec(PublicKeyProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec for {@link PermissionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */ export const PermissionPredicateAtom = lib.defineCodec(lib.neverCodec);
/**
 * Codec and constructors for enumeration {@link PermissionProjectionSelector}.
 */ export const PermissionProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ]
  }).discriminated())
};
/**
 * Codec constructor for the structure with generic parameters.
 */ export const QueryWithFilter = {
  with: (t0, t1, t2)=>lib.structCodec([
      'query',
      'predicate',
      'selector'
    ], {
      query: t0,
      predicate: t1,
      selector: t2
    })
};
/**
 * Codec and constructors for enumeration {@link RoleIdProjectionSelector}.
 */ export const RoleIdProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Name: {
      Atom: Object.freeze({
        kind: 'Name',
        value: NameProjectionSelector.Atom
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Name: [
      1,
      lib.getCodec(NameProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link RoleProjectionSelector}.
 */ export const RoleProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Id: {
      Atom: Object.freeze({
        kind: 'Id',
        value: RoleIdProjectionSelector.Atom
      }),
      Name: {
        Atom: Object.freeze({
          kind: 'Id',
          value: RoleIdProjectionSelector.Name.Atom
        })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Id: [
      1,
      lib.getCodec(RoleIdProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TriggerIdProjectionSelector}.
 */ export const TriggerIdProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Name: {
      Atom: Object.freeze({
        kind: 'Name',
        value: NameProjectionSelector.Atom
      })
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Name: [
      1,
      lib.getCodec(NameProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link TriggerProjectionSelector}.
 */ export const TriggerProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Id: {
      Atom: Object.freeze({
        kind: 'Id',
        value: TriggerIdProjectionSelector.Atom
      }),
      Name: {
        Atom: Object.freeze({
          kind: 'Id',
          value: TriggerIdProjectionSelector.Name.Atom
        })
      }
    },
    Action: {
      Atom: Object.freeze({
        kind: 'Action',
        value: ActionProjectionSelector.Atom
      }),
      Metadata: {
        Atom: Object.freeze({
          kind: 'Action',
          value: ActionProjectionSelector.Metadata.Atom
        }),
        Key: (value)=>({
            kind: 'Action',
            value: ActionProjectionSelector.Metadata.Key(value)
          })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Id: [
      1,
      lib.getCodec(TriggerIdProjectionSelector)
    ],
    Action: [
      2,
      lib.getCodec(ActionProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link SignedBlockProjectionSelector}.
 */ export const SignedBlockProjectionSelector = {
  ...{
    Atom: Object.freeze({
      kind: 'Atom'
    }),
    Header: {
      Atom: Object.freeze({
        kind: 'Header',
        value: BlockHeaderProjectionSelector.Atom
      }),
      Hash: {
        Atom: Object.freeze({
          kind: 'Header',
          value: BlockHeaderProjectionSelector.Hash.Atom
        })
      }
    }
  },
  ...lib.defineCodec(lib.enumCodec({
    Atom: [
      0
    ],
    Header: [
      1,
      lib.getCodec(BlockHeaderProjectionSelector)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link QueryBox}.
 */ export const QueryBox = {
  ...{
    FindDomains: (value)=>({
        kind: 'FindDomains',
        value
      }),
    FindAccounts: (value)=>({
        kind: 'FindAccounts',
        value
      }),
    FindAssets: (value)=>({
        kind: 'FindAssets',
        value
      }),
    FindAssetsDefinitions: (value)=>({
        kind: 'FindAssetsDefinitions',
        value
      }),
    FindNfts: (value)=>({
        kind: 'FindNfts',
        value
      }),
    FindRoles: (value)=>({
        kind: 'FindRoles',
        value
      }),
    FindRoleIds: (value)=>({
        kind: 'FindRoleIds',
        value
      }),
    FindPermissionsByAccountId: (value)=>({
        kind: 'FindPermissionsByAccountId',
        value
      }),
    FindRolesByAccountId: (value)=>({
        kind: 'FindRolesByAccountId',
        value
      }),
    FindAccountsWithAsset: (value)=>({
        kind: 'FindAccountsWithAsset',
        value
      }),
    FindPeers: (value)=>({
        kind: 'FindPeers',
        value
      }),
    FindActiveTriggerIds: (value)=>({
        kind: 'FindActiveTriggerIds',
        value
      }),
    FindTriggers: (value)=>({
        kind: 'FindTriggers',
        value
      }),
    FindTransactions: (value)=>({
        kind: 'FindTransactions',
        value
      }),
    FindBlocks: (value)=>({
        kind: 'FindBlocks',
        value
      }),
    FindBlockHeaders: (value)=>({
        kind: 'FindBlockHeaders',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    FindDomains: [
      0,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(DomainProjectionPredicate)), lib.Vec.with(lib.getCodec(DomainProjectionSelector)))
    ],
    FindAccounts: [
      1,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(AccountProjectionPredicate)), lib.Vec.with(lib.getCodec(AccountProjectionSelector)))
    ],
    FindAssets: [
      2,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(AssetProjectionPredicate)), lib.Vec.with(lib.getCodec(AssetProjectionSelector)))
    ],
    FindAssetsDefinitions: [
      3,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(AssetDefinitionProjectionPredicate)), lib.Vec.with(lib.getCodec(AssetDefinitionProjectionSelector)))
    ],
    FindNfts: [
      4,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(NftProjectionPredicate)), lib.Vec.with(lib.getCodec(NftProjectionSelector)))
    ],
    FindRoles: [
      5,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(RoleProjectionPredicate)), lib.Vec.with(lib.getCodec(RoleProjectionSelector)))
    ],
    FindRoleIds: [
      6,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(RoleIdProjectionPredicate)), lib.Vec.with(lib.getCodec(RoleIdProjectionSelector)))
    ],
    FindPermissionsByAccountId: [
      7,
      QueryWithFilter.with(lib.getCodec(FindPermissionsByAccountId), lib.CompoundPredicate.with(lib.getCodec(PermissionProjectionPredicate)), lib.Vec.with(lib.getCodec(PermissionProjectionSelector)))
    ],
    FindRolesByAccountId: [
      8,
      QueryWithFilter.with(lib.getCodec(FindRolesByAccountId), lib.CompoundPredicate.with(lib.getCodec(RoleIdProjectionPredicate)), lib.Vec.with(lib.getCodec(RoleIdProjectionSelector)))
    ],
    FindAccountsWithAsset: [
      9,
      QueryWithFilter.with(lib.getCodec(FindAccountsWithAsset), lib.CompoundPredicate.with(lib.getCodec(AccountProjectionPredicate)), lib.Vec.with(lib.getCodec(AccountProjectionSelector)))
    ],
    FindPeers: [
      10,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(PeerIdProjectionPredicate)), lib.Vec.with(lib.getCodec(PeerIdProjectionSelector)))
    ],
    FindActiveTriggerIds: [
      11,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(TriggerIdProjectionPredicate)), lib.Vec.with(lib.getCodec(TriggerIdProjectionSelector)))
    ],
    FindTriggers: [
      12,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(TriggerProjectionPredicate)), lib.Vec.with(lib.getCodec(TriggerProjectionSelector)))
    ],
    FindTransactions: [
      13,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(CommittedTransactionProjectionPredicate)), lib.Vec.with(lib.getCodec(CommittedTransactionProjectionSelector)))
    ],
    FindBlocks: [
      14,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(SignedBlockProjectionPredicate)), lib.Vec.with(lib.getCodec(SignedBlockProjectionSelector)))
    ],
    FindBlockHeaders: [
      15,
      QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(BlockHeaderProjectionPredicate)), lib.Vec.with(lib.getCodec(BlockHeaderProjectionSelector)))
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link QueryOutputBatchBox}.
 */ export const QueryOutputBatchBox = {
  ...{
    PublicKey: (value)=>({
        kind: 'PublicKey',
        value
      }),
    String: (value)=>({
        kind: 'String',
        value
      }),
    Metadata: (value)=>({
        kind: 'Metadata',
        value
      }),
    Json: (value)=>({
        kind: 'Json',
        value
      }),
    Numeric: (value)=>({
        kind: 'Numeric',
        value
      }),
    Name: (value)=>({
        kind: 'Name',
        value
      }),
    DomainId: (value)=>({
        kind: 'DomainId',
        value
      }),
    Domain: (value)=>({
        kind: 'Domain',
        value
      }),
    AccountId: (value)=>({
        kind: 'AccountId',
        value
      }),
    Account: (value)=>({
        kind: 'Account',
        value
      }),
    AssetId: (value)=>({
        kind: 'AssetId',
        value
      }),
    Asset: (value)=>({
        kind: 'Asset',
        value
      }),
    AssetDefinitionId: (value)=>({
        kind: 'AssetDefinitionId',
        value
      }),
    AssetDefinition: (value)=>({
        kind: 'AssetDefinition',
        value
      }),
    NftId: (value)=>({
        kind: 'NftId',
        value
      }),
    Nft: (value)=>({
        kind: 'Nft',
        value
      }),
    Role: (value)=>({
        kind: 'Role',
        value
      }),
    Parameter: (value)=>({
        kind: 'Parameter',
        value
      }),
    Permission: (value)=>({
        kind: 'Permission',
        value
      }),
    CommittedTransaction: (value)=>({
        kind: 'CommittedTransaction',
        value
      }),
    SignedTransaction: (value)=>({
        kind: 'SignedTransaction',
        value
      }),
    TransactionHash: (value)=>({
        kind: 'TransactionHash',
        value
      }),
    TransactionRejectionReason: (value)=>({
        kind: 'TransactionRejectionReason',
        value
      }),
    Peer: (value)=>({
        kind: 'Peer',
        value
      }),
    RoleId: (value)=>({
        kind: 'RoleId',
        value
      }),
    TriggerId: (value)=>({
        kind: 'TriggerId',
        value
      }),
    Trigger: (value)=>({
        kind: 'Trigger',
        value
      }),
    Action: (value)=>({
        kind: 'Action',
        value
      }),
    Block: (value)=>({
        kind: 'Block',
        value
      }),
    BlockHeader: (value)=>({
        kind: 'BlockHeader',
        value
      }),
    BlockHeaderHash: (value)=>({
        kind: 'BlockHeaderHash',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    PublicKey: [
      0,
      lib.Vec.with(lib.getCodec(lib.PublicKey))
    ],
    String: [
      1,
      lib.Vec.with(lib.getCodec(lib.String))
    ],
    Metadata: [
      2,
      lib.Vec.with(lib.getCodec(Metadata))
    ],
    Json: [
      3,
      lib.Vec.with(lib.getCodec(lib.Json))
    ],
    Numeric: [
      4,
      lib.Vec.with(lib.getCodec(Numeric))
    ],
    Name: [
      5,
      lib.Vec.with(lib.getCodec(lib.Name))
    ],
    DomainId: [
      6,
      lib.Vec.with(lib.getCodec(lib.DomainId))
    ],
    Domain: [
      7,
      lib.Vec.with(lib.getCodec(Domain))
    ],
    AccountId: [
      8,
      lib.Vec.with(lib.getCodec(lib.AccountId))
    ],
    Account: [
      9,
      lib.Vec.with(lib.getCodec(Account))
    ],
    AssetId: [
      10,
      lib.Vec.with(lib.getCodec(lib.AssetId))
    ],
    Asset: [
      11,
      lib.Vec.with(lib.getCodec(Asset))
    ],
    AssetDefinitionId: [
      12,
      lib.Vec.with(lib.getCodec(lib.AssetDefinitionId))
    ],
    AssetDefinition: [
      13,
      lib.Vec.with(lib.getCodec(AssetDefinition))
    ],
    NftId: [
      14,
      lib.Vec.with(lib.getCodec(lib.NftId))
    ],
    Nft: [
      15,
      lib.Vec.with(lib.getCodec(Nft))
    ],
    Role: [
      16,
      lib.Vec.with(lib.getCodec(Role))
    ],
    Parameter: [
      17,
      lib.Vec.with(lib.getCodec(Parameter))
    ],
    Permission: [
      18,
      lib.Vec.with(lib.getCodec(Permission))
    ],
    CommittedTransaction: [
      19,
      lib.Vec.with(lib.getCodec(CommittedTransaction))
    ],
    SignedTransaction: [
      20,
      lib.Vec.with(lib.getCodec(SignedTransaction))
    ],
    TransactionHash: [
      21,
      lib.Vec.with(lib.getCodec(lib.Hash))
    ],
    TransactionRejectionReason: [
      22,
      lib.Vec.with(lib.Option.with(lib.getCodec(TransactionRejectionReason)))
    ],
    Peer: [
      23,
      lib.Vec.with(lib.getCodec(PeerId))
    ],
    RoleId: [
      24,
      lib.Vec.with(lib.getCodec(RoleId))
    ],
    TriggerId: [
      25,
      lib.Vec.with(lib.getCodec(TriggerId))
    ],
    Trigger: [
      26,
      lib.Vec.with(lib.getCodec(Trigger))
    ],
    Action: [
      27,
      lib.Vec.with(lib.getCodec(Action))
    ],
    Block: [
      28,
      lib.Vec.with(lib.getCodec(SignedBlock))
    ],
    BlockHeader: [
      29,
      lib.Vec.with(lib.getCodec(BlockHeader))
    ],
    BlockHeaderHash: [
      30,
      lib.Vec.with(lib.getCodec(lib.Hash))
    ]
  }).discriminated())
};
export const QueryOutputBatchBoxTuple = lib.defineCodec(lib.Vec.with(lib.getCodec(QueryOutputBatchBox)));
/**
 * Codec of the structure.
 */ export const QueryOutput = lib.defineCodec(lib.structCodec([
  'batch',
  'remainingItems',
  'continueCursor'
], {
  batch: lib.getCodec(QueryOutputBatchBoxTuple),
  remainingItems: lib.getCodec(lib.U64),
  continueCursor: lib.Option.with(lib.getCodec(ForwardCursor))
}));
/**
 * Codec of the structure.
 */ export const Sorting = lib.defineCodec(lib.structCodec([
  'sortByMetadataKey'
], {
  sortByMetadataKey: lib.Option.with(lib.getCodec(lib.Name))
}));
/**
 * Codec of the structure.
 */ export const QueryParams = lib.defineCodec(lib.structCodec([
  'pagination',
  'sorting',
  'fetchSize'
], {
  pagination: lib.getCodec(Pagination),
  sorting: lib.getCodec(Sorting),
  fetchSize: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U64)))
}));
/**
 * Codec and constructors for enumeration {@link SingularQueryBox}.
 */ export const SingularQueryBox = {
  ...{
    FindExecutorDataModel: Object.freeze({
      kind: 'FindExecutorDataModel'
    }),
    FindParameters: Object.freeze({
      kind: 'FindParameters'
    })
  },
  ...lib.defineCodec(lib.enumCodec({
    FindExecutorDataModel: [
      0
    ],
    FindParameters: [
      1
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const QueryWithParams = lib.defineCodec(lib.structCodec([
  'query',
  'params'
], {
  query: lib.getCodec(QueryBox),
  params: lib.getCodec(QueryParams)
}));
/**
 * Codec and constructors for enumeration {@link QueryRequest}.
 */ export const QueryRequest = {
  ...{
    Singular: {
      FindExecutorDataModel: Object.freeze({
        kind: 'Singular',
        value: SingularQueryBox.FindExecutorDataModel
      }),
      FindParameters: Object.freeze({
        kind: 'Singular',
        value: SingularQueryBox.FindParameters
      })
    },
    Start: (value)=>({
        kind: 'Start',
        value
      }),
    Continue: (value)=>({
        kind: 'Continue',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Singular: [
      0,
      lib.getCodec(SingularQueryBox)
    ],
    Start: [
      1,
      lib.getCodec(QueryWithParams)
    ],
    Continue: [
      2,
      lib.getCodec(ForwardCursor)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const QueryRequestWithAuthority = lib.defineCodec(lib.structCodec([
  'authority',
  'request'
], {
  authority: lib.getCodec(lib.AccountId),
  request: lib.getCodec(QueryRequest)
}));
/**
 * Codec and constructors for enumeration {@link SingularQueryOutputBox}.
 */ export const SingularQueryOutputBox = {
  ...{
    ExecutorDataModel: (value)=>({
        kind: 'ExecutorDataModel',
        value
      }),
    Parameters: (value)=>({
        kind: 'Parameters',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    ExecutorDataModel: [
      0,
      lib.getCodec(ExecutorDataModel)
    ],
    Parameters: [
      1,
      lib.getCodec(Parameters)
    ]
  }).discriminated())
};
/**
 * Codec and constructors for enumeration {@link QueryResponse}.
 */ export const QueryResponse = {
  ...{
    Singular: {
      ExecutorDataModel: (value)=>({
          kind: 'Singular',
          value: SingularQueryOutputBox.ExecutorDataModel(value)
        }),
      Parameters: (value)=>({
          kind: 'Singular',
          value: SingularQueryOutputBox.Parameters(value)
        })
    },
    Iterable: (value)=>({
        kind: 'Iterable',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    Singular: [
      0,
      lib.getCodec(SingularQueryOutputBox)
    ],
    Iterable: [
      1,
      lib.getCodec(QueryOutput)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const RawGenesisTransaction = lib.defineCodec(lib.structCodec([
  'chain',
  'executor',
  'parameters',
  'instructions',
  'wasmDir',
  'wasmTriggers',
  'topology'
], {
  chain: lib.getCodec(ChainId),
  executor: lib.getCodec(lib.String),
  parameters: lib.Option.with(lib.getCodec(Parameters)),
  instructions: lib.Vec.with(lib.lazyCodec(()=>lib.getCodec(InstructionBox))),
  wasmDir: lib.getCodec(lib.String),
  wasmTriggers: lib.Vec.with(lib.getCodec(GenesisWasmTrigger)),
  topology: lib.Vec.with(lib.getCodec(PeerId))
}));
/**
 * Codec of the structure.
 */ export const SignedQueryV1 = lib.defineCodec(lib.structCodec([
  'signature',
  'payload'
], {
  signature: lib.getCodec(lib.Signature),
  payload: lib.getCodec(QueryRequestWithAuthority)
}));
/**
 * Codec and constructors for enumeration {@link SignedQuery}.
 */ export const SignedQuery = {
  ...{
    V1: (value)=>({
        kind: 'V1',
        value
      })
  },
  ...lib.defineCodec(lib.enumCodec({
    V1: [
      1,
      lib.getCodec(SignedQueryV1)
    ]
  }).discriminated())
};
/**
 * Codec of the structure.
 */ export const Uptime = lib.defineCodec(lib.structCodec([
  'secs',
  'nanos'
], {
  secs: lib.getCodec(lib.Compact),
  nanos: lib.getCodec(lib.U32)
}));
/**
 * Codec of the structure.
 */ export const Status = lib.defineCodec(lib.structCodec([
  'peers',
  'blocks',
  'blocksNonEmpty',
  'txsApproved',
  'txsRejected',
  'uptime',
  'viewChanges',
  'queueSize'
], {
  peers: lib.getCodec(lib.Compact),
  blocks: lib.getCodec(lib.Compact),
  blocksNonEmpty: lib.getCodec(lib.Compact),
  txsApproved: lib.getCodec(lib.Compact),
  txsRejected: lib.getCodec(lib.Compact),
  uptime: lib.getCodec(Uptime),
  viewChanges: lib.getCodec(lib.Compact),
  queueSize: lib.getCodec(lib.Compact)
}));
//# sourceMappingURL=types.generated.js.map
import * as scale from "@scale-codec/core";
import { defineCodec, GenCodec, structCodec } from "../codec.js";
import { ordCompare } from "../traits.js";
import { toSortedSet } from "../util.js";
export const U8 = defineCodec(new GenCodec({
  encode: scale.encodeU8,
  decode: scale.decodeU8
}));
export const U16 = defineCodec(new GenCodec({
  encode: scale.encodeU16,
  decode: scale.decodeU16
}));
export const U32 = defineCodec(new GenCodec({
  encode: scale.encodeU32,
  decode: scale.decodeU32
}));
export const U64 = defineCodec(new GenCodec({
  encode: scale.encodeU64,
  decode: scale.decodeU64
}));
export const U128 = defineCodec(new GenCodec({
  encode: scale.encodeU128,
  decode: scale.decodeU128
}));
export const BytesVec = defineCodec(new GenCodec({
  encode: scale.encodeUint8Vec,
  decode: scale.decodeUint8Vec
}));
export const Bool = defineCodec(new GenCodec({
  encode: scale.encodeBool,
  decode: scale.decodeBool
}));
export const String = defineCodec(new GenCodec({
  encode: scale.encodeStr,
  decode: scale.decodeStr
}));
export const Compact = defineCodec(new GenCodec({
  encode: scale.encodeCompact,
  decode: scale.decodeCompact
}));
export class NonZero {
  static with(codec) {
    return codec.wrap({
      toBase: (x)=>x.value,
      fromBase: (x)=>new NonZero(x)
    });
  }
  _value;
  __brand;
  constructor(value){
    const isZero = typeof value === 'number' || typeof value === 'bigint' ? value === 0 : value.isZero();
    if (isZero) throw new TypeError(`Zero is passed to the NonZero constructor (${globalThis.String(value)})`);
    this._value = value;
  }
  get value() {
    return this._value;
  }
  map(fun) {
    return new NonZero(fun(this.value));
  }
  toJSON() {
    return this.value;
  }
}
export const Option = {
  with: (value)=>new GenCodec({
      encode: scale.createOptionEncoder(value.raw.encode),
      decode: scale.createOptionDecoder(value.raw.decode)
    }).wrap({
      fromBase: (base)=>base.tag === 'None' ? null : base.as('Some'),
      toBase: (higher)=>higher === null ? scale.variant('None') : scale.variant('Some', higher)
    })
};
export const Vec = {
  with: (item)=>{
    return new GenCodec({
      encode: scale.createVecEncoder(item.raw.encode),
      decode: scale.createVecDecoder(item.raw.decode)
    });
  }
};
/**
 * Codec factories for {@link BTreeSet:type}
 */ export const BTreeSet = {
  with (type) {
    return BTreeSet.withCmp(type, ordCompare);
  },
  withCmp (codec, compare) {
    return Vec.with(codec).wrap({
      toBase: (x)=>toSortedSet(x, compare),
      fromBase: (x)=>x
    });
  }
};
export const BTreeMap = {
  with: (key, value)=>{
    return BTreeMap.withCmp(key, value, (a, b)=>ordCompare(a.key, b.key));
  },
  withCmp: (key, value, compareFn)=>{
    const entry = structCodec([
      'key',
      'value'
    ], {
      key,
      value
    });
    return BTreeSet.withCmp(entry, (a, b)=>compareFn(a, b));
  }
};
//# sourceMappingURL=primitives.js.map
/**
 * [SCALE](https://docs.polkadot.com/polkadot-protocol/basics/data-encoding) codec utilities.
 *
 * These are mostly used internally, but you can use it in case you need to extend codec functionality.
 *
 * This module is mostly based on the [`@scale-codec/core`](https://www.npmjs.com/package/@scale-codec/core) package.
 *
 * @module
 */ import * as scale from "@scale-codec/core";
import { decodeHex } from "@jsr/std__encoding";
export const SYMBOL_CODEC = '$codec';
/**
 * Extracts codec from its container.
 */ export function getCodec(type) {
  return type[SYMBOL_CODEC];
}
/**
 * Wraps a codec into {@link CodecContainer}.
 */ export function defineCodec(codec) {
  return {
    [SYMBOL_CODEC]: codec
  };
}
/**
 * Generic codec.
 *
 * Unlike {@link RawScaleCodec}, provides higher-level encode/decode functions, as well as some composition utilities.
 */ export class GenCodec {
  /**
   * Create a lazy codec, by only having a getter to the actual codec.
   *
   * The getter is called for each codec access and is not cached.
   */ static lazy(f) {
    return new GenCodec({
      encode: scale.encodeFactory((v, w)=>f().raw.encode(v, w), (v)=>f().raw.encode.sizeHint(v)),
      decode: (w)=>f().raw.decode(w)
    });
  }
  /**
   * Access lower-level SCALE codec
   */ raw;
  constructor(raw){
    this.raw = raw;
  }
  encode(value) {
    return scale.WalkerImpl.encode(value, this.raw.encode);
  }
  decode(data) {
    const parsed = ArrayBuffer.isView(data) ? data : decodeHex(data);
    return scale.WalkerImpl.decode(parsed, this.raw.decode);
  }
  wrap({ toBase, fromBase }) {
    return new GenCodec({
      encode: scale.encodeFactory((v, w)=>this.raw.encode(toBase(v), w), (v)=>this.raw.encode.sizeHint(toBase(v))),
      decode: (w)=>fromBase(this.raw.decode(w))
    });
  }
}
export class EnumCodec extends GenCodec {
  discriminated() {
    return this.wrap({
      toBase: (value)=>{
        if (value.value !== undefined) return scale.variant(value.kind, value.value);
        return scale.variant(value.kind);
      },
      fromBase: (value)=>value.unit ? {
          kind: value.tag
        } : {
          kind: value.tag,
          value: value.content
        }
    });
  }
  literalUnion() {
    return this.wrap({
      toBase: (literal)=>scale.variant(literal),
      fromBase: (variant)=>variant.tag
    });
  }
}
export function lazyCodec(f) {
  return GenCodec.lazy(f);
}
export function enumCodec(schema) {
  const encoders = {};
  const decoders = {};
  for (const [tag, [dis, maybeCodec]] of Object.entries(schema)){
    ;
    encoders[tag] = maybeCodec ? [
      dis,
      maybeCodec.raw.encode
    ] : dis;
    decoders[dis] = maybeCodec ? [
      tag,
      maybeCodec.raw.decode
    ] : tag;
  }
  return new EnumCodec({
    encode: scale.createEnumEncoder(encoders),
    decode: scale.createEnumDecoder(decoders)
  });
}
export function tupleCodec(codecs) {
  return new GenCodec({
    encode: scale.createTupleEncoder(codecs.map((x)=>x.raw.encode)),
    decode: scale.createTupleDecoder(codecs.map((x)=>x.raw.decode))
  });
}
export function structCodec(order, schema) {
  const encoders = [];
  const decoders = [];
  for (const field of order){
    encoders.push([
      field,
      schema[field].raw.encode
    ]);
    decoders.push([
      field,
      schema[field].raw.decode
    ]);
  }
  return new GenCodec({
    encode: scale.createStructEncoder(encoders),
    decode: scale.createStructDecoder(decoders)
  });
}
const thisCodecShouldNeverBeCalled = ()=>{
  throw new Error('This value could never be encoded');
};
export const neverCodec = new GenCodec({
  encode: scale.encodeFactory(thisCodecShouldNeverBeCalled, thisCodecShouldNeverBeCalled),
  decode: thisCodecShouldNeverBeCalled
});
export const nullCodec = new GenCodec({
  encode: scale.encodeUnit,
  decode: scale.decodeUnit
});
export function bitmapCodec(masks) {
  const REPR_MAX = 2 ** 32 - 1;
  const toMask = (set)=>{
    let num = 0;
    for (const i of set){
      num |= masks[i];
    }
    return num;
  };
  const masksArray = Object.entries(masks).map(([k, v])=>({
      key: k,
      value: v
    }));
  const fromMask = (bitmask)=>{
    const set = new Set();
    let bitmaskMut = bitmask;
    for (const mask of masksArray){
      if ((mask.value & bitmaskMut) !== mask.value) continue;
      set.add(mask.key);
      let maskEffectiveBits = 0;
      for(let i = mask.value; i > 0; i >>= 1, maskEffectiveBits++);
      const fullNotMask = REPR_MAX >> maskEffectiveBits << maskEffectiveBits | ~mask.value;
      bitmaskMut &= fullNotMask;
    }
    if (bitmaskMut !== 0) {
      throw new Error(`Bitmask contains unknown flags: 0b${bitmaskMut.toString(2)}`);
    }
    return set;
  };
  return new GenCodec({
    encode: scale.encodeU32,
    decode: scale.decodeU32
  }).wrap({
    toBase: toMask,
    fromBase: fromMask
  });
}
//# sourceMappingURL=codec.js.map
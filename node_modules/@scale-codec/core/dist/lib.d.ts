/**
 * Core SCALE library with tools to encode to and decode SCALE binaries. It includes implementations for
 * primitive types as well as for complex types.
 *
 * @packageDocumentation
 */

import { Enumerate } from '@scale-codec/enum';
import { EnumOf } from '@scale-codec/enum';
import { EnumRecord } from '@scale-codec/enum';
import { RustOption } from '@scale-codec/enum';
import { RustResult } from '@scale-codec/enum';
import { Variant } from '@scale-codec/enum';
import { variant } from '@scale-codec/enum';
import { VariantAny } from '@scale-codec/enum';
import { VariantFactoryFn } from '@scale-codec/enum';
import { VariantToFactoryArgs } from '@scale-codec/enum';

/**
 * Set of integer types that are supported by codec for `bigint`
 */
export declare type BigIntTypes = IntTypes | `${'i' | 'u'}${64 | 128 | 256 | 512}`;

export declare function countPositiveBigIntEffectiveBytes(positiveNum: bigint): number;

export declare function createArrayDecoder<T>(decodeItem: Decode<T>, len: number): Decode<T[]>;

export declare function createArrayEncoder<T>(encodeItem: Encode<T>, len: number): Encode<T[]>;

export declare function createBigIntDecoder(ty: BigIntTypes): Decode<bigint>;

export declare function createBigIntEncoder(ty: BigIntTypes): Encode<bigint>;

export declare function createEnumDecoder<V extends VariantAny>(decoders: EnumDecoders<EnumOf<V>>): Decode<V>;

export declare function createEnumEncoder<V extends VariantAny>(encoders: EnumEncoders<EnumOf<V>>): Encode<V>;

export declare function createIntDecoder(ty: IntTypes): Decode<number>;

export declare function createIntEncoder(ty: IntTypes): Encode<number>;

export declare function createMapDecoder<K, V>(decodeKey: Decode<K>, decodeValue: Decode<V>): Decode<Map<K, V>>;

export declare function createMapEncoder<K, V>(encodeKey: Encode<K>, encodeValue: Encode<V>): Encode<Map<K, V>>;

export declare function createOptionDecoder<T>(decodeSome: Decode<T>): Decode<RustOption<T>>;

export declare function createOptionEncoder<T>(encodeSome: Encode<T>): Encode<RustOption<T>>;

export declare function createResultDecoder<Ok, Err>(decodeOk: Decode<Ok>, decodeErr: Decode<Err>): Decode<RustResult<Ok, Err>>;

export declare function createResultEncoder<Ok, Err>(encodeOk: Encode<Ok>, encodeErr: Encode<Err>): Encode<RustResult<Ok, Err>>;

export declare function createSetDecoder<T>(decodeItem: Decode<T>): Decode<Set<T>>;

export declare function createSetEncoder<T>(encodeItem: Encode<T>): Encode<Set<T>>;

export declare function createStructDecoder<T extends {}>(decoders: StructDecoders<T>): Decode<T>;

export declare function createStructEncoder<T extends {}>(encoders: StructEncoders<T>): Encode<T>;

export declare function createTupleDecoder<T extends any[]>(decoders: TupleDecoders<T>): Decode<T>;

export declare function createTupleEncoder<T extends any[]>(encoders: TupleEncoders<T>): Encode<T>;

export declare function createUint8ArrayDecoder(len: number): Decode<Uint8Array>;

export declare function createUint8ArrayEncoder(len: number): Encode<Uint8Array>;

export declare function createVecDecoder<T>(decodeItem: Decode<T>): Decode<T[]>;

export declare function createVecEncoder<T>(encodeItem: Encode<T>): Encode<T[]>;

export declare type Decode<T> = (walker: Walker) => T;

export declare function decodeArray<T>(walker: Walker, decodeItem: Decode<T>, len: number): T[];

/**
 * Decodes `bigint` in Little-Endian
 */
export declare function decodeBigInt(walker: Walker, ty: BigIntTypes): bigint;

/**
 * Decodes `bigint` in Little-Endian. It is like {@link decodeBigInt} but is not
 * binded to strict bytes count (1, 2, 4, 8, 16 etc)
 *
 * @remarks
 * Does not mutate walker's offset!
 */
export declare function decodeBigIntVarious(walker: Walker, bytes: number, signed: boolean): bigint;

export declare const decodeBool: Decode<boolean>;

/**
 * Decodes compact-encoded integer
 */
export declare function decodeCompact(walker: Walker): bigint;

export declare function decodeEnum<V extends VariantAny>(walker: Walker, decoders: EnumDecoders<EnumOf<V>>): V;

export declare const decodeI128: Decode<bigint>;

export declare const decodeI16: Decode<number>;

export declare const decodeI32: Decode<number>;

export declare const decodeI64: Decode<bigint>;

export declare const decodeI8: Decode<number>;

/**
 * Decodes signed/unsigned 8/16/32 bits integers in Little-Endian
 */
export declare function decodeInt(walker: Walker, ty: IntTypes): number;

export declare function decodeMap<K, V>(walker: Walker, decodeKey: Decode<K>, decodeValue: Decode<V>): Map<K, V>;

/**
 * Special decoder for `OptionBool` type from Rust's parity_scale_codec
 */
export declare const decodeOptionBool: Decode<RustOption<boolean>>;

export declare function decodeSet<T>(walker: Walker, decodeItem: Decode<T>): Set<T>;

export declare function decodeStr(walker: Walker): string;

export declare function decodeStruct<T extends {}>(walker: Walker, decoders: StructDecoders<T>): T;

declare type DecodeTuple<T extends string, V> = [tag: T, decode: Decode<V>];

export declare function decodeTuple<T extends any[]>(walker: Walker, decoders: TupleDecoders<T>): T;

export declare const decodeU128: Decode<bigint>;

export declare const decodeU16: Decode<number>;

export declare const decodeU32: Decode<number>;

export declare const decodeU64: Decode<bigint>;

export declare const decodeU8: Decode<number>;

/**
 * decode `[u8; x]` array directly into the native `Uint8Array`
 */
export declare function decodeUint8Array(walker: Walker, len: number): Uint8Array;

export declare const decodeUint8Vec: Decode<Uint8Array>;

/**
 * Decoder to handle unit type (i.e. `()`)
 */
export declare const decodeUnit: Decode<null>;

export declare function decodeVec<T>(walker: Walker, decodeItem: Decode<T>): T[];

export declare type Encode<T> = {
    (value: T, walker: Walker): void;
    sizeHint: (value: T) => number;
};

export declare function encodeArray<T>(arr: T[], encodeItem: Encode<T>, len: number, walker: Walker): void;

export declare function encodeArraySizeHint<T>(arr: T[], encodeItem: Encode<T>, len: number): number;

/**
 * Encodes `bigint` in Little-Endian
 */
export declare function encodeBigInt(bi: bigint, ty: BigIntTypes, walker: Walker): void;

export declare const encodeBool: Encode<boolean>;

export declare const encodeCompact: Encode<bigint | number>;

export declare function encodeEnum<V extends VariantAny>(value: V, encoders: EnumEncoders<EnumOf<V>>, walker: Walker): void;

export declare function encodeEnumSizeHint<V extends VariantAny>(value: V, encoders: EnumEncoders<EnumOf<V>>): number;

export declare function encodeFactory<T>(fn: (value: T, walker: Walker) => void, sizeHint: (value: T) => number): Encode<T>;

export declare const encodeI128: Encode<bigint>;

export declare const encodeI16: Encode<number>;

export declare const encodeI32: Encode<number>;

export declare const encodeI64: Encode<bigint>;

export declare const encodeI8: Encode<number>;

/**
 * Encodes signed/unsigned 8/16/32 bits integers in Little-Endian
 */
export declare function encodeInt(value: number, ty: IntTypes, walker: Walker): void;

export declare function encodeMap<K, V>(map: Map<K, V>, encodeKey: Encode<K>, encodeValue: Encode<V>, walker: Walker): void;

export declare function encodeMapSizeHint<K, V>(map: Map<K, V>, encodeKey: Encode<K>, encodeValue: Encode<V>): number;

/**
 * Special encoder for `OptionBool` type from Rust's parity_scale_codec
 */
export declare const encodeOptionBool: Encode<RustOption<boolean>>;

export declare function encodePositiveBigIntInto(positiveNum: bigint, mutSlice: Uint8Array, offset: number, bytesLimit: number): number;

export declare function encodeSet<T>(set: Set<T>, encodeItem: Encode<T>, walker: Walker): void;

export declare function encodeSetSizeHint<T>(set: Set<T>, encodeItem: Encode<T>): number;

export declare const encodeStr: Encode<string>;

export declare function encodeStruct<T extends {}>(struct: T, encoders: StructEncoders<T>, walker: Walker): void;

export declare function encodeStructSizeHint<T extends {}>(struct: T, encoders: StructEncoders<T>): number;

declare type EncodeTuple<V> = [discriminant: number, encode: Encode<V>];

export declare function encodeTuple<T extends any[]>(tuple: T, encoders: TupleEncoders<T>, walker: Walker): void;

export declare function encodeTupleSizeHint<T extends any[]>(tuple: T, encoders: TupleEncoders<T>): number;

export declare const encodeU128: Encode<bigint>;

export declare const encodeU16: Encode<number>;

export declare const encodeU32: Encode<number>;

export declare const encodeU64: Encode<bigint>;

export declare const encodeU8: Encode<number>;

/**
 * Encode to `[u8; x]` Rust's array directly from the native `Uint8Array`
 */
export declare function encodeUint8Array(value: Uint8Array, len: number, walker: Walker): void;

export declare const encodeUint8Vec: Encode<Uint8Array>;

/**
 * Encoder to handle unit type (i.e. `()`)
 */
export declare const encodeUnit: Encode<null>;

export declare function encodeVec<T>(vec: T[], encodeItem: Encode<T>, walker: Walker): void;

export declare function encodeVecSizeHint<T>(vec: T[], encodeItem: Encode<T>): number;

export declare type EnumDecoders<E extends EnumRecord> = {
    [D in number]: {
        [tag in keyof E]: E[tag] extends [infer C] ? DecodeTuple<tag & string, C> : tag & string;
    }[keyof E];
};

export declare class EnumEncodeError extends Error {
    constructor(message: string, encoders: EnumEncoders<any>);
}

export declare type EnumEncoders<E extends EnumRecord> = {
    [tag in keyof E]: E[tag] extends [infer C] ? EncodeTuple<C> : number;
};

export { Enumerate }

export { EnumOf }

export { EnumRecord }

/**
 * Set of integer types that are supported by codec for `number`
 */
export declare type IntTypes = `${'i' | 'u'}${8 | 16 | 32}`;

export { RustOption }

export { RustResult }

export declare class SliceWalkerFinalOffsetError extends Error {
    constructor(walker: Walker);
}

export declare type StructDecoders<T> = {
    [K in keyof T]: [K, Decode<T[K]>];
}[keyof T][];

export declare type StructEncoders<T> = {
    [K in keyof T]: [K, Encode<T[K]>];
}[keyof T][];

export declare type TupleDecoders<Tuple extends any[]> = Tuple extends [infer Head, ...infer Tail] ? [Decode<Head>, ...TupleDecoders<Tail>] : [];

export declare type TupleEncoders<Tuple extends any[]> = Tuple extends [infer Head, ...infer Tail] ? [Encode<Head>, ...TupleEncoders<Tail>] : [];

export { Variant }

export { variant }

export { VariantAny }

export { VariantFactoryFn }

export { VariantToFactoryArgs }

export declare interface Walker {
    u8: Uint8Array;
    view: DataView;
    idx: number;
}

export declare class WalkerImpl implements Walker {
    static encode<T>(value: T, encode: Encode<T>): Uint8Array;
    static decode<T>(source: ArrayBufferView, decode: Decode<T>): T;
    u8: Uint8Array;
    view: DataView;
    idx: number;
    constructor(source: ArrayBufferView);
    checkFinalOffset(): void;
    setOffset(value: number): this;
}

export { }

import { assert, fail } from "@jsr/std__assert";
import { Name } from "./data-model/compound.js";
export const QUERIES_WITH_PAYLOAD = new Set([
  'FindAccountsWithAsset',
  'FindPermissionsByAccountId',
  'FindRolesByAccountId'
]);
function funWithProps(props) {
  function noop() {}
  return Object.assign(noop, props);
}
function makePredicateBuilder() {
  return funWithProps({
    __props: []
  });
}
function predicateBuilderPushProp(value, prop) {
  return funWithProps({
    __props: [
      ...value.__props,
      prop
    ]
  });
}
function fixPropCase(prop) {
  return prop[0].toUpperCase() + prop.slice(1);
}
function predicateBuilderCall(value, args) {
  assert(value.__props.length);
  const arg = args.length === 0 ? null : args.length === 1 ? {
    some: args[0]
  } : fail('must be 0 or 1 args');
  if (value.__props.at(-1) === 'key' && arg && arg.some instanceof Name) {
    return {
      t: 'continue',
      value: funWithProps({
        __props: [
          ...value.__props,
          {
            t: 'metadata-key',
            key: arg.some
          }
        ]
      })
    };
  }
  const lastProp = value.__props.at(-1);
  assert(typeof lastProp === 'string');
  const lastPropFixed = fixPropCase(lastProp);
  let acc = arg ? {
    kind: lastPropFixed,
    value: arg.some
  } : {
    kind: lastPropFixed
  };
  acc = {
    kind: 'Atom',
    value: acc
  };
  for(let i = value.__props.length - 2; i >= 0; i--){
    const prop = value.__props[i];
    if (typeof prop === 'string') acc = {
      kind: fixPropCase(prop),
      value: acc
    };
    else if (prop.t === 'metadata-key') acc = {
      key: prop.key,
      projection: acc
    };
    else fail('unreachable');
  }
  return {
    t: 'final',
    value: acc
  };
}
function makePredicateBuilderProxy(builder) {
  return new Proxy(builder, {
    apply (target, _thisArg, args) {
      const ret = predicateBuilderCall(target, args);
      if (ret.t === 'continue') return makePredicateBuilderProxy(ret.value);
      return ret.value;
    },
    get (target, p) {
      assert(typeof p === 'string');
      return makePredicateBuilderProxy(predicateBuilderPushProp(target, p));
    }
  });
}
export function predicateProto() {
  return makePredicateBuilderProxy(makePredicateBuilder());
}
const selector = Symbol('actual-selector');
function makeSelectorBuilder() {
  return makePredicateBuilder();
}
function selectorBuilderPushProp(value, prop) {
  return predicateBuilderPushProp(value, prop);
}
function selectorBuilderCall(value, args) {
  assert(value.__props.at(-1) === 'key' && args.length === 1);
  const name = args[0];
  assert(name instanceof Name);
  return funWithProps({
    __props: [
      ...value.__props,
      {
        t: 'metadata-key',
        key: name
      }
    ]
  });
}
function buildSelector(builder) {
  let acc = {
    kind: 'Atom'
  };
  for(let i = builder.__props.length - 1; i >= 0; i--){
    const prop = builder.__props[i];
    if (typeof prop === 'string') acc = {
      kind: fixPropCase(prop),
      value: acc
    };
    else if (prop.t === 'metadata-key') acc = {
      key: prop.key,
      projection: acc
    };
    else fail('unreachable');
  }
  return acc;
}
function makeSelectorBuilderProxy(value) {
  return new Proxy(value, {
    get (target, p) {
      if (p === selector) return buildSelector(target);
      if (typeof p === 'string') {
        return makeSelectorBuilderProxy(selectorBuilderPushProp(target, p));
      }
    },
    apply (target, _thisArg, args) {
      return makeSelectorBuilderProxy(selectorBuilderCall(target, args));
    }
  });
}
export function selectorProto() {
  return makeSelectorBuilderProxy(makeSelectorBuilder());
}
export function getActualSelector(builder) {
  if (typeof builder === 'function' && '__props' in builder) {
    return builder[selector];
  }
  throw new TypeError('Expected a magical selector builder type, got something else; make sure you are using `.selectWith()` properly.');
}
//# sourceMappingURL=query-internal.js.map
import * as crypto from "../crypto/mod.js";
import type { JsonValue } from "type-fest";
import { type GenCodec, SYMBOL_CODEC } from "../codec.js";
import { type IsZero, type Ord } from "../traits.js";
import type { Variant } from "../util.js";
import { U64 } from "./primitives.js";
export declare class Json<T extends JsonValue = JsonValue> implements Ord<Json> {
  public static [SYMBOL_CODEC]: GenCodec<Json<JsonValue>>;
  public static fromValue<T extends JsonValue>(value: T): Json<T>;
  public static fromJsonString<T extends JsonValue = JsonValue>(value: string): Json<T>;
  private _value: any;
  private _str: any;
  public constructor(asValue: null | {
    some: T;
  }, asString: string | null);
  public asValue(): T;
  public asJsonString(): string;
  /**
   * For {@link JSON} integration
   */ public toJSON(): T;
  public compare(that: Json): number;
}
export declare class Timestamp {
  public static [SYMBOL_CODEC]: GenCodec<Timestamp>;
  public static fromDate(value: Date): Timestamp;
  public static fromMillis(value: number | bigint | U64): Timestamp;
  public static now(): Timestamp;
  private _ms: any;
  public constructor(milliseconds: U64);
  public asDate(): Date;
  public asMillis(): U64;
  public toJSON(): string;
}
export { Timestamp as TimestampU128 };
/**
 * Convenience wrapper around `u64` numbers representing durations.
 */ export declare class Duration implements IsZero {
  public static [SYMBOL_CODEC]: GenCodec<Duration>;
  public static fromMillis(ms: number | bigint): Duration;
  private readonly _ms: any;
  protected constructor(ms: bigint);
  public asMillis(): bigint;
  public isZero(): boolean;
  public toJSON(): {
    ms: bigint;
  };
}
/**
 * Convenience wrapper around `Compact` integers representing durations.
 */ export declare class DurationCompact implements IsZero {
  public static [SYMBOL_CODEC]: GenCodec<DurationCompact>;
  public static fromMillis(ms: number | bigint): DurationCompact;
  private readonly _ms: any;
  protected constructor(ms: bigint);
  public asMillis(): bigint;
  public isZero(): boolean;
  public toJSON(): {
    ms: bigint;
  };
}
export type CompoundPredicate<Atom> = Variant<'Atom', Atom> | Variant<'Not', CompoundPredicate<Atom>> | Variant<'And' | 'Or', CompoundPredicate<Atom>[]>;
export declare const CompoundPredicate: {
  with<T>(atom: GenCodec<T>): GenCodec<CompoundPredicate<T>>;
  /**
   * Predicate that always passes.
   *
   * It is simply the `And` variant with no predicates, which is always True (same logic as for {@link Array.prototype.every}).
   */ PASS: Variant<'And', never[]>;
  /**
   * Predicate that always fails.
   *
   * It is simply the `Or` variant with no predicates, which is always False (same logic as for {@link Array.prototype.some}).
   */ FAIL: Variant<'Or', never[]>;
  Atom<T>(value: T): CompoundPredicate<T>;
  Not<T>(predicate: CompoundPredicate<T>): CompoundPredicate<T>;
  And<T>(...predicates: CompoundPredicate<T>[]): CompoundPredicate<T>;
  Or<T>(...predicates: CompoundPredicate<T>[]): CompoundPredicate<T>;
};
/**
 * Name is a simple wrap around string that ensures that it
 * doesn't contain whitespaces characters, `@`, and `#`.
 *
 * @example
 * ```ts
 * import { assertEquals, assertThrows } from '@std/assert'
 *
 * const name1 = new Name('alice')
 * assertEquals(name1.value, 'alice')
 *
 * assertThrows(() => new Name('alice and bob')) // Error: whitespace characters.
 * ```
 */ export declare class Name implements Ord<Name> {
  public static [SYMBOL_CODEC]: GenCodec<Name>;
  private _brand: any;
  private _value: any;
  public constructor(name: string);
  public get value(): string;
  public toJSON(): string;
  public compare(other: Name): number;
}
export type DomainId = Name;
export declare const DomainId: any;
export declare class AccountId implements Ord<AccountId> {
  public static [SYMBOL_CODEC]: GenCodec<AccountId>;
  /**
   * Parses account id from a string in a form of `<signature>@<domain>`.
   *
   * Throws an error if the string is not a valid account id.
   */ public static parse(str: string): AccountId;
  public readonly signatory: crypto.PublicKey;
  public readonly domain: DomainId;
  private __brand: any;
  public constructor(signatory: crypto.PublicKey, domain: DomainId);
  public toJSON(): string;
  /**
   * String representation of an account id, as described in {@link AccountId.parse}.
   */ public toString(): string;
  public compare(that: AccountId): number;
}
export declare class AssetDefinitionId {
  public static [SYMBOL_CODEC]: GenCodec<AssetDefinitionId>;
  /**
   * Parse an asset definition id from a string representation in a form of `<name>@<domain>`.
   *
   * Throws an error if the string is invalid asset definition id.
   */ public static parse(str: string): AssetDefinitionId;
  public readonly name: Name;
  public readonly domain: DomainId;
  private __brand: any;
  public constructor(name: Name, domain: DomainId);
  /**
   * String representation, as described in {@link AssetDefinitionId.parse}
   */ public toString(): string;
  public toJSON(): string;
}
export declare class AssetId {
  public static [SYMBOL_CODEC]: GenCodec<AssetId>;
  /**
   * Parses an asset id from its string representation in a form of either
   *
   * - `<asset>#<domain>#<signatory>@<domain>`
   * - `<asset>##<signatory>@<domain>` (when domains are the same)
   *
   * Throws an error if the string is invalid asset id.
   */ public static parse(str: string): AssetId;
  public readonly account: AccountId;
  public readonly definition: AssetDefinitionId;
  private __brand: any;
  public constructor(account: AccountId, definition: AssetDefinitionId);
  /**
   * Produce a stringified ID, see {@link parse}.
   */ public toString(): string;
  public toJSON(): string;
}
/**
 * Identification of Non-Fungible Token (asset).
 */ export declare class NftId {
  public static [SYMBOL_CODEC]: GenCodec<NftId>;
  /**
   * Parse NFT ID from its string representation.
   *
   * @example
   * ```ts
   * import { assertEquals } from '@std/assert'
   *
   * const id = NftId.parse('nft$domain')
   *
   * assertEquals(id.name.value, 'nft')
   * assertEquals(id.domain.value, 'domain')
   * ```
   */ public static parse(str: string): NftId;
  public readonly domain: DomainId;
  public readonly name: Name;
  private __brand: any;
  public constructor(name: Name, domain: DomainId);
  /**
   * Returns string representation of NFT ID.
   *
   * @example
   * ```ts
   * import { assertEquals } from '@std/assert'
   *
   * const id = new NftId(new Name('nft'), new DomainId('domain'))
   *
   * assertEquals(id.toString(), 'nft$domain')
   * ```
   */ public toString(): string;
  public toJSON(): string;
}
//# sourceMappingURL=compound.d.ts.map
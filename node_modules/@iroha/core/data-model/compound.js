import * as crypto from "../crypto/mod.js";
import { enumCodec, getCodec, lazyCodec, structCodec, SYMBOL_CODEC } from "../codec.js";
import { ordCompare } from "../traits.js";
import { Compact, String, U64, Vec } from "./primitives.js";
// TODO document that parse/stringify json lazily when needed
export class Json {
  static [SYMBOL_CODEC] = getCodec(String).wrap({
    toBase: (x)=>x.asJsonString(),
    fromBase: (str)=>Json.fromJsonString(str)
  });
  static fromValue(value) {
    return new Json({
      some: value
    }, null);
  }
  static fromJsonString(value) {
    if (!value) throw new Error('JSON string cannot be empty');
    return new Json(null, value);
  }
  _value;
  _str;
  constructor(asValue, asString){
    this._value = asValue;
    this._str = asString;
  }
  asValue() {
    if (!this._value) {
      this._value = {
        some: JSON.parse(this._str)
      };
    }
    return this._value.some;
  }
  asJsonString() {
    if (typeof this._str !== 'string') {
      this._str = JSON.stringify(this._value.some);
    }
    return this._str;
  }
  /**
   * For {@link JSON} integration
   */ toJSON() {
    return this.asValue();
  }
  compare(that) {
    return ordCompare(this.asJsonString(), that.asJsonString());
  }
}
export class Timestamp {
  static [SYMBOL_CODEC] = getCodec(U64).wrap({
    toBase: (x)=>x.asMillis(),
    fromBase: (x)=>Timestamp.fromMillis(x)
  });
  static fromDate(value) {
    return new Timestamp(BigInt(value.getTime()));
  }
  static fromMillis(value) {
    return new Timestamp(BigInt(value));
  }
  static now() {
    return new Timestamp(BigInt(Date.now()));
  }
  _ms;
  constructor(milliseconds){
    this._ms = milliseconds;
  }
  asDate() {
    // TODO check correct bounds
    return new Date(Number(this._ms));
  }
  asMillis() {
    return this._ms;
  }
  toJSON() {
    return this.asDate().toISOString();
  }
}
export { Timestamp as TimestampU128 };
/**
 * Convenience wrapper around `u64` numbers representing durations.
 */ export class Duration {
  static [SYMBOL_CODEC] = getCodec(U64).wrap({
    fromBase: (x)=>Duration.fromMillis(x),
    toBase: (y)=>y.asMillis()
  });
  static fromMillis(ms) {
    return new Duration(BigInt(ms));
  }
  _ms;
  constructor(ms){
    if (ms < 0n) throw new TypeError(`Duration could not be negative, got: ${ms}`);
    this._ms = ms;
  }
  asMillis() {
    return this._ms;
  }
  isZero() {
    return this._ms === 0n;
  }
  toJSON() {
    return {
      ms: this._ms
    };
  }
}
/**
 * Convenience wrapper around `Compact` integers representing durations.
 */ export class DurationCompact {
  static [SYMBOL_CODEC] = getCodec(Compact).wrap({
    fromBase: (x)=>DurationCompact.fromMillis(x),
    toBase: (y)=>y.asMillis()
  });
  static fromMillis(ms) {
    return new DurationCompact(BigInt(ms));
  }
  _ms;
  constructor(ms){
    if (ms < 0n) throw new TypeError(`Duration could not be negative, got: ${ms}`);
    this._ms = ms;
  }
  asMillis() {
    return this._ms;
  }
  isZero() {
    return this._ms === 0n;
  }
  toJSON() {
    return {
      ms: this._ms
    };
  }
}
export const CompoundPredicate = {
  // TODO: freeze `value: []` too?
  PASS: Object.freeze({
    kind: 'And',
    value: []
  }),
  FAIL: Object.freeze({
    kind: 'Or',
    value: []
  }),
  Atom: (value)=>({
      kind: 'Atom',
      value
    }),
  Not: (predicate)=>({
      kind: 'Not',
      value: predicate
    }),
  And: (...predicates)=>({
      kind: 'And',
      value: predicates
    }),
  Or: (...predicates)=>({
      kind: 'Or',
      value: predicates
    }),
  with: (atomType)=>{
    const lazySelf = lazyCodec(()=>codec);
    const codec = enumCodec({
      // magic discriminants from schema
      Atom: [
        0,
        atomType
      ],
      Not: [
        1,
        lazySelf
      ],
      And: [
        2,
        Vec.with(lazySelf)
      ],
      Or: [
        3,
        Vec.with(lazySelf)
      ]
    }).discriminated();
    return codec;
  }
};
/**
 * Name is a simple wrap around string that ensures that it
 * doesn't contain whitespaces characters, `@`, and `#`.
 *
 * @example
 * ```ts
 * import { assertEquals, assertThrows } from '@std/assert'
 *
 * const name1 = new Name('alice')
 * assertEquals(name1.value, 'alice')
 *
 * assertThrows(() => new Name('alice and bob')) // Error: whitespace characters.
 * ```
 */ export class Name {
  static [SYMBOL_CODEC] = getCodec(String).wrap({
    toBase: (x)=>x.value,
    fromBase: (x)=>new Name(x)
  });
  _brand;
  _value;
  constructor(name){
    if (!name.length) throw new SyntaxError(`Name should not be empty`);
    if (/[\s#@]/.test(name)) {
      throw new SyntaxError(`Invalid name: "${name}". Name should not contain whitespace characters, ` + `"@" (reserved for "⟨signatory⟩@⟨domain⟩" constructs, e.g. "ed....@wonderland"), ` + `and "#" (reserved for "⟨asset⟩#⟨domain⟩" constructs, e.g. "rose#wonderland") `);
    }
    this._value = name;
  }
  get value() {
    return this._value;
  }
  toJSON() {
    return this.value;
  }
  compare(other) {
    return this.value > other.value ? 1 : this.value < other.value ? -1 : 0;
  }
}
export const DomainId = Name;
export class AccountId {
  static [SYMBOL_CODEC] = structCodec([
    'domain',
    'signatory'
  ], {
    domain: getCodec(DomainId),
    signatory: getCodec(crypto.PublicKey)
  }).wrap({
    fromBase: (x)=>new AccountId(x.signatory, x.domain),
    toBase: (x)=>x
  });
  /**
   * Parses account id from a string in a form of `<signature>@<domain>`.
   *
   * Throws an error if the string is not a valid account id.
   */ static parse(str) {
    return accountIdFromStr(str);
  }
  signatory;
  domain;
  __brand;
  constructor(signatory, domain){
    this.signatory = signatory;
    this.domain = domain;
  }
  toJSON() {
    return this.toString();
  }
  /**
   * String representation of an account id, as described in {@link AccountId.parse}.
   */ toString() {
    return `${this.signatory.multihash()}@${this.domain.value}`;
  }
  compare(that) {
    const domains = ordCompare(this.domain, that.domain);
    if (domains !== 0) return domains;
    return ordCompare(this.signatory, that.signatory);
  }
}
function accountIdFromObj({ signatory, domain }) {
  return new AccountId(crypto.PublicKey.fromMultihash(signatory), new Name(domain));
}
function accountIdFromStr(str) {
  const parts = str.split('@');
  if (parts.length !== 2) {
    throw new SyntaxError(`AccountId should have format "⟨signatory⟩@⟨domain⟩", got: "${str}"`);
  }
  const [signatory, domain] = parts;
  return accountIdFromObj({
    signatory,
    domain
  });
}
export class AssetDefinitionId {
  static [SYMBOL_CODEC] = structCodec([
    'domain',
    'name'
  ], {
    domain: getCodec(DomainId),
    name: getCodec(Name)
  }).wrap({
    toBase: (higher)=>higher,
    fromBase: (lower)=>new AssetDefinitionId(lower.name, lower.domain)
  });
  /**
   * Parse an asset definition id from a string representation in a form of `<name>@<domain>`.
   *
   * Throws an error if the string is invalid asset definition id.
   */ static parse(str) {
    return assetDefIdFromStr(str);
  }
  name;
  domain;
  __brand;
  constructor(name, domain){
    this.name = name;
    this.domain = domain;
  }
  /**
   * String representation, as described in {@link AssetDefinitionId.parse}
   */ toString() {
    return `${this.name.value}#${this.domain.value}`;
  }
  toJSON() {
    return this.toString();
  }
}
function assetDefIdFromObj({ name, domain }) {
  return new AssetDefinitionId(new Name(name), new Name(domain));
}
function assetDefIdFromStr(input) {
  const parts = input.split('#');
  if (parts.length !== 2) {
    throw new SyntaxError(`AssetDefinitionId should have format "⟨name⟩#⟨domain⟩", e.g. "rose#wonderland", got "${input}"`);
  }
  const [name, domain] = parts;
  return assetDefIdFromObj({
    name,
    domain
  });
}
export class AssetId {
  static [SYMBOL_CODEC] = structCodec([
    'account',
    'definition'
  ], {
    account: getCodec(AccountId),
    definition: getCodec(AssetDefinitionId)
  }).wrap({
    toBase: (higher)=>higher,
    fromBase: (lower)=>new AssetId(lower.account, lower.definition)
  });
  /**
   * Parses an asset id from its string representation in a form of either
   *
   * - `<asset>#<domain>#<signatory>@<domain>`
   * - `<asset>##<signatory>@<domain>` (when domains are the same)
   *
   * Throws an error if the string is invalid asset id.
   */ static parse(str) {
    return assetIdFromStr(str);
  }
  account;
  definition;
  __brand;
  constructor(account, definition){
    this.account = account;
    this.definition = definition;
  }
  /**
   * Produce a stringified ID, see {@link parse}.
   */ toString() {
    return this.account.domain.value === this.definition.domain.value ? `${this.definition.name.value}##${this.account.toString()}` : `${this.definition.toString()}#${this.account.toString()}`;
  }
  toJSON() {
    return this.toString();
  }
}
function assetIdFromStr(input) {
  const match = input.match(/^(.+)#(.+)?#(.+)@(.+)$/);
  if (!match) {
    throw new SyntaxError(`AssetId should have format "⟨name⟩#⟨asset domain⟩#⟨account signatory⟩@⟨account domain⟩" ` + `or "⟨name⟩##⟨account signatory⟩@⟨account domain⟩" (when asset and account domains are the same), got "${input}"`);
  }
  const [, asset, domain1, account, domain2] = match;
  return new AssetId(accountIdFromObj({
    signatory: account,
    domain: domain2
  }), assetDefIdFromObj({
    name: asset,
    domain: domain1 ?? domain2
  }));
}
/**
 * Identification of Non-Fungible Token (asset).
 */ export class NftId {
  static [SYMBOL_CODEC] = structCodec([
    'domain',
    'name'
  ], {
    domain: getCodec(DomainId),
    name: getCodec(Name)
  }).wrap({
    toBase: (x)=>x,
    fromBase: (x)=>new NftId(x.name, x.domain)
  });
  /**
   * Parse NFT ID from its string representation.
   *
   * @example
   * ```ts
   * import { assertEquals } from '@std/assert'
   *
   * const id = NftId.parse('nft$domain')
   *
   * assertEquals(id.name.value, 'nft')
   * assertEquals(id.domain.value, 'domain')
   * ```
   */ static parse(str) {
    const parts = str.split('$');
    if (parts.length !== 2) {
      throw new SyntaxError(`NfdId should have format "⟨name⟩$⟨domain⟩", e.g. "nft$domain", got "${str}"`);
    }
    const [name, domain] = parts;
    return new NftId(new Name(name), new DomainId(domain));
  }
  domain;
  name;
  __brand;
  constructor(name, domain){
    this.domain = domain;
    this.name = name;
  }
  /**
   * Returns string representation of NFT ID.
   *
   * @example
   * ```ts
   * import { assertEquals } from '@std/assert'
   *
   * const id = new NftId(new Name('nft'), new DomainId('domain'))
   *
   * assertEquals(id.toString(), 'nft$domain')
   * ```
   */ toString() {
    return `${this.name.value}$${this.domain.value}`;
  }
  toJSON() {
    return this.toString();
  }
}
//# sourceMappingURL=compound.js.map
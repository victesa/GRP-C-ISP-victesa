import * as lib from './types.generated.prelude.js'

export type Metadata = lib.BTreeMap<lib.Name, lib.Json>
export const Metadata: lib.CodecContainer<Metadata> = lib.defineCodec(lib.BTreeMap.with(lib.getCodec(lib.Name), lib.getCodec(lib.Json)))

/**
 * Structure with named fields.
 */
export interface Account { id: lib.AccountId, metadata: Metadata }
/**
 * Codec of the structure.
 */
export const Account: lib.CodecContainer<Account> = lib.defineCodec(lib.structCodec<Account>(['id', 'metadata'], {id: lib.getCodec(lib.AccountId), metadata: lib.getCodec(Metadata)}))

/**
 * Structure with named fields.
 */
export interface Numeric { mantissa: lib.Compact, scale: lib.Compact }
/**
 * Codec of the structure.
 */
export const Numeric: lib.CodecContainer<Numeric> = lib.defineCodec(lib.structCodec<Numeric>(['mantissa', 'scale'], {mantissa: lib.getCodec(lib.Compact), scale: lib.getCodec(lib.Compact)}))

/**
 * Structure with named fields.
 */
export interface Asset { id: lib.AssetId, value: Numeric }
/**
 * Codec of the structure.
 */
export const Asset: lib.CodecContainer<Asset> = lib.defineCodec(lib.structCodec<Asset>(['id', 'value'], {id: lib.getCodec(lib.AssetId), value: lib.getCodec(Numeric)}))

/**
 * Structure with named fields.
 */
export interface AssetChanged { asset: lib.AssetId, amount: Numeric }
/**
 * Codec of the structure.
 */
export const AssetChanged: lib.CodecContainer<AssetChanged> = lib.defineCodec(lib.structCodec<AssetChanged>(['asset', 'amount'], {asset: lib.getCodec(lib.AssetId), amount: lib.getCodec(Numeric)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `Added`
 * - `Removed`
 * 
 * TODO how to construct, how to use
 */
export type AssetEvent = lib.Variant<'Created', Asset> | lib.Variant<'Deleted', lib.AssetId> | lib.Variant<'Added', AssetChanged> | lib.Variant<'Removed', AssetChanged>
/**
 * Codec and constructors for enumeration {@link AssetEvent}.
 */
export const AssetEvent: lib.CodecContainer<AssetEvent> & { Created: <const T extends Asset>(value: T) => lib.Variant<'Created', T>, Deleted: <const T extends lib.AssetId>(value: T) => lib.Variant<'Deleted', T>, Added: <const T extends AssetChanged>(value: T) => lib.Variant<'Added', T>, Removed: <const T extends AssetChanged>(value: T) => lib.Variant<'Removed', T> } = { ...{ Created: <const T extends Asset>(value: T): lib.Variant<'Created', T> => ({ kind: 'Created', value }), Deleted: <const T extends lib.AssetId>(value: T): lib.Variant<'Deleted', T> => ({ kind: 'Deleted', value }), Added: <const T extends AssetChanged>(value: T): lib.Variant<'Added', T> => ({ kind: 'Added', value }), Removed: <const T extends AssetChanged>(value: T): lib.Variant<'Removed', T> => ({ kind: 'Removed', value }) }, ...lib.defineCodec(lib.enumCodec<{ Created: [Asset], Deleted: [lib.AssetId], Added: [AssetChanged], Removed: [AssetChanged] }>({ Created: [0, lib.getCodec(Asset)], Deleted: [1, lib.getCodec(lib.AssetId)], Added: [2, lib.getCodec(AssetChanged)], Removed: [3, lib.getCodec(AssetChanged)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface Permission { name: lib.String, payload: lib.Json }
/**
 * Codec of the structure.
 */
export const Permission: lib.CodecContainer<Permission> = lib.defineCodec(lib.structCodec<Permission>(['name', 'payload'], {name: lib.getCodec(lib.String), payload: lib.getCodec(lib.Json)}))

/**
 * Structure with named fields.
 */
export interface AccountPermissionChanged { account: lib.AccountId, permission: Permission }
/**
 * Codec of the structure.
 */
export const AccountPermissionChanged: lib.CodecContainer<AccountPermissionChanged> = lib.defineCodec(lib.structCodec<AccountPermissionChanged>(['account', 'permission'], {account: lib.getCodec(lib.AccountId), permission: lib.getCodec(Permission)}))

export type RoleId = lib.Name
export const RoleId = lib.Name

/**
 * Structure with named fields.
 */
export interface AccountRoleChanged { account: lib.AccountId, role: RoleId }
/**
 * Codec of the structure.
 */
export const AccountRoleChanged: lib.CodecContainer<AccountRoleChanged> = lib.defineCodec(lib.structCodec<AccountRoleChanged>(['account', 'role'], {account: lib.getCodec(lib.AccountId), role: lib.getCodec(RoleId)}))

/**
 * Structure with named fields and generic parameters.
 */
export interface MetadataChanged<T0> { target: T0, key: lib.Name, value: lib.Json }
/**
 * Codec constructor for the structure with generic parameters.
 */
export const MetadataChanged = { /**
 * Create a codec with the actual codecs for generic parameters.
 */
with: <T0>(t0: lib.GenCodec<T0>): lib.GenCodec<MetadataChanged<T0>> => lib.structCodec<MetadataChanged<T0>>(['target', 'key', 'value'], {target: t0, key: lib.getCodec(lib.Name), value: lib.getCodec(lib.Json)}) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `Asset`
 * - `PermissionAdded`
 * - `PermissionRemoved`
 * - `RoleGranted`
 * - `RoleRevoked`
 * - `MetadataInserted`
 * - `MetadataRemoved`
 * 
 * TODO how to construct, how to use
 */
export type AccountEvent = lib.Variant<'Created', Account> | lib.Variant<'Deleted', lib.AccountId> | lib.Variant<'Asset', AssetEvent> | lib.Variant<'PermissionAdded', AccountPermissionChanged> | lib.Variant<'PermissionRemoved', AccountPermissionChanged> | lib.Variant<'RoleGranted', AccountRoleChanged> | lib.Variant<'RoleRevoked', AccountRoleChanged> | lib.Variant<'MetadataInserted', MetadataChanged<lib.AccountId>> | lib.Variant<'MetadataRemoved', MetadataChanged<lib.AccountId>>
/**
 * Codec and constructors for enumeration {@link AccountEvent}.
 */
export const AccountEvent: lib.CodecContainer<AccountEvent> & { Created: <const T extends Account>(value: T) => lib.Variant<'Created', T>, Deleted: <const T extends lib.AccountId>(value: T) => lib.Variant<'Deleted', T>, Asset: { Created: <const T extends Asset>(value: T) => lib.Variant<'Asset', lib.Variant<'Created', T>>, Deleted: <const T extends lib.AssetId>(value: T) => lib.Variant<'Asset', lib.Variant<'Deleted', T>>, Added: <const T extends AssetChanged>(value: T) => lib.Variant<'Asset', lib.Variant<'Added', T>>, Removed: <const T extends AssetChanged>(value: T) => lib.Variant<'Asset', lib.Variant<'Removed', T>> }, PermissionAdded: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'PermissionAdded', T>, PermissionRemoved: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'PermissionRemoved', T>, RoleGranted: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'RoleGranted', T>, RoleRevoked: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'RoleRevoked', T>, MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'MetadataInserted', T>, MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'MetadataRemoved', T> } = { ...{ Created: <const T extends Account>(value: T): lib.Variant<'Created', T> => ({ kind: 'Created', value }), Deleted: <const T extends lib.AccountId>(value: T): lib.Variant<'Deleted', T> => ({ kind: 'Deleted', value }), Asset: { Created: <const T extends Asset>(value: T): lib.Variant<'Asset', lib.Variant<'Created', T>> => ({ kind: 'Asset', value: AssetEvent.Created(value) }), Deleted: <const T extends lib.AssetId>(value: T): lib.Variant<'Asset', lib.Variant<'Deleted', T>> => ({ kind: 'Asset', value: AssetEvent.Deleted(value) }), Added: <const T extends AssetChanged>(value: T): lib.Variant<'Asset', lib.Variant<'Added', T>> => ({ kind: 'Asset', value: AssetEvent.Added(value) }), Removed: <const T extends AssetChanged>(value: T): lib.Variant<'Asset', lib.Variant<'Removed', T>> => ({ kind: 'Asset', value: AssetEvent.Removed(value) }) }, PermissionAdded: <const T extends AccountPermissionChanged>(value: T): lib.Variant<'PermissionAdded', T> => ({ kind: 'PermissionAdded', value }), PermissionRemoved: <const T extends AccountPermissionChanged>(value: T): lib.Variant<'PermissionRemoved', T> => ({ kind: 'PermissionRemoved', value }), RoleGranted: <const T extends AccountRoleChanged>(value: T): lib.Variant<'RoleGranted', T> => ({ kind: 'RoleGranted', value }), RoleRevoked: <const T extends AccountRoleChanged>(value: T): lib.Variant<'RoleRevoked', T> => ({ kind: 'RoleRevoked', value }), MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T): lib.Variant<'MetadataInserted', T> => ({ kind: 'MetadataInserted', value }), MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T): lib.Variant<'MetadataRemoved', T> => ({ kind: 'MetadataRemoved', value }) }, ...lib.defineCodec(lib.enumCodec<{ Created: [Account], Deleted: [lib.AccountId], Asset: [AssetEvent], PermissionAdded: [AccountPermissionChanged], PermissionRemoved: [AccountPermissionChanged], RoleGranted: [AccountRoleChanged], RoleRevoked: [AccountRoleChanged], MetadataInserted: [MetadataChanged<lib.AccountId>], MetadataRemoved: [MetadataChanged<lib.AccountId>] }>({ Created: [0, lib.getCodec(Account)], Deleted: [1, lib.getCodec(lib.AccountId)], Asset: [2, lib.getCodec(AssetEvent)], PermissionAdded: [3, lib.getCodec(AccountPermissionChanged)], PermissionRemoved: [4, lib.getCodec(AccountPermissionChanged)], RoleGranted: [5, lib.getCodec(AccountRoleChanged)], RoleRevoked: [6, lib.getCodec(AccountRoleChanged)], MetadataInserted: [7, MetadataChanged.with(lib.getCodec(lib.AccountId))], MetadataRemoved: [8, MetadataChanged.with(lib.getCodec(lib.AccountId))] }).discriminated()) }

export type AccountEventSet = Set<'Created' | 'Deleted' | 'AnyAsset' | 'PermissionAdded' | 'PermissionRemoved' | 'RoleGranted' | 'RoleRevoked' | 'MetadataInserted' | 'MetadataRemoved'>
export const AccountEventSet: lib.CodecContainer<AccountEventSet> = lib.defineCodec(lib.bitmapCodec<AccountEventSet extends Set<infer T> ? T : never>({ Created: 1, Deleted: 2, AnyAsset: 4, PermissionAdded: 8, PermissionRemoved: 16, RoleGranted: 32, RoleRevoked: 64, MetadataInserted: 128, MetadataRemoved: 256 }))

/**
 * Structure with named fields.
 */
export interface AccountEventFilter { idMatcher: lib.Option<lib.AccountId>, eventSet: AccountEventSet }
/**
 * Codec of the structure.
 */
export const AccountEventFilter: lib.CodecContainer<AccountEventFilter> = lib.defineCodec(lib.structCodec<AccountEventFilter>(['idMatcher', 'eventSet'], {idMatcher: lib.Option.with(lib.getCodec(lib.AccountId)), eventSet: lib.getCodec(AccountEventSet)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type AccountIdPredicateAtom = lib.Variant<'Equals', lib.AccountId>
/**
 * Codec and constructors for enumeration {@link AccountIdPredicateAtom}.
 */
export const AccountIdPredicateAtom: lib.CodecContainer<AccountIdPredicateAtom> & { Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends lib.AccountId>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [lib.AccountId] }>({ Equals: [0, lib.getCodec(lib.AccountId)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type DomainIdPredicateAtom = lib.Variant<'Equals', lib.DomainId>
/**
 * Codec and constructors for enumeration {@link DomainIdPredicateAtom}.
 */
export const DomainIdPredicateAtom: lib.CodecContainer<DomainIdPredicateAtom> & { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [lib.DomainId] }>({ Equals: [0, lib.getCodec(lib.DomainId)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * - `Contains`
 * - `StartsWith`
 * - `EndsWith`
 * 
 * TODO how to construct, how to use
 */
export type StringPredicateAtom = lib.Variant<'Equals', lib.String> | lib.Variant<'Contains', lib.String> | lib.Variant<'StartsWith', lib.String> | lib.Variant<'EndsWith', lib.String>
/**
 * Codec and constructors for enumeration {@link StringPredicateAtom}.
 */
export const StringPredicateAtom: lib.CodecContainer<StringPredicateAtom> & { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Equals', T>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Contains', T>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'StartsWith', T>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'EndsWith', T> } = { ...{ Equals: <const T extends lib.String>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Contains', T> => ({ kind: 'Contains', value }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'StartsWith', T> => ({ kind: 'StartsWith', value }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'EndsWith', T> => ({ kind: 'EndsWith', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [lib.String], Contains: [lib.String], StartsWith: [lib.String], EndsWith: [lib.String] }>({ Equals: [0, lib.getCodec(lib.String)], Contains: [1, lib.getCodec(lib.String)], StartsWith: [2, lib.getCodec(lib.String)], EndsWith: [3, lib.getCodec(lib.String)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type NameProjectionPredicate = lib.Variant<'Atom', StringPredicateAtom>
/**
 * Codec and constructors for enumeration {@link NameProjectionPredicate}.
 */
export const NameProjectionPredicate: lib.CodecContainer<NameProjectionPredicate> & { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Atom', lib.Variant<'Contains', T>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Atom', lib.Variant<'StartsWith', T>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Atom', lib.Variant<'EndsWith', T>> } } = { ...{ Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: StringPredicateAtom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Atom', lib.Variant<'Contains', T>> => ({ kind: 'Atom', value: StringPredicateAtom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Atom', lib.Variant<'StartsWith', T>> => ({ kind: 'Atom', value: StringPredicateAtom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Atom', lib.Variant<'EndsWith', T>> => ({ kind: 'Atom', value: StringPredicateAtom.EndsWith(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [StringPredicateAtom] }>({ Atom: [0, lib.getCodec(StringPredicateAtom)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */
export type DomainIdProjectionPredicate = lib.Variant<'Atom', DomainIdPredicateAtom> | lib.Variant<'Name', NameProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link DomainIdProjectionPredicate}.
 */
export const DomainIdProjectionPredicate: lib.CodecContainer<DomainIdProjectionPredicate> & { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>> } } } = { ...{ Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: DomainIdPredicateAtom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.EndsWith(value) }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [DomainIdPredicateAtom], Name: [NameProjectionPredicate] }>({ Atom: [0, lib.getCodec(DomainIdPredicateAtom)], Name: [1, lib.getCodec(NameProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type PublicKeyPredicateAtom = lib.Variant<'Equals', lib.PublicKey>
/**
 * Codec and constructors for enumeration {@link PublicKeyPredicateAtom}.
 */
export const PublicKeyPredicateAtom: lib.CodecContainer<PublicKeyPredicateAtom> & { Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends lib.PublicKey>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [lib.PublicKey] }>({ Equals: [0, lib.getCodec(lib.PublicKey)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type PublicKeyProjectionPredicate = lib.Variant<'Atom', PublicKeyPredicateAtom>
/**
 * Codec and constructors for enumeration {@link PublicKeyProjectionPredicate}.
 */
export const PublicKeyProjectionPredicate: lib.CodecContainer<PublicKeyProjectionPredicate> & { Atom: { Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> } } = { ...{ Atom: { Equals: <const T extends lib.PublicKey>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: PublicKeyPredicateAtom.Equals(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [PublicKeyPredicateAtom] }>({ Atom: [0, lib.getCodec(PublicKeyPredicateAtom)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Signatory`
 * 
 * TODO how to construct, how to use
 */
export type AccountIdProjectionPredicate = lib.Variant<'Atom', AccountIdPredicateAtom> | lib.Variant<'Domain', DomainIdProjectionPredicate> | lib.Variant<'Signatory', PublicKeyProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link AccountIdProjectionPredicate}.
 */
export const AccountIdProjectionPredicate: lib.CodecContainer<AccountIdProjectionPredicate> & { Atom: { Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>> } } } = { ...{ Atom: { Equals: <const T extends lib.AccountId>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: AccountIdPredicateAtom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.EndsWith(value) }) } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T): lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Signatory', value: PublicKeyProjectionPredicate.Atom.Equals(value) }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [AccountIdPredicateAtom], Domain: [DomainIdProjectionPredicate], Signatory: [PublicKeyProjectionPredicate] }>({ Atom: [0, lib.getCodec(AccountIdPredicateAtom)], Domain: [1, lib.getCodec(DomainIdProjectionPredicate)], Signatory: [2, lib.getCodec(PublicKeyProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type NameProjectionSelector = lib.VariantUnit<'Atom'>
/**
 * Codec and constructors for enumeration {@link NameProjectionSelector}.
 */
export const NameProjectionSelector: lib.CodecContainer<NameProjectionSelector> & { Atom: lib.VariantUnit<'Atom'> } = { ...{ Atom: Object.freeze({ kind: 'Atom' }) }, ...lib.defineCodec(lib.enumCodec<{ Atom: [] }>({ Atom: [0] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */
export type DomainIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Name', NameProjectionSelector>
/**
 * Codec and constructors for enumeration {@link DomainIdProjectionSelector}.
 */
export const DomainIdProjectionSelector: lib.CodecContainer<DomainIdProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Name: { Atom: lib.Variant<'Name', lib.VariantUnit<'Atom'>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Name: { Atom: Object.freeze<lib.Variant<'Name', lib.VariantUnit<'Atom'>>>({ kind: 'Name', value: NameProjectionSelector.Atom }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Name: [NameProjectionSelector] }>({ Atom: [0], Name: [1, lib.getCodec(NameProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type PublicKeyProjectionSelector = lib.VariantUnit<'Atom'>
/**
 * Codec and constructors for enumeration {@link PublicKeyProjectionSelector}.
 */
export const PublicKeyProjectionSelector: lib.CodecContainer<PublicKeyProjectionSelector> & { Atom: lib.VariantUnit<'Atom'> } = { ...{ Atom: Object.freeze({ kind: 'Atom' }) }, ...lib.defineCodec(lib.enumCodec<{ Atom: [] }>({ Atom: [0] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Signatory`
 * 
 * TODO how to construct, how to use
 */
export type AccountIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Domain', DomainIdProjectionSelector> | lib.Variant<'Signatory', PublicKeyProjectionSelector>
/**
 * Codec and constructors for enumeration {@link AccountIdProjectionSelector}.
 */
export const AccountIdProjectionSelector: lib.CodecContainer<AccountIdProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Domain: { Atom: lib.Variant<'Domain', lib.VariantUnit<'Atom'>>, Name: { Atom: lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>> } }, Signatory: { Atom: lib.Variant<'Signatory', lib.VariantUnit<'Atom'>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Domain: { Atom: Object.freeze<lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>({ kind: 'Domain', value: DomainIdProjectionSelector.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>({ kind: 'Domain', value: DomainIdProjectionSelector.Name.Atom }) } }, Signatory: { Atom: Object.freeze<lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>({ kind: 'Signatory', value: PublicKeyProjectionSelector.Atom }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Domain: [DomainIdProjectionSelector], Signatory: [PublicKeyProjectionSelector] }>({ Atom: [0], Domain: [1, lib.getCodec(DomainIdProjectionSelector)], Signatory: [2, lib.getCodec(PublicKeyProjectionSelector)] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type AccountPredicateAtom = never
/**
 * Codec for {@link AccountPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const AccountPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type MetadataPredicateAtom = never
/**
 * Codec for {@link MetadataPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const MetadataPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type JsonPredicateAtom = lib.Variant<'Equals', lib.Json>
/**
 * Codec and constructors for enumeration {@link JsonPredicateAtom}.
 */
export const JsonPredicateAtom: lib.CodecContainer<JsonPredicateAtom> & { Equals: <const T extends lib.Json>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends lib.Json>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [lib.Json] }>({ Equals: [0, lib.getCodec(lib.Json)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type JsonProjectionPredicate = lib.Variant<'Atom', JsonPredicateAtom>
/**
 * Codec and constructors for enumeration {@link JsonProjectionPredicate}.
 */
export const JsonProjectionPredicate: lib.CodecContainer<JsonProjectionPredicate> & { Atom: { Equals: <const T extends lib.Json>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> } } = { ...{ Atom: { Equals: <const T extends lib.Json>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: JsonPredicateAtom.Equals(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [JsonPredicateAtom] }>({ Atom: [0, lib.getCodec(JsonPredicateAtom)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface MetadataKeyProjectionPredicate { key: lib.Name, projection: JsonProjectionPredicate }
/**
 * Codec of the structure.
 */
export const MetadataKeyProjectionPredicate: lib.CodecContainer<MetadataKeyProjectionPredicate> = lib.defineCodec(lib.structCodec<MetadataKeyProjectionPredicate>(['key', 'projection'], {key: lib.getCodec(lib.Name), projection: lib.getCodec(JsonProjectionPredicate)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Key`
 * 
 * TODO how to construct, how to use
 */
export type MetadataProjectionPredicate = lib.Variant<'Atom', MetadataPredicateAtom> | lib.Variant<'Key', MetadataKeyProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link MetadataProjectionPredicate}.
 */
export const MetadataProjectionPredicate: lib.CodecContainer<MetadataProjectionPredicate> & { Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Key', T> } = { ...{ Key: <const T extends MetadataKeyProjectionPredicate>(value: T): lib.Variant<'Key', T> => ({ kind: 'Key', value }) }, ...lib.defineCodec(lib.enumCodec<{ Atom: [MetadataPredicateAtom], Key: [MetadataKeyProjectionPredicate] }>({ Atom: [0, lib.getCodec(MetadataPredicateAtom)], Key: [1, lib.getCodec(MetadataKeyProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */
export type AccountProjectionPredicate = lib.Variant<'Atom', AccountPredicateAtom> | lib.Variant<'Id', AccountIdProjectionPredicate> | lib.Variant<'Metadata', MetadataProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link AccountProjectionPredicate}.
 */
export const AccountProjectionPredicate: lib.CodecContainer<AccountProjectionPredicate> & { Id: { Atom: { Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Id', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> } } }, Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>> } } = { ...{ Id: { Atom: { Equals: <const T extends lib.AccountId>(value: T): lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Id', value: AccountIdProjectionPredicate.Atom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: AccountIdProjectionPredicate.Domain.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Id', value: AccountIdProjectionPredicate.Domain.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>> => ({ kind: 'Id', value: AccountIdProjectionPredicate.Domain.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>> => ({ kind: 'Id', value: AccountIdProjectionPredicate.Domain.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> => ({ kind: 'Id', value: AccountIdProjectionPredicate.Domain.Name.Atom.EndsWith(value) }) } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T): lib.Variant<'Id', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: AccountIdProjectionPredicate.Signatory.Atom.Equals(value) }) } } }, Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T): lib.Variant<'Metadata', lib.Variant<'Key', T>> => ({ kind: 'Metadata', value: MetadataProjectionPredicate.Key(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [AccountPredicateAtom], Id: [AccountIdProjectionPredicate], Metadata: [MetadataProjectionPredicate] }>({ Atom: [0, lib.getCodec(AccountPredicateAtom)], Id: [1, lib.getCodec(AccountIdProjectionPredicate)], Metadata: [2, lib.getCodec(MetadataProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type JsonProjectionSelector = lib.VariantUnit<'Atom'>
/**
 * Codec and constructors for enumeration {@link JsonProjectionSelector}.
 */
export const JsonProjectionSelector: lib.CodecContainer<JsonProjectionSelector> & { Atom: lib.VariantUnit<'Atom'> } = { ...{ Atom: Object.freeze({ kind: 'Atom' }) }, ...lib.defineCodec(lib.enumCodec<{ Atom: [] }>({ Atom: [0] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface MetadataKeyProjectionSelector { key: lib.Name, projection: JsonProjectionSelector }
/**
 * Codec of the structure.
 */
export const MetadataKeyProjectionSelector: lib.CodecContainer<MetadataKeyProjectionSelector> = lib.defineCodec(lib.structCodec<MetadataKeyProjectionSelector>(['key', 'projection'], {key: lib.getCodec(lib.Name), projection: lib.getCodec(JsonProjectionSelector)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Key`
 * 
 * TODO how to construct, how to use
 */
export type MetadataProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Key', MetadataKeyProjectionSelector>
/**
 * Codec and constructors for enumeration {@link MetadataProjectionSelector}.
 */
export const MetadataProjectionSelector: lib.CodecContainer<MetadataProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Key', T> } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Key: <const T extends MetadataKeyProjectionSelector>(value: T): lib.Variant<'Key', T> => ({ kind: 'Key', value }) }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Key: [MetadataKeyProjectionSelector] }>({ Atom: [0], Key: [1, lib.getCodec(MetadataKeyProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */
export type AccountProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', AccountIdProjectionSelector> | lib.Variant<'Metadata', MetadataProjectionSelector>
/**
 * Codec and constructors for enumeration {@link AccountProjectionSelector}.
 */
export const AccountProjectionSelector: lib.CodecContainer<AccountProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Id: { Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>, Domain: { Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>, Name: { Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>> } }, Signatory: { Atom: lib.Variant<'Id', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>> } }, Metadata: { Atom: lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>, Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Id: { Atom: Object.freeze<lib.Variant<'Id', lib.VariantUnit<'Atom'>>>({ kind: 'Id', value: AccountIdProjectionSelector.Atom }), Domain: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: AccountIdProjectionSelector.Domain.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>({ kind: 'Id', value: AccountIdProjectionSelector.Domain.Name.Atom }) } }, Signatory: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: AccountIdProjectionSelector.Signatory.Atom }) } }, Metadata: { Atom: Object.freeze<lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>>({ kind: 'Metadata', value: MetadataProjectionSelector.Atom }), Key: <const T extends MetadataKeyProjectionSelector>(value: T): lib.Variant<'Metadata', lib.Variant<'Key', T>> => ({ kind: 'Metadata', value: MetadataProjectionSelector.Key(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Id: [AccountIdProjectionSelector], Metadata: [MetadataProjectionSelector] }>({ Atom: [0], Id: [1, lib.getCodec(AccountIdProjectionSelector)], Metadata: [2, lib.getCodec(MetadataProjectionSelector)] }).discriminated()) }

export type WasmSmartContract = lib.BytesVec
export const WasmSmartContract = lib.BytesVec

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Instructions`
 * - `Wasm`
 * 
 * TODO how to construct, how to use
 */
export type Executable = lib.Variant<'Instructions', lib.Vec<InstructionBox>> | lib.Variant<'Wasm', WasmSmartContract>
/**
 * Codec and constructors for enumeration {@link Executable}.
 */
export const Executable: lib.CodecContainer<Executable> & { Instructions: <const T extends lib.Vec<InstructionBox>>(value: T) => lib.Variant<'Instructions', T>, Wasm: <const T extends WasmSmartContract>(value: T) => lib.Variant<'Wasm', T> } = { ...{ Instructions: <const T extends lib.Vec<InstructionBox>>(value: T): lib.Variant<'Instructions', T> => ({ kind: 'Instructions', value }), Wasm: <const T extends WasmSmartContract>(value: T): lib.Variant<'Wasm', T> => ({ kind: 'Wasm', value }) }, ...lib.defineCodec(lib.enumCodec<{ Instructions: [lib.Vec<InstructionBox>], Wasm: [WasmSmartContract] }>({ Instructions: [0, lib.Vec.with(lib.lazyCodec(() => lib.getCodec(InstructionBox)))], Wasm: [1, lib.getCodec(WasmSmartContract)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Indefinitely`
 * - `Exactly`
 * 
 * TODO how to construct, how to use
 */
export type Repeats = lib.VariantUnit<'Indefinitely'> | lib.Variant<'Exactly', lib.U32>
/**
 * Codec and constructors for enumeration {@link Repeats}.
 */
export const Repeats: lib.CodecContainer<Repeats> & { Indefinitely: lib.VariantUnit<'Indefinitely'>, Exactly: <const T extends lib.U32>(value: T) => lib.Variant<'Exactly', T> } = { ...{ Indefinitely: Object.freeze({ kind: 'Indefinitely' }), Exactly: <const T extends lib.U32>(value: T): lib.Variant<'Exactly', T> => ({ kind: 'Exactly', value }) }, ...lib.defineCodec(lib.enumCodec<{ Indefinitely: [], Exactly: [lib.U32] }>({ Indefinitely: [0], Exactly: [1, lib.getCodec(lib.U32)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface PeerId { publicKey: lib.PublicKey }
/**
 * Codec of the structure.
 */
export const PeerId: lib.CodecContainer<PeerId> = lib.defineCodec(lib.structCodec<PeerId>(['publicKey'], {publicKey: lib.getCodec(lib.PublicKey)}))

export type TriggerId = lib.Name
export const TriggerId = lib.Name

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Asset`
 * - `AssetDefinition`
 * - `Nft`
 * - `Account`
 * - `Domain`
 * - `MetadataKey`
 * - `Block`
 * - `Transaction`
 * - `Peer`
 * - `Trigger`
 * - `Role`
 * - `Permission`
 * - `PublicKey`
 * 
 * TODO how to construct, how to use
 */
export type FindError = lib.Variant<'Asset', lib.AssetId> | lib.Variant<'AssetDefinition', lib.AssetDefinitionId> | lib.Variant<'Nft', lib.NftId> | lib.Variant<'Account', lib.AccountId> | lib.Variant<'Domain', lib.DomainId> | lib.Variant<'MetadataKey', lib.Name> | lib.Variant<'Block', lib.Hash> | lib.Variant<'Transaction', lib.Hash> | lib.Variant<'Peer', PeerId> | lib.Variant<'Trigger', TriggerId> | lib.Variant<'Role', RoleId> | lib.Variant<'Permission', Permission> | lib.Variant<'PublicKey', lib.PublicKey>
/**
 * Codec and constructors for enumeration {@link FindError}.
 */
export const FindError: lib.CodecContainer<FindError> & { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Asset', T>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AssetDefinition', T>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Nft', T>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Account', T>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', T>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'MetadataKey', T>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Block', T>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Transaction', T>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Peer', T>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Trigger', T>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Role', T>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Permission', T>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'PublicKey', T> } = { ...{ Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Asset', T> => ({ kind: 'Asset', value }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'AssetDefinition', T> => ({ kind: 'AssetDefinition', value }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Nft', T> => ({ kind: 'Nft', value }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Account', T> => ({ kind: 'Account', value }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Domain', T> => ({ kind: 'Domain', value }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'MetadataKey', T> => ({ kind: 'MetadataKey', value }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Block', T> => ({ kind: 'Block', value }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Transaction', T> => ({ kind: 'Transaction', value }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Peer', T> => ({ kind: 'Peer', value }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Trigger', T> => ({ kind: 'Trigger', value }), Role: <const T extends RoleId>(value: T): lib.Variant<'Role', T> => ({ kind: 'Role', value }), Permission: <const T extends Permission>(value: T): lib.Variant<'Permission', T> => ({ kind: 'Permission', value }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'PublicKey', T> => ({ kind: 'PublicKey', value }) }, ...lib.defineCodec(lib.enumCodec<{ Asset: [lib.AssetId], AssetDefinition: [lib.AssetDefinitionId], Nft: [lib.NftId], Account: [lib.AccountId], Domain: [lib.DomainId], MetadataKey: [lib.Name], Block: [lib.Hash], Transaction: [lib.Hash], Peer: [PeerId], Trigger: [TriggerId], Role: [RoleId], Permission: [Permission], PublicKey: [lib.PublicKey] }>({ Asset: [0, lib.getCodec(lib.AssetId)], AssetDefinition: [1, lib.getCodec(lib.AssetDefinitionId)], Nft: [2, lib.getCodec(lib.NftId)], Account: [3, lib.getCodec(lib.AccountId)], Domain: [4, lib.getCodec(lib.DomainId)], MetadataKey: [5, lib.getCodec(lib.Name)], Block: [6, lib.getCodec(lib.Hash)], Transaction: [7, lib.getCodec(lib.Hash)], Peer: [8, lib.getCodec(PeerId)], Trigger: [9, lib.getCodec(TriggerId)], Role: [10, lib.getCodec(RoleId)], Permission: [11, lib.getCodec(Permission)], PublicKey: [12, lib.getCodec(lib.PublicKey)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface TransactionLimitError { reason: lib.String }
/**
 * Codec of the structure.
 */
export const TransactionLimitError: lib.CodecContainer<TransactionLimitError> = lib.defineCodec(lib.structCodec<TransactionLimitError>(['reason'], {reason: lib.getCodec(lib.String)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Register`
 * - `Unregister`
 * - `Mint`
 * - `Burn`
 * - `Transfer`
 * - `SetKeyValue`
 * - `RemoveKeyValue`
 * - `Grant`
 * - `Revoke`
 * - `ExecuteTrigger`
 * - `SetParameter`
 * - `Upgrade`
 * - `Log`
 * - `Custom`
 * 
 * TODO how to construct, how to use
 */
export type InstructionType = lib.VariantUnit<'Register'> | lib.VariantUnit<'Unregister'> | lib.VariantUnit<'Mint'> | lib.VariantUnit<'Burn'> | lib.VariantUnit<'Transfer'> | lib.VariantUnit<'SetKeyValue'> | lib.VariantUnit<'RemoveKeyValue'> | lib.VariantUnit<'Grant'> | lib.VariantUnit<'Revoke'> | lib.VariantUnit<'ExecuteTrigger'> | lib.VariantUnit<'SetParameter'> | lib.VariantUnit<'Upgrade'> | lib.VariantUnit<'Log'> | lib.VariantUnit<'Custom'>
/**
 * Codec and constructors for enumeration {@link InstructionType}.
 */
export const InstructionType: lib.CodecContainer<InstructionType> & { Register: lib.VariantUnit<'Register'>, Unregister: lib.VariantUnit<'Unregister'>, Mint: lib.VariantUnit<'Mint'>, Burn: lib.VariantUnit<'Burn'>, Transfer: lib.VariantUnit<'Transfer'>, SetKeyValue: lib.VariantUnit<'SetKeyValue'>, RemoveKeyValue: lib.VariantUnit<'RemoveKeyValue'>, Grant: lib.VariantUnit<'Grant'>, Revoke: lib.VariantUnit<'Revoke'>, ExecuteTrigger: lib.VariantUnit<'ExecuteTrigger'>, SetParameter: lib.VariantUnit<'SetParameter'>, Upgrade: lib.VariantUnit<'Upgrade'>, Log: lib.VariantUnit<'Log'>, Custom: lib.VariantUnit<'Custom'> } = { ...{ Register: Object.freeze({ kind: 'Register' }), Unregister: Object.freeze({ kind: 'Unregister' }), Mint: Object.freeze({ kind: 'Mint' }), Burn: Object.freeze({ kind: 'Burn' }), Transfer: Object.freeze({ kind: 'Transfer' }), SetKeyValue: Object.freeze({ kind: 'SetKeyValue' }), RemoveKeyValue: Object.freeze({ kind: 'RemoveKeyValue' }), Grant: Object.freeze({ kind: 'Grant' }), Revoke: Object.freeze({ kind: 'Revoke' }), ExecuteTrigger: Object.freeze({ kind: 'ExecuteTrigger' }), SetParameter: Object.freeze({ kind: 'SetParameter' }), Upgrade: Object.freeze({ kind: 'Upgrade' }), Log: Object.freeze({ kind: 'Log' }), Custom: Object.freeze({ kind: 'Custom' }) }, ...lib.defineCodec(lib.enumCodec<{ Register: [], Unregister: [], Mint: [], Burn: [], Transfer: [], SetKeyValue: [], RemoveKeyValue: [], Grant: [], Revoke: [], ExecuteTrigger: [], SetParameter: [], Upgrade: [], Log: [], Custom: [] }>({ Register: [0], Unregister: [1], Mint: [2], Burn: [3], Transfer: [4], SetKeyValue: [5], RemoveKeyValue: [6], Grant: [7], Revoke: [8], ExecuteTrigger: [9], SetParameter: [10], Upgrade: [11], Log: [12], Custom: [13] }).discriminated()) }

/**
 * Structure with named fields and generic parameters.
 */
export interface Mismatch<T0> { expected: T0, actual: T0 }
/**
 * Codec constructor for the structure with generic parameters.
 */
export const Mismatch = { /**
 * Create a codec with the actual codecs for generic parameters.
 */
with: <T0>(t0: lib.GenCodec<T0>): lib.GenCodec<Mismatch<T0>> => lib.structCodec<Mismatch<T0>>(['expected', 'actual'], {expected: t0, actual: t0}) }

/**
 * Structure with named fields.
 */
export interface NumericSpec { scale: lib.Option<lib.U32> }
/**
 * Codec of the structure.
 */
export const NumericSpec: lib.CodecContainer<NumericSpec> = lib.defineCodec(lib.structCodec<NumericSpec>(['scale'], {scale: lib.Option.with(lib.getCodec(lib.U32))}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `AssetNumericSpec`
 * 
 * TODO how to construct, how to use
 */
export type TypeError = lib.Variant<'AssetNumericSpec', Mismatch<NumericSpec>>
/**
 * Codec and constructors for enumeration {@link TypeError}.
 */
export const TypeError: lib.CodecContainer<TypeError> & { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'AssetNumericSpec', T> } = { ...{ AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T): lib.Variant<'AssetNumericSpec', T> => ({ kind: 'AssetNumericSpec', value }) }, ...lib.defineCodec(lib.enumCodec<{ AssetNumericSpec: [Mismatch<NumericSpec>] }>({ AssetNumericSpec: [0, Mismatch.with(lib.getCodec(NumericSpec))] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Unsupported`
 * - `PermissionParameter`
 * - `Type`
 * 
 * TODO how to construct, how to use
 */
export type InstructionEvaluationError = lib.Variant<'Unsupported', InstructionType> | lib.Variant<'PermissionParameter', lib.String> | lib.Variant<'Type', TypeError>
/**
 * Codec and constructors for enumeration {@link InstructionEvaluationError}.
 */
export const InstructionEvaluationError: lib.CodecContainer<InstructionEvaluationError> & { Unsupported: { Register: lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>, Unregister: lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>, Mint: lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>, Burn: lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>, Transfer: lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>, SetKeyValue: lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>, RemoveKeyValue: lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>, Grant: lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>, Revoke: lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>, ExecuteTrigger: lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>, SetParameter: lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>, Upgrade: lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>, Log: lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>, Custom: lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>> }, PermissionParameter: <const T extends lib.String>(value: T) => lib.Variant<'PermissionParameter', T>, Type: { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>> } } = { ...{ Unsupported: { Register: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>({ kind: 'Unsupported', value: InstructionType.Register }), Unregister: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>({ kind: 'Unsupported', value: InstructionType.Unregister }), Mint: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>({ kind: 'Unsupported', value: InstructionType.Mint }), Burn: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>({ kind: 'Unsupported', value: InstructionType.Burn }), Transfer: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>({ kind: 'Unsupported', value: InstructionType.Transfer }), SetKeyValue: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>({ kind: 'Unsupported', value: InstructionType.SetKeyValue }), RemoveKeyValue: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>({ kind: 'Unsupported', value: InstructionType.RemoveKeyValue }), Grant: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>({ kind: 'Unsupported', value: InstructionType.Grant }), Revoke: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>({ kind: 'Unsupported', value: InstructionType.Revoke }), ExecuteTrigger: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>({ kind: 'Unsupported', value: InstructionType.ExecuteTrigger }), SetParameter: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>({ kind: 'Unsupported', value: InstructionType.SetParameter }), Upgrade: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>({ kind: 'Unsupported', value: InstructionType.Upgrade }), Log: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>({ kind: 'Unsupported', value: InstructionType.Log }), Custom: Object.freeze<lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>({ kind: 'Unsupported', value: InstructionType.Custom }) }, PermissionParameter: <const T extends lib.String>(value: T): lib.Variant<'PermissionParameter', T> => ({ kind: 'PermissionParameter', value }), Type: { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T): lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>> => ({ kind: 'Type', value: TypeError.AssetNumericSpec(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Unsupported: [InstructionType], PermissionParameter: [lib.String], Type: [TypeError] }>({ Unsupported: [0, lib.getCodec(InstructionType)], PermissionParameter: [1, lib.getCodec(lib.String)], Type: [2, lib.getCodec(TypeError)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Find`
 * - `Conversion`
 * - `NotFound`
 * - `CursorMismatch`
 * - `CursorDone`
 * - `FetchSizeTooBig`
 * - `InvalidSingularParameters`
 * - `CapacityLimit`
 * 
 * TODO how to construct, how to use
 */
export type QueryExecutionFail = lib.Variant<'Find', FindError> | lib.Variant<'Conversion', lib.String> | lib.VariantUnit<'NotFound'> | lib.VariantUnit<'CursorMismatch'> | lib.VariantUnit<'CursorDone'> | lib.VariantUnit<'FetchSizeTooBig'> | lib.VariantUnit<'InvalidSingularParameters'> | lib.VariantUnit<'CapacityLimit'>
/**
 * Codec and constructors for enumeration {@link QueryExecutionFail}.
 */
export const QueryExecutionFail: lib.CodecContainer<QueryExecutionFail> & { Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Find', lib.Variant<'Asset', T>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Find', lib.Variant<'Nft', T>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Find', lib.Variant<'Account', T>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Find', lib.Variant<'Domain', T>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Find', lib.Variant<'MetadataKey', T>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Find', lib.Variant<'Block', T>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Find', lib.Variant<'Transaction', T>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Find', lib.Variant<'Peer', T>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Find', lib.Variant<'Trigger', T>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Find', lib.Variant<'Role', T>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Find', lib.Variant<'Permission', T>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Find', lib.Variant<'PublicKey', T>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Conversion', T>, NotFound: lib.VariantUnit<'NotFound'>, CursorMismatch: lib.VariantUnit<'CursorMismatch'>, CursorDone: lib.VariantUnit<'CursorDone'>, FetchSizeTooBig: lib.VariantUnit<'FetchSizeTooBig'>, InvalidSingularParameters: lib.VariantUnit<'InvalidSingularParameters'>, CapacityLimit: lib.VariantUnit<'CapacityLimit'> } = { ...{ Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Find', lib.Variant<'Asset', T>> => ({ kind: 'Find', value: FindError.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Find', lib.Variant<'AssetDefinition', T>> => ({ kind: 'Find', value: FindError.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Find', lib.Variant<'Nft', T>> => ({ kind: 'Find', value: FindError.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Find', lib.Variant<'Account', T>> => ({ kind: 'Find', value: FindError.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Find', lib.Variant<'Domain', T>> => ({ kind: 'Find', value: FindError.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'Find', lib.Variant<'MetadataKey', T>> => ({ kind: 'Find', value: FindError.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Find', lib.Variant<'Block', T>> => ({ kind: 'Find', value: FindError.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Find', lib.Variant<'Transaction', T>> => ({ kind: 'Find', value: FindError.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Find', lib.Variant<'Peer', T>> => ({ kind: 'Find', value: FindError.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Find', lib.Variant<'Trigger', T>> => ({ kind: 'Find', value: FindError.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Find', lib.Variant<'Role', T>> => ({ kind: 'Find', value: FindError.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'Find', lib.Variant<'Permission', T>> => ({ kind: 'Find', value: FindError.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'Find', lib.Variant<'PublicKey', T>> => ({ kind: 'Find', value: FindError.PublicKey(value) }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'Conversion', T> => ({ kind: 'Conversion', value }), NotFound: Object.freeze({ kind: 'NotFound' }), CursorMismatch: Object.freeze({ kind: 'CursorMismatch' }), CursorDone: Object.freeze({ kind: 'CursorDone' }), FetchSizeTooBig: Object.freeze({ kind: 'FetchSizeTooBig' }), InvalidSingularParameters: Object.freeze({ kind: 'InvalidSingularParameters' }), CapacityLimit: Object.freeze({ kind: 'CapacityLimit' }) }, ...lib.defineCodec(lib.enumCodec<{ Find: [FindError], Conversion: [lib.String], NotFound: [], CursorMismatch: [], CursorDone: [], FetchSizeTooBig: [], InvalidSingularParameters: [], CapacityLimit: [] }>({ Find: [0, lib.getCodec(FindError)], Conversion: [1, lib.getCodec(lib.String)], NotFound: [2], CursorMismatch: [3], CursorDone: [4], FetchSizeTooBig: [5], InvalidSingularParameters: [6], CapacityLimit: [7] }).discriminated()) }

export type CustomParameterId = lib.Name
export const CustomParameterId = lib.Name

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `DomainId`
 * - `AccountId`
 * - `AssetDefinitionId`
 * - `AssetId`
 * - `NftId`
 * - `PeerId`
 * - `TriggerId`
 * - `RoleId`
 * - `Permission`
 * - `CustomParameterId`
 * 
 * TODO how to construct, how to use
 */
export type IdBox = lib.Variant<'DomainId', lib.DomainId> | lib.Variant<'AccountId', lib.AccountId> | lib.Variant<'AssetDefinitionId', lib.AssetDefinitionId> | lib.Variant<'AssetId', lib.AssetId> | lib.Variant<'NftId', lib.NftId> | lib.Variant<'PeerId', PeerId> | lib.Variant<'TriggerId', TriggerId> | lib.Variant<'RoleId', RoleId> | lib.Variant<'Permission', Permission> | lib.Variant<'CustomParameterId', CustomParameterId>
/**
 * Codec and constructors for enumeration {@link IdBox}.
 */
export const IdBox: lib.CodecContainer<IdBox> & { DomainId: <const T extends lib.DomainId>(value: T) => lib.Variant<'DomainId', T>, AccountId: <const T extends lib.AccountId>(value: T) => lib.Variant<'AccountId', T>, AssetDefinitionId: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AssetDefinitionId', T>, AssetId: <const T extends lib.AssetId>(value: T) => lib.Variant<'AssetId', T>, NftId: <const T extends lib.NftId>(value: T) => lib.Variant<'NftId', T>, PeerId: <const T extends PeerId>(value: T) => lib.Variant<'PeerId', T>, TriggerId: <const T extends TriggerId>(value: T) => lib.Variant<'TriggerId', T>, RoleId: <const T extends RoleId>(value: T) => lib.Variant<'RoleId', T>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Permission', T>, CustomParameterId: <const T extends CustomParameterId>(value: T) => lib.Variant<'CustomParameterId', T> } = { ...{ DomainId: <const T extends lib.DomainId>(value: T): lib.Variant<'DomainId', T> => ({ kind: 'DomainId', value }), AccountId: <const T extends lib.AccountId>(value: T): lib.Variant<'AccountId', T> => ({ kind: 'AccountId', value }), AssetDefinitionId: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'AssetDefinitionId', T> => ({ kind: 'AssetDefinitionId', value }), AssetId: <const T extends lib.AssetId>(value: T): lib.Variant<'AssetId', T> => ({ kind: 'AssetId', value }), NftId: <const T extends lib.NftId>(value: T): lib.Variant<'NftId', T> => ({ kind: 'NftId', value }), PeerId: <const T extends PeerId>(value: T): lib.Variant<'PeerId', T> => ({ kind: 'PeerId', value }), TriggerId: <const T extends TriggerId>(value: T): lib.Variant<'TriggerId', T> => ({ kind: 'TriggerId', value }), RoleId: <const T extends RoleId>(value: T): lib.Variant<'RoleId', T> => ({ kind: 'RoleId', value }), Permission: <const T extends Permission>(value: T): lib.Variant<'Permission', T> => ({ kind: 'Permission', value }), CustomParameterId: <const T extends CustomParameterId>(value: T): lib.Variant<'CustomParameterId', T> => ({ kind: 'CustomParameterId', value }) }, ...lib.defineCodec(lib.enumCodec<{ DomainId: [lib.DomainId], AccountId: [lib.AccountId], AssetDefinitionId: [lib.AssetDefinitionId], AssetId: [lib.AssetId], NftId: [lib.NftId], PeerId: [PeerId], TriggerId: [TriggerId], RoleId: [RoleId], Permission: [Permission], CustomParameterId: [CustomParameterId] }>({ DomainId: [0, lib.getCodec(lib.DomainId)], AccountId: [1, lib.getCodec(lib.AccountId)], AssetDefinitionId: [2, lib.getCodec(lib.AssetDefinitionId)], AssetId: [3, lib.getCodec(lib.AssetId)], NftId: [4, lib.getCodec(lib.NftId)], PeerId: [5, lib.getCodec(PeerId)], TriggerId: [6, lib.getCodec(TriggerId)], RoleId: [7, lib.getCodec(RoleId)], Permission: [8, lib.getCodec(Permission)], CustomParameterId: [9, lib.getCodec(CustomParameterId)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface RepetitionError { instruction: InstructionType, id: IdBox }
/**
 * Codec of the structure.
 */
export const RepetitionError: lib.CodecContainer<RepetitionError> = lib.defineCodec(lib.structCodec<RepetitionError>(['instruction', 'id'], {instruction: lib.getCodec(InstructionType), id: lib.getCodec(IdBox)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `MintUnmintable`
 * - `ForbidMintOnMintable`
 * 
 * TODO how to construct, how to use
 */
export type MintabilityError = lib.VariantUnit<'MintUnmintable'> | lib.VariantUnit<'ForbidMintOnMintable'>
/**
 * Codec and constructors for enumeration {@link MintabilityError}.
 */
export const MintabilityError: lib.CodecContainer<MintabilityError> & { MintUnmintable: lib.VariantUnit<'MintUnmintable'>, ForbidMintOnMintable: lib.VariantUnit<'ForbidMintOnMintable'> } = { ...{ MintUnmintable: Object.freeze({ kind: 'MintUnmintable' }), ForbidMintOnMintable: Object.freeze({ kind: 'ForbidMintOnMintable' }) }, ...lib.defineCodec(lib.enumCodec<{ MintUnmintable: [], ForbidMintOnMintable: [] }>({ MintUnmintable: [0], ForbidMintOnMintable: [1] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Overflow`
 * - `NotEnoughQuantity`
 * - `DivideByZero`
 * - `NegativeValue`
 * - `DomainViolation`
 * - `Unknown`
 * - `FixedPointConversion`
 * 
 * TODO how to construct, how to use
 */
export type MathError = lib.VariantUnit<'Overflow'> | lib.VariantUnit<'NotEnoughQuantity'> | lib.VariantUnit<'DivideByZero'> | lib.VariantUnit<'NegativeValue'> | lib.VariantUnit<'DomainViolation'> | lib.VariantUnit<'Unknown'> | lib.Variant<'FixedPointConversion', lib.String>
/**
 * Codec and constructors for enumeration {@link MathError}.
 */
export const MathError: lib.CodecContainer<MathError> & { Overflow: lib.VariantUnit<'Overflow'>, NotEnoughQuantity: lib.VariantUnit<'NotEnoughQuantity'>, DivideByZero: lib.VariantUnit<'DivideByZero'>, NegativeValue: lib.VariantUnit<'NegativeValue'>, DomainViolation: lib.VariantUnit<'DomainViolation'>, Unknown: lib.VariantUnit<'Unknown'>, FixedPointConversion: <const T extends lib.String>(value: T) => lib.Variant<'FixedPointConversion', T> } = { ...{ Overflow: Object.freeze({ kind: 'Overflow' }), NotEnoughQuantity: Object.freeze({ kind: 'NotEnoughQuantity' }), DivideByZero: Object.freeze({ kind: 'DivideByZero' }), NegativeValue: Object.freeze({ kind: 'NegativeValue' }), DomainViolation: Object.freeze({ kind: 'DomainViolation' }), Unknown: Object.freeze({ kind: 'Unknown' }), FixedPointConversion: <const T extends lib.String>(value: T): lib.Variant<'FixedPointConversion', T> => ({ kind: 'FixedPointConversion', value }) }, ...lib.defineCodec(lib.enumCodec<{ Overflow: [], NotEnoughQuantity: [], DivideByZero: [], NegativeValue: [], DomainViolation: [], Unknown: [], FixedPointConversion: [lib.String] }>({ Overflow: [0], NotEnoughQuantity: [1], DivideByZero: [2], NegativeValue: [3], DomainViolation: [4], Unknown: [5], FixedPointConversion: [6, lib.getCodec(lib.String)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Wasm`
 * - `TimeTriggerInThePast`
 * 
 * TODO how to construct, how to use
 */
export type InvalidParameterError = lib.Variant<'Wasm', lib.String> | lib.VariantUnit<'TimeTriggerInThePast'>
/**
 * Codec and constructors for enumeration {@link InvalidParameterError}.
 */
export const InvalidParameterError: lib.CodecContainer<InvalidParameterError> & { Wasm: <const T extends lib.String>(value: T) => lib.Variant<'Wasm', T>, TimeTriggerInThePast: lib.VariantUnit<'TimeTriggerInThePast'> } = { ...{ Wasm: <const T extends lib.String>(value: T): lib.Variant<'Wasm', T> => ({ kind: 'Wasm', value }), TimeTriggerInThePast: Object.freeze({ kind: 'TimeTriggerInThePast' }) }, ...lib.defineCodec(lib.enumCodec<{ Wasm: [lib.String], TimeTriggerInThePast: [] }>({ Wasm: [0, lib.getCodec(lib.String)], TimeTriggerInThePast: [1] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Evaluate`
 * - `Query`
 * - `Conversion`
 * - `Find`
 * - `Repetition`
 * - `Mintability`
 * - `Math`
 * - `InvalidParameter`
 * - `InvariantViolation`
 * 
 * TODO how to construct, how to use
 */
export type InstructionExecutionError = lib.Variant<'Evaluate', InstructionEvaluationError> | lib.Variant<'Query', QueryExecutionFail> | lib.Variant<'Conversion', lib.String> | lib.Variant<'Find', FindError> | lib.Variant<'Repetition', RepetitionError> | lib.Variant<'Mintability', MintabilityError> | lib.Variant<'Math', MathError> | lib.Variant<'InvalidParameter', InvalidParameterError> | lib.Variant<'InvariantViolation', lib.String>
/**
 * Codec and constructors for enumeration {@link InstructionExecutionError}.
 */
export const InstructionExecutionError: lib.CodecContainer<InstructionExecutionError> & { Evaluate: { Unsupported: { Register: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>, Unregister: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>, Mint: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>, Burn: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>, Transfer: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>, SetKeyValue: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>, RemoveKeyValue: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>, Grant: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>, Revoke: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>, ExecuteTrigger: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>, SetParameter: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>, Upgrade: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>, Log: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>, Custom: lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>> }, PermissionParameter: <const T extends lib.String>(value: T) => lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>, Type: { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>> } }, Query: { Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Query', lib.Variant<'Conversion', T>>, NotFound: lib.Variant<'Query', lib.VariantUnit<'NotFound'>>, CursorMismatch: lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>, CursorDone: lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>, FetchSizeTooBig: lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>, InvalidSingularParameters: lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>, CapacityLimit: lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Conversion', T>, Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Find', lib.Variant<'Asset', T>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Find', lib.Variant<'Nft', T>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Find', lib.Variant<'Account', T>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Find', lib.Variant<'Domain', T>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Find', lib.Variant<'MetadataKey', T>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Find', lib.Variant<'Block', T>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Find', lib.Variant<'Transaction', T>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Find', lib.Variant<'Peer', T>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Find', lib.Variant<'Trigger', T>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Find', lib.Variant<'Role', T>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Find', lib.Variant<'Permission', T>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Find', lib.Variant<'PublicKey', T>> }, Repetition: <const T extends RepetitionError>(value: T) => lib.Variant<'Repetition', T>, Mintability: { MintUnmintable: lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>, ForbidMintOnMintable: lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>> }, Math: { Overflow: lib.Variant<'Math', lib.VariantUnit<'Overflow'>>, NotEnoughQuantity: lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>, DivideByZero: lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>, NegativeValue: lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>, DomainViolation: lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>, Unknown: lib.Variant<'Math', lib.VariantUnit<'Unknown'>>, FixedPointConversion: <const T extends lib.String>(value: T) => lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>> }, InvalidParameter: { Wasm: <const T extends lib.String>(value: T) => lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>, TimeTriggerInThePast: lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>> }, InvariantViolation: <const T extends lib.String>(value: T) => lib.Variant<'InvariantViolation', T> } = { ...{ Evaluate: { Unsupported: { Register: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.Register }), Unregister: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.Unregister }), Mint: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.Mint }), Burn: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.Burn }), Transfer: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.Transfer }), SetKeyValue: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.SetKeyValue }), RemoveKeyValue: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.RemoveKeyValue }), Grant: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.Grant }), Revoke: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.Revoke }), ExecuteTrigger: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.ExecuteTrigger }), SetParameter: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.SetParameter }), Upgrade: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.Upgrade }), Log: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.Log }), Custom: Object.freeze<lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>>({ kind: 'Evaluate', value: InstructionEvaluationError.Unsupported.Custom }) }, PermissionParameter: <const T extends lib.String>(value: T): lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>> => ({ kind: 'Evaluate', value: InstructionEvaluationError.PermissionParameter(value) }), Type: { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T): lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>> => ({ kind: 'Evaluate', value: InstructionEvaluationError.Type.AssetNumericSpec(value) }) } }, Query: { Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>> => ({ kind: 'Query', value: QueryExecutionFail.Find.PublicKey(value) }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'Query', lib.Variant<'Conversion', T>> => ({ kind: 'Query', value: QueryExecutionFail.Conversion(value) }), NotFound: Object.freeze<lib.Variant<'Query', lib.VariantUnit<'NotFound'>>>({ kind: 'Query', value: QueryExecutionFail.NotFound }), CursorMismatch: Object.freeze<lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>>({ kind: 'Query', value: QueryExecutionFail.CursorMismatch }), CursorDone: Object.freeze<lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>>({ kind: 'Query', value: QueryExecutionFail.CursorDone }), FetchSizeTooBig: Object.freeze<lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>>({ kind: 'Query', value: QueryExecutionFail.FetchSizeTooBig }), InvalidSingularParameters: Object.freeze<lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>>({ kind: 'Query', value: QueryExecutionFail.InvalidSingularParameters }), CapacityLimit: Object.freeze<lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>>({ kind: 'Query', value: QueryExecutionFail.CapacityLimit }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'Conversion', T> => ({ kind: 'Conversion', value }), Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Find', lib.Variant<'Asset', T>> => ({ kind: 'Find', value: FindError.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Find', lib.Variant<'AssetDefinition', T>> => ({ kind: 'Find', value: FindError.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Find', lib.Variant<'Nft', T>> => ({ kind: 'Find', value: FindError.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Find', lib.Variant<'Account', T>> => ({ kind: 'Find', value: FindError.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Find', lib.Variant<'Domain', T>> => ({ kind: 'Find', value: FindError.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'Find', lib.Variant<'MetadataKey', T>> => ({ kind: 'Find', value: FindError.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Find', lib.Variant<'Block', T>> => ({ kind: 'Find', value: FindError.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Find', lib.Variant<'Transaction', T>> => ({ kind: 'Find', value: FindError.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Find', lib.Variant<'Peer', T>> => ({ kind: 'Find', value: FindError.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Find', lib.Variant<'Trigger', T>> => ({ kind: 'Find', value: FindError.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Find', lib.Variant<'Role', T>> => ({ kind: 'Find', value: FindError.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'Find', lib.Variant<'Permission', T>> => ({ kind: 'Find', value: FindError.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'Find', lib.Variant<'PublicKey', T>> => ({ kind: 'Find', value: FindError.PublicKey(value) }) }, Repetition: <const T extends RepetitionError>(value: T): lib.Variant<'Repetition', T> => ({ kind: 'Repetition', value }), Mintability: { MintUnmintable: Object.freeze<lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>>({ kind: 'Mintability', value: MintabilityError.MintUnmintable }), ForbidMintOnMintable: Object.freeze<lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>>({ kind: 'Mintability', value: MintabilityError.ForbidMintOnMintable }) }, Math: { Overflow: Object.freeze<lib.Variant<'Math', lib.VariantUnit<'Overflow'>>>({ kind: 'Math', value: MathError.Overflow }), NotEnoughQuantity: Object.freeze<lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>>({ kind: 'Math', value: MathError.NotEnoughQuantity }), DivideByZero: Object.freeze<lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>>({ kind: 'Math', value: MathError.DivideByZero }), NegativeValue: Object.freeze<lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>>({ kind: 'Math', value: MathError.NegativeValue }), DomainViolation: Object.freeze<lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>>({ kind: 'Math', value: MathError.DomainViolation }), Unknown: Object.freeze<lib.Variant<'Math', lib.VariantUnit<'Unknown'>>>({ kind: 'Math', value: MathError.Unknown }), FixedPointConversion: <const T extends lib.String>(value: T): lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>> => ({ kind: 'Math', value: MathError.FixedPointConversion(value) }) }, InvalidParameter: { Wasm: <const T extends lib.String>(value: T): lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>> => ({ kind: 'InvalidParameter', value: InvalidParameterError.Wasm(value) }), TimeTriggerInThePast: Object.freeze<lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>>({ kind: 'InvalidParameter', value: InvalidParameterError.TimeTriggerInThePast }) }, InvariantViolation: <const T extends lib.String>(value: T): lib.Variant<'InvariantViolation', T> => ({ kind: 'InvariantViolation', value }) }, ...lib.defineCodec(lib.enumCodec<{ Evaluate: [InstructionEvaluationError], Query: [QueryExecutionFail], Conversion: [lib.String], Find: [FindError], Repetition: [RepetitionError], Mintability: [MintabilityError], Math: [MathError], InvalidParameter: [InvalidParameterError], InvariantViolation: [lib.String] }>({ Evaluate: [0, lib.getCodec(InstructionEvaluationError)], Query: [1, lib.getCodec(QueryExecutionFail)], Conversion: [2, lib.getCodec(lib.String)], Find: [3, lib.getCodec(FindError)], Repetition: [4, lib.getCodec(RepetitionError)], Mintability: [5, lib.getCodec(MintabilityError)], Math: [6, lib.getCodec(MathError)], InvalidParameter: [7, lib.getCodec(InvalidParameterError)], InvariantViolation: [8, lib.getCodec(lib.String)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `NotPermitted`
 * - `InstructionFailed`
 * - `QueryFailed`
 * - `TooComplex`
 * - `InternalError`
 * 
 * TODO how to construct, how to use
 */
export type ValidationFail = lib.Variant<'NotPermitted', lib.String> | lib.Variant<'InstructionFailed', InstructionExecutionError> | lib.Variant<'QueryFailed', QueryExecutionFail> | lib.VariantUnit<'TooComplex'> | lib.VariantUnit<'InternalError'>
/**
 * Codec and constructors for enumeration {@link ValidationFail}.
 */
export const ValidationFail: lib.CodecContainer<ValidationFail> & { NotPermitted: <const T extends lib.String>(value: T) => lib.Variant<'NotPermitted', T>, InstructionFailed: { Evaluate: { Unsupported: { Register: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>>, Unregister: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>>, Mint: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>>, Burn: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>>, Transfer: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>>, SetKeyValue: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>>, RemoveKeyValue: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>>, Grant: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>>, Revoke: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>>, ExecuteTrigger: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>>, SetParameter: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>>, Upgrade: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>>, Log: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>>, Custom: lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>> }, PermissionParameter: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>>, Type: { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>>> } }, Query: { Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Conversion', T>>>, NotFound: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'NotFound'>>>, CursorMismatch: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>>, CursorDone: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>>, FetchSizeTooBig: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>>, InvalidSingularParameters: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>>, CapacityLimit: lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Conversion', T>>, Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>> }, Repetition: <const T extends RepetitionError>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Repetition', T>>, Mintability: { MintUnmintable: lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>>, ForbidMintOnMintable: lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>> }, Math: { Overflow: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Overflow'>>>, NotEnoughQuantity: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>>, DivideByZero: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>>, NegativeValue: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>>, DomainViolation: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>>, Unknown: lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Unknown'>>>, FixedPointConversion: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>>> }, InvalidParameter: { Wasm: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>>, TimeTriggerInThePast: lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>> }, InvariantViolation: <const T extends lib.String>(value: T) => lib.Variant<'InstructionFailed', lib.Variant<'InvariantViolation', T>> }, QueryFailed: { Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'QueryFailed', lib.Variant<'Conversion', T>>, NotFound: lib.Variant<'QueryFailed', lib.VariantUnit<'NotFound'>>, CursorMismatch: lib.Variant<'QueryFailed', lib.VariantUnit<'CursorMismatch'>>, CursorDone: lib.Variant<'QueryFailed', lib.VariantUnit<'CursorDone'>>, FetchSizeTooBig: lib.Variant<'QueryFailed', lib.VariantUnit<'FetchSizeTooBig'>>, InvalidSingularParameters: lib.Variant<'QueryFailed', lib.VariantUnit<'InvalidSingularParameters'>>, CapacityLimit: lib.Variant<'QueryFailed', lib.VariantUnit<'CapacityLimit'>> }, TooComplex: lib.VariantUnit<'TooComplex'>, InternalError: lib.VariantUnit<'InternalError'> } = { ...{ NotPermitted: <const T extends lib.String>(value: T): lib.Variant<'NotPermitted', T> => ({ kind: 'NotPermitted', value }), InstructionFailed: { Evaluate: { Unsupported: { Register: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.Register }), Unregister: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.Unregister }), Mint: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.Mint }), Burn: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.Burn }), Transfer: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.Transfer }), SetKeyValue: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.SetKeyValue }), RemoveKeyValue: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.RemoveKeyValue }), Grant: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.Grant }), Revoke: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.Revoke }), ExecuteTrigger: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.ExecuteTrigger }), SetParameter: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.SetParameter }), Upgrade: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.Upgrade }), Log: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.Log }), Custom: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Unsupported.Custom }) }, PermissionParameter: <const T extends lib.String>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.PermissionParameter(value) }), Type: { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Evaluate.Type.AssetNumericSpec(value) }) } }, Query: { Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Find.PublicKey(value) }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Conversion', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.Conversion(value) }), NotFound: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'NotFound'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.NotFound }), CursorMismatch: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.CursorMismatch }), CursorDone: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.CursorDone }), FetchSizeTooBig: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.FetchSizeTooBig }), InvalidSingularParameters: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.InvalidSingularParameters }), CapacityLimit: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Query.CapacityLimit }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Conversion', T>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Conversion(value) }), Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Account', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Block', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Role', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Find.PublicKey(value) }) }, Repetition: <const T extends RepetitionError>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Repetition', T>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Repetition(value) }), Mintability: { MintUnmintable: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Mintability.MintUnmintable }), ForbidMintOnMintable: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Mintability.ForbidMintOnMintable }) }, Math: { Overflow: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Overflow'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Math.Overflow }), NotEnoughQuantity: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Math.NotEnoughQuantity }), DivideByZero: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Math.DivideByZero }), NegativeValue: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Math.NegativeValue }), DomainViolation: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Math.DomainViolation }), Unknown: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Unknown'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.Math.Unknown }), FixedPointConversion: <const T extends lib.String>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.Math.FixedPointConversion(value) }) }, InvalidParameter: { Wasm: <const T extends lib.String>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.InvalidParameter.Wasm(value) }), TimeTriggerInThePast: Object.freeze<lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>>>({ kind: 'InstructionFailed', value: InstructionExecutionError.InvalidParameter.TimeTriggerInThePast }) }, InvariantViolation: <const T extends lib.String>(value: T): lib.Variant<'InstructionFailed', lib.Variant<'InvariantViolation', T>> => ({ kind: 'InstructionFailed', value: InstructionExecutionError.InvariantViolation(value) }) }, QueryFailed: { Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Account', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Block', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Role', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Find.PublicKey(value) }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'QueryFailed', lib.Variant<'Conversion', T>> => ({ kind: 'QueryFailed', value: QueryExecutionFail.Conversion(value) }), NotFound: Object.freeze<lib.Variant<'QueryFailed', lib.VariantUnit<'NotFound'>>>({ kind: 'QueryFailed', value: QueryExecutionFail.NotFound }), CursorMismatch: Object.freeze<lib.Variant<'QueryFailed', lib.VariantUnit<'CursorMismatch'>>>({ kind: 'QueryFailed', value: QueryExecutionFail.CursorMismatch }), CursorDone: Object.freeze<lib.Variant<'QueryFailed', lib.VariantUnit<'CursorDone'>>>({ kind: 'QueryFailed', value: QueryExecutionFail.CursorDone }), FetchSizeTooBig: Object.freeze<lib.Variant<'QueryFailed', lib.VariantUnit<'FetchSizeTooBig'>>>({ kind: 'QueryFailed', value: QueryExecutionFail.FetchSizeTooBig }), InvalidSingularParameters: Object.freeze<lib.Variant<'QueryFailed', lib.VariantUnit<'InvalidSingularParameters'>>>({ kind: 'QueryFailed', value: QueryExecutionFail.InvalidSingularParameters }), CapacityLimit: Object.freeze<lib.Variant<'QueryFailed', lib.VariantUnit<'CapacityLimit'>>>({ kind: 'QueryFailed', value: QueryExecutionFail.CapacityLimit }) }, TooComplex: Object.freeze({ kind: 'TooComplex' }), InternalError: Object.freeze({ kind: 'InternalError' }) }, ...lib.defineCodec(lib.enumCodec<{ NotPermitted: [lib.String], InstructionFailed: [InstructionExecutionError], QueryFailed: [QueryExecutionFail], TooComplex: [], InternalError: [] }>({ NotPermitted: [0, lib.getCodec(lib.String)], InstructionFailed: [1, lib.getCodec(InstructionExecutionError)], QueryFailed: [2, lib.getCodec(QueryExecutionFail)], TooComplex: [3], InternalError: [4] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface InstructionExecutionFail { instruction: InstructionBox, reason: lib.String }
/**
 * Codec of the structure.
 */
export const InstructionExecutionFail: lib.CodecContainer<InstructionExecutionFail> = lib.defineCodec(lib.structCodec<InstructionExecutionFail>(['instruction', 'reason'], {instruction: lib.lazyCodec(() => lib.getCodec(InstructionBox)), reason: lib.getCodec(lib.String)}))

/**
 * Structure with named fields.
 */
export interface WasmExecutionFail { reason: lib.String }
/**
 * Codec of the structure.
 */
export const WasmExecutionFail: lib.CodecContainer<WasmExecutionFail> = lib.defineCodec(lib.structCodec<WasmExecutionFail>(['reason'], {reason: lib.getCodec(lib.String)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `AccountDoesNotExist`
 * - `LimitCheck`
 * - `Validation`
 * - `InstructionExecution`
 * - `WasmExecution`
 * 
 * TODO how to construct, how to use
 */
export type TransactionRejectionReason = lib.Variant<'AccountDoesNotExist', FindError> | lib.Variant<'LimitCheck', TransactionLimitError> | lib.Variant<'Validation', ValidationFail> | lib.Variant<'InstructionExecution', InstructionExecutionFail> | lib.Variant<'WasmExecution', WasmExecutionFail>
/**
 * Codec and constructors for enumeration {@link TransactionRejectionReason}.
 */
export const TransactionRejectionReason: lib.CodecContainer<TransactionRejectionReason> & { AccountDoesNotExist: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Asset', T>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'AssetDefinition', T>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Nft', T>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Account', T>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Domain', T>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'MetadataKey', T>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Block', T>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Transaction', T>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Peer', T>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Trigger', T>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Role', T>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'Permission', T>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'AccountDoesNotExist', lib.Variant<'PublicKey', T>> }, LimitCheck: <const T extends TransactionLimitError>(value: T) => lib.Variant<'LimitCheck', T>, Validation: { NotPermitted: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'NotPermitted', T>>, InstructionFailed: { Evaluate: { Unsupported: { Register: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>>>, Unregister: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>>>, Mint: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>>>, Burn: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>>>, Transfer: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>>>, SetKeyValue: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>>>, RemoveKeyValue: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>>>, Grant: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>>>, Revoke: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>>>, ExecuteTrigger: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>>>, SetParameter: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>>>, Upgrade: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>>>, Log: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>>>, Custom: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>>> }, PermissionParameter: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>>>, Type: { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>>>> } }, Query: { Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Conversion', T>>>>, NotFound: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'NotFound'>>>>, CursorMismatch: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>>>, CursorDone: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>>>, FetchSizeTooBig: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>>>, InvalidSingularParameters: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>>>, CapacityLimit: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Conversion', T>>>, Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>> }, Repetition: <const T extends RepetitionError>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Repetition', T>>>, Mintability: { MintUnmintable: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>>>, ForbidMintOnMintable: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>>> }, Math: { Overflow: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Overflow'>>>>, NotEnoughQuantity: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>>>, DivideByZero: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>>>, NegativeValue: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>>>, DomainViolation: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>>>, Unknown: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Unknown'>>>>, FixedPointConversion: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>>>> }, InvalidParameter: { Wasm: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>>>, TimeTriggerInThePast: lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>>> }, InvariantViolation: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvariantViolation', T>>> }, QueryFailed: { Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Conversion', T>>>, NotFound: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'NotFound'>>>, CursorMismatch: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorMismatch'>>>, CursorDone: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorDone'>>>, FetchSizeTooBig: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'FetchSizeTooBig'>>>, InvalidSingularParameters: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'InvalidSingularParameters'>>>, CapacityLimit: lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CapacityLimit'>>> }, TooComplex: lib.Variant<'Validation', lib.VariantUnit<'TooComplex'>>, InternalError: lib.Variant<'Validation', lib.VariantUnit<'InternalError'>> }, InstructionExecution: <const T extends InstructionExecutionFail>(value: T) => lib.Variant<'InstructionExecution', T>, WasmExecution: <const T extends WasmExecutionFail>(value: T) => lib.Variant<'WasmExecution', T> } = { ...{ AccountDoesNotExist: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'Asset', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'AssetDefinition', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'Nft', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'Account', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'Domain', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'MetadataKey', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'Block', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'Transaction', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'Peer', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'Trigger', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'Role', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'Permission', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'AccountDoesNotExist', lib.Variant<'PublicKey', T>> => ({ kind: 'AccountDoesNotExist', value: FindError.PublicKey(value) }) }, LimitCheck: <const T extends TransactionLimitError>(value: T): lib.Variant<'LimitCheck', T> => ({ kind: 'LimitCheck', value }), Validation: { NotPermitted: <const T extends lib.String>(value: T): lib.Variant<'Validation', lib.Variant<'NotPermitted', T>> => ({ kind: 'Validation', value: ValidationFail.NotPermitted(value) }), InstructionFailed: { Evaluate: { Unsupported: { Register: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Register }), Unregister: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Unregister }), Mint: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Mint }), Burn: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Burn }), Transfer: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Transfer }), SetKeyValue: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.SetKeyValue }), RemoveKeyValue: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.RemoveKeyValue }), Grant: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Grant }), Revoke: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Revoke }), ExecuteTrigger: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.ExecuteTrigger }), SetParameter: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.SetParameter }), Upgrade: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Upgrade }), Log: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Log }), Custom: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Unsupported.Custom }) }, PermissionParameter: <const T extends lib.String>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.PermissionParameter(value) }), Type: { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Evaluate.Type.AssetNumericSpec(value) }) } }, Query: { Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Find.PublicKey(value) }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Conversion', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.Conversion(value) }), NotFound: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'NotFound'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.NotFound }), CursorMismatch: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.CursorMismatch }), CursorDone: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.CursorDone }), FetchSizeTooBig: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.FetchSizeTooBig }), InvalidSingularParameters: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.InvalidSingularParameters }), CapacityLimit: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Query.CapacityLimit }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Conversion', T>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Conversion(value) }), Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Find.PublicKey(value) }) }, Repetition: <const T extends RepetitionError>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Repetition', T>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Repetition(value) }), Mintability: { MintUnmintable: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Mintability.MintUnmintable }), ForbidMintOnMintable: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Mintability.ForbidMintOnMintable }) }, Math: { Overflow: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Overflow'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Math.Overflow }), NotEnoughQuantity: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Math.NotEnoughQuantity }), DivideByZero: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Math.DivideByZero }), NegativeValue: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Math.NegativeValue }), DomainViolation: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Math.DomainViolation }), Unknown: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Unknown'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.Math.Unknown }), FixedPointConversion: <const T extends lib.String>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.Math.FixedPointConversion(value) }) }, InvalidParameter: { Wasm: <const T extends lib.String>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.InvalidParameter.Wasm(value) }), TimeTriggerInThePast: Object.freeze<lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>>>>({ kind: 'Validation', value: ValidationFail.InstructionFailed.InvalidParameter.TimeTriggerInThePast }) }, InvariantViolation: <const T extends lib.String>(value: T): lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvariantViolation', T>>> => ({ kind: 'Validation', value: ValidationFail.InstructionFailed.InvariantViolation(value) }) }, QueryFailed: { Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Find.PublicKey(value) }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Conversion', T>>> => ({ kind: 'Validation', value: ValidationFail.QueryFailed.Conversion(value) }), NotFound: Object.freeze<lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'NotFound'>>>>({ kind: 'Validation', value: ValidationFail.QueryFailed.NotFound }), CursorMismatch: Object.freeze<lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorMismatch'>>>>({ kind: 'Validation', value: ValidationFail.QueryFailed.CursorMismatch }), CursorDone: Object.freeze<lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorDone'>>>>({ kind: 'Validation', value: ValidationFail.QueryFailed.CursorDone }), FetchSizeTooBig: Object.freeze<lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'FetchSizeTooBig'>>>>({ kind: 'Validation', value: ValidationFail.QueryFailed.FetchSizeTooBig }), InvalidSingularParameters: Object.freeze<lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'InvalidSingularParameters'>>>>({ kind: 'Validation', value: ValidationFail.QueryFailed.InvalidSingularParameters }), CapacityLimit: Object.freeze<lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CapacityLimit'>>>>({ kind: 'Validation', value: ValidationFail.QueryFailed.CapacityLimit }) }, TooComplex: Object.freeze<lib.Variant<'Validation', lib.VariantUnit<'TooComplex'>>>({ kind: 'Validation', value: ValidationFail.TooComplex }), InternalError: Object.freeze<lib.Variant<'Validation', lib.VariantUnit<'InternalError'>>>({ kind: 'Validation', value: ValidationFail.InternalError }) }, InstructionExecution: <const T extends InstructionExecutionFail>(value: T): lib.Variant<'InstructionExecution', T> => ({ kind: 'InstructionExecution', value }), WasmExecution: <const T extends WasmExecutionFail>(value: T): lib.Variant<'WasmExecution', T> => ({ kind: 'WasmExecution', value }) }, ...lib.defineCodec(lib.enumCodec<{ AccountDoesNotExist: [FindError], LimitCheck: [TransactionLimitError], Validation: [ValidationFail], InstructionExecution: [InstructionExecutionFail], WasmExecution: [WasmExecutionFail] }>({ AccountDoesNotExist: [0, lib.getCodec(FindError)], LimitCheck: [1, lib.getCodec(TransactionLimitError)], Validation: [2, lib.getCodec(ValidationFail)], InstructionExecution: [3, lib.getCodec(InstructionExecutionFail)], WasmExecution: [4, lib.getCodec(WasmExecutionFail)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Queued`
 * - `Expired`
 * - `Approved`
 * - `Rejected`
 * 
 * TODO how to construct, how to use
 */
export type TransactionStatus = lib.VariantUnit<'Queued'> | lib.VariantUnit<'Expired'> | lib.VariantUnit<'Approved'> | lib.Variant<'Rejected', TransactionRejectionReason>
/**
 * Codec and constructors for enumeration {@link TransactionStatus}.
 */
export const TransactionStatus: lib.CodecContainer<TransactionStatus> & { Queued: lib.VariantUnit<'Queued'>, Expired: lib.VariantUnit<'Expired'>, Approved: lib.VariantUnit<'Approved'>, Rejected: { AccountDoesNotExist: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Asset', T>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'AssetDefinition', T>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Nft', T>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Account', T>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Domain', T>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'MetadataKey', T>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Block', T>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Transaction', T>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Peer', T>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Trigger', T>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Role', T>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Permission', T>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'PublicKey', T>>> }, LimitCheck: <const T extends TransactionLimitError>(value: T) => lib.Variant<'Rejected', lib.Variant<'LimitCheck', T>>, Validation: { NotPermitted: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'NotPermitted', T>>>, InstructionFailed: { Evaluate: { Unsupported: { Register: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>>>>, Unregister: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>>>>, Mint: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>>>>, Burn: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>>>>, Transfer: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>>>>, SetKeyValue: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>>>>, RemoveKeyValue: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>>>>, Grant: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>>>>, Revoke: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>>>>, ExecuteTrigger: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>>>>, SetParameter: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>>>>, Upgrade: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>>>>, Log: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>>>>, Custom: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>>>> }, PermissionParameter: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>>>>, Type: { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>>>>> } }, Query: { Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Conversion', T>>>>>, NotFound: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'NotFound'>>>>>, CursorMismatch: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>>>>, CursorDone: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>>>>, FetchSizeTooBig: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>>>>, InvalidSingularParameters: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>>>>, CapacityLimit: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>>>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Conversion', T>>>>, Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>> }, Repetition: <const T extends RepetitionError>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Repetition', T>>>>, Mintability: { MintUnmintable: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>>>>, ForbidMintOnMintable: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>>>> }, Math: { Overflow: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Overflow'>>>>>, NotEnoughQuantity: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>>>>, DivideByZero: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>>>>, NegativeValue: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>>>>, DomainViolation: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>>>>, Unknown: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Unknown'>>>>>, FixedPointConversion: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>>>>> }, InvalidParameter: { Wasm: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>>>>, TimeTriggerInThePast: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>>>> }, InvariantViolation: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvariantViolation', T>>>> }, QueryFailed: { Find: { Asset: <const T extends lib.AssetId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>>>, MetadataKey: <const T extends lib.Name>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>>, Block: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>>>, Transaction: <const T extends lib.Hash>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>>, Peer: <const T extends PeerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>>>, Permission: <const T extends Permission>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>>>, PublicKey: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>> }, Conversion: <const T extends lib.String>(value: T) => lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Conversion', T>>>>, NotFound: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'NotFound'>>>>, CursorMismatch: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorMismatch'>>>>, CursorDone: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorDone'>>>>, FetchSizeTooBig: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'FetchSizeTooBig'>>>>, InvalidSingularParameters: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'InvalidSingularParameters'>>>>, CapacityLimit: lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CapacityLimit'>>>> }, TooComplex: lib.Variant<'Rejected', lib.Variant<'Validation', lib.VariantUnit<'TooComplex'>>>, InternalError: lib.Variant<'Rejected', lib.Variant<'Validation', lib.VariantUnit<'InternalError'>>> }, InstructionExecution: <const T extends InstructionExecutionFail>(value: T) => lib.Variant<'Rejected', lib.Variant<'InstructionExecution', T>>, WasmExecution: <const T extends WasmExecutionFail>(value: T) => lib.Variant<'Rejected', lib.Variant<'WasmExecution', T>> } } = { ...{ Queued: Object.freeze({ kind: 'Queued' }), Expired: Object.freeze({ kind: 'Expired' }), Approved: Object.freeze({ kind: 'Approved' }), Rejected: { AccountDoesNotExist: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Asset', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'AssetDefinition', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Nft', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Account', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Domain', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'MetadataKey', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Block', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Transaction', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Peer', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Trigger', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Role', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'Permission', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'Rejected', lib.Variant<'AccountDoesNotExist', lib.Variant<'PublicKey', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.AccountDoesNotExist.PublicKey(value) }) }, LimitCheck: <const T extends TransactionLimitError>(value: T): lib.Variant<'Rejected', lib.Variant<'LimitCheck', T>> => ({ kind: 'Rejected', value: TransactionRejectionReason.LimitCheck(value) }), Validation: { NotPermitted: <const T extends lib.String>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'NotPermitted', T>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.NotPermitted(value) }), InstructionFailed: { Evaluate: { Unsupported: { Register: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Register'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Register }), Unregister: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Unregister'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Unregister }), Mint: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Mint'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Mint }), Burn: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Burn'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Burn }), Transfer: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Transfer'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Transfer }), SetKeyValue: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetKeyValue'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.SetKeyValue }), RemoveKeyValue: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'RemoveKeyValue'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.RemoveKeyValue }), Grant: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Grant'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Grant }), Revoke: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Revoke'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Revoke }), ExecuteTrigger: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'ExecuteTrigger'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.ExecuteTrigger }), SetParameter: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'SetParameter'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.SetParameter }), Upgrade: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Upgrade'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Upgrade }), Log: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Log'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Log }), Custom: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Unsupported', lib.VariantUnit<'Custom'>>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Unsupported.Custom }) }, PermissionParameter: <const T extends lib.String>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'PermissionParameter', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.PermissionParameter(value) }), Type: { AssetNumericSpec: <const T extends Mismatch<NumericSpec>>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Evaluate', lib.Variant<'Type', lib.Variant<'AssetNumericSpec', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Evaluate.Type.AssetNumericSpec(value) }) } }, Query: { Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Asset', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Nft', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Account', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Domain', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Block', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Peer', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Role', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'Permission', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Find.PublicKey(value) }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.Variant<'Conversion', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.Conversion(value) }), NotFound: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'NotFound'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.NotFound }), CursorMismatch: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorMismatch'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.CursorMismatch }), CursorDone: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CursorDone'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.CursorDone }), FetchSizeTooBig: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'FetchSizeTooBig'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.FetchSizeTooBig }), InvalidSingularParameters: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'InvalidSingularParameters'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.InvalidSingularParameters }), CapacityLimit: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Query', lib.VariantUnit<'CapacityLimit'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Query.CapacityLimit }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Conversion', T>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Conversion(value) }), Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Find.PublicKey(value) }) }, Repetition: <const T extends RepetitionError>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Repetition', T>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Repetition(value) }), Mintability: { MintUnmintable: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'MintUnmintable'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Mintability.MintUnmintable }), ForbidMintOnMintable: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Mintability', lib.VariantUnit<'ForbidMintOnMintable'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Mintability.ForbidMintOnMintable }) }, Math: { Overflow: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Overflow'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Math.Overflow }), NotEnoughQuantity: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NotEnoughQuantity'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Math.NotEnoughQuantity }), DivideByZero: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DivideByZero'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Math.DivideByZero }), NegativeValue: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'NegativeValue'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Math.NegativeValue }), DomainViolation: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'DomainViolation'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Math.DomainViolation }), Unknown: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.VariantUnit<'Unknown'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Math.Unknown }), FixedPointConversion: <const T extends lib.String>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'Math', lib.Variant<'FixedPointConversion', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.Math.FixedPointConversion(value) }) }, InvalidParameter: { Wasm: <const T extends lib.String>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.Variant<'Wasm', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.InvalidParameter.Wasm(value) }), TimeTriggerInThePast: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvalidParameter', lib.VariantUnit<'TimeTriggerInThePast'>>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.InvalidParameter.TimeTriggerInThePast }) }, InvariantViolation: <const T extends lib.String>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'InstructionFailed', lib.Variant<'InvariantViolation', T>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InstructionFailed.InvariantViolation(value) }) }, QueryFailed: { Find: { Asset: <const T extends lib.AssetId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Asset', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.Asset(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'AssetDefinition', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Nft', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.Nft(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Account', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.Account(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Domain', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.Domain(value) }), MetadataKey: <const T extends lib.Name>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'MetadataKey', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.MetadataKey(value) }), Block: <const T extends lib.Hash>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Block', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.Block(value) }), Transaction: <const T extends lib.Hash>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Transaction', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.Transaction(value) }), Peer: <const T extends PeerId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Peer', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.Peer(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Trigger', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.Trigger(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Role', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.Role(value) }), Permission: <const T extends Permission>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'Permission', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.Permission(value) }), PublicKey: <const T extends lib.PublicKey>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Find', lib.Variant<'PublicKey', T>>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Find.PublicKey(value) }) }, Conversion: <const T extends lib.String>(value: T): lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.Variant<'Conversion', T>>>> => ({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.Conversion(value) }), NotFound: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'NotFound'>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.NotFound }), CursorMismatch: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorMismatch'>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.CursorMismatch }), CursorDone: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CursorDone'>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.CursorDone }), FetchSizeTooBig: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'FetchSizeTooBig'>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.FetchSizeTooBig }), InvalidSingularParameters: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'InvalidSingularParameters'>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.InvalidSingularParameters }), CapacityLimit: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.Variant<'QueryFailed', lib.VariantUnit<'CapacityLimit'>>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.QueryFailed.CapacityLimit }) }, TooComplex: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.VariantUnit<'TooComplex'>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.TooComplex }), InternalError: Object.freeze<lib.Variant<'Rejected', lib.Variant<'Validation', lib.VariantUnit<'InternalError'>>>>({ kind: 'Rejected', value: TransactionRejectionReason.Validation.InternalError }) }, InstructionExecution: <const T extends InstructionExecutionFail>(value: T): lib.Variant<'Rejected', lib.Variant<'InstructionExecution', T>> => ({ kind: 'Rejected', value: TransactionRejectionReason.InstructionExecution(value) }), WasmExecution: <const T extends WasmExecutionFail>(value: T): lib.Variant<'Rejected', lib.Variant<'WasmExecution', T>> => ({ kind: 'Rejected', value: TransactionRejectionReason.WasmExecution(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Queued: [], Expired: [], Approved: [], Rejected: [TransactionRejectionReason] }>({ Queued: [0], Expired: [1], Approved: [2], Rejected: [3, lib.getCodec(TransactionRejectionReason)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface TransactionEventFilter { hash: lib.Option<lib.Hash>, blockHeight: lib.Option<lib.Option<lib.NonZero<lib.U64>>>, status: lib.Option<TransactionStatus> }
/**
 * Codec of the structure.
 */
export const TransactionEventFilter: lib.CodecContainer<TransactionEventFilter> = lib.defineCodec(lib.structCodec<TransactionEventFilter>(['hash', 'blockHeight', 'status'], {hash: lib.Option.with(lib.getCodec(lib.Hash)), blockHeight: lib.Option.with(lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U64)))), status: lib.Option.with(lib.getCodec(TransactionStatus))}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `ConsensusBlockRejection`
 * 
 * TODO how to construct, how to use
 */
export type BlockRejectionReason = lib.VariantUnit<'ConsensusBlockRejection'>
/**
 * Codec and constructors for enumeration {@link BlockRejectionReason}.
 */
export const BlockRejectionReason: lib.CodecContainer<BlockRejectionReason> & { ConsensusBlockRejection: lib.VariantUnit<'ConsensusBlockRejection'> } = { ...{ ConsensusBlockRejection: Object.freeze({ kind: 'ConsensusBlockRejection' }) }, ...lib.defineCodec(lib.enumCodec<{ ConsensusBlockRejection: [] }>({ ConsensusBlockRejection: [0] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Approved`
 * - `Rejected`
 * - `Committed`
 * - `Applied`
 * 
 * TODO how to construct, how to use
 */
export type BlockStatus = lib.VariantUnit<'Created'> | lib.VariantUnit<'Approved'> | lib.Variant<'Rejected', BlockRejectionReason> | lib.VariantUnit<'Committed'> | lib.VariantUnit<'Applied'>
/**
 * Codec and constructors for enumeration {@link BlockStatus}.
 */
export const BlockStatus: lib.CodecContainer<BlockStatus> & { Created: lib.VariantUnit<'Created'>, Approved: lib.VariantUnit<'Approved'>, Rejected: { ConsensusBlockRejection: lib.Variant<'Rejected', lib.VariantUnit<'ConsensusBlockRejection'>> }, Committed: lib.VariantUnit<'Committed'>, Applied: lib.VariantUnit<'Applied'> } = { ...{ Created: Object.freeze({ kind: 'Created' }), Approved: Object.freeze({ kind: 'Approved' }), Rejected: { ConsensusBlockRejection: Object.freeze<lib.Variant<'Rejected', lib.VariantUnit<'ConsensusBlockRejection'>>>({ kind: 'Rejected', value: BlockRejectionReason.ConsensusBlockRejection }) }, Committed: Object.freeze({ kind: 'Committed' }), Applied: Object.freeze({ kind: 'Applied' }) }, ...lib.defineCodec(lib.enumCodec<{ Created: [], Approved: [], Rejected: [BlockRejectionReason], Committed: [], Applied: [] }>({ Created: [0], Approved: [1], Rejected: [2, lib.getCodec(BlockRejectionReason)], Committed: [3], Applied: [4] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface BlockEventFilter { height: lib.Option<lib.NonZero<lib.U64>>, status: lib.Option<BlockStatus> }
/**
 * Codec of the structure.
 */
export const BlockEventFilter: lib.CodecContainer<BlockEventFilter> = lib.defineCodec(lib.structCodec<BlockEventFilter>(['height', 'status'], {height: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U64))), status: lib.Option.with(lib.getCodec(BlockStatus))}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Transaction`
 * - `Block`
 * 
 * TODO how to construct, how to use
 */
export type PipelineEventFilterBox = lib.Variant<'Transaction', TransactionEventFilter> | lib.Variant<'Block', BlockEventFilter>
/**
 * Codec and constructors for enumeration {@link PipelineEventFilterBox}.
 */
export const PipelineEventFilterBox: lib.CodecContainer<PipelineEventFilterBox> & { Transaction: <const T extends TransactionEventFilter>(value: T) => lib.Variant<'Transaction', T>, Block: <const T extends BlockEventFilter>(value: T) => lib.Variant<'Block', T> } = { ...{ Transaction: <const T extends TransactionEventFilter>(value: T): lib.Variant<'Transaction', T> => ({ kind: 'Transaction', value }), Block: <const T extends BlockEventFilter>(value: T): lib.Variant<'Block', T> => ({ kind: 'Block', value }) }, ...lib.defineCodec(lib.enumCodec<{ Transaction: [TransactionEventFilter], Block: [BlockEventFilter] }>({ Transaction: [0, lib.getCodec(TransactionEventFilter)], Block: [1, lib.getCodec(BlockEventFilter)] }).discriminated()) }

export type PeerEventSet = Set<'Added' | 'Removed'>
export const PeerEventSet: lib.CodecContainer<PeerEventSet> = lib.defineCodec(lib.bitmapCodec<PeerEventSet extends Set<infer T> ? T : never>({ Added: 1, Removed: 2 }))

/**
 * Structure with named fields.
 */
export interface PeerEventFilter { idMatcher: lib.Option<PeerId>, eventSet: PeerEventSet }
/**
 * Codec of the structure.
 */
export const PeerEventFilter: lib.CodecContainer<PeerEventFilter> = lib.defineCodec(lib.structCodec<PeerEventFilter>(['idMatcher', 'eventSet'], {idMatcher: lib.Option.with(lib.getCodec(PeerId)), eventSet: lib.getCodec(PeerEventSet)}))

export type DomainEventSet = Set<'Created' | 'Deleted' | 'AnyAssetDefinition' | 'AnyNft' | 'AnyAccount' | 'MetadataInserted' | 'MetadataRemoved' | 'OwnerChanged'>
export const DomainEventSet: lib.CodecContainer<DomainEventSet> = lib.defineCodec(lib.bitmapCodec<DomainEventSet extends Set<infer T> ? T : never>({ Created: 1, Deleted: 2, AnyAssetDefinition: 4, AnyNft: 8, AnyAccount: 16, MetadataInserted: 32, MetadataRemoved: 64, OwnerChanged: 128 }))

/**
 * Structure with named fields.
 */
export interface DomainEventFilter { idMatcher: lib.Option<lib.DomainId>, eventSet: DomainEventSet }
/**
 * Codec of the structure.
 */
export const DomainEventFilter: lib.CodecContainer<DomainEventFilter> = lib.defineCodec(lib.structCodec<DomainEventFilter>(['idMatcher', 'eventSet'], {idMatcher: lib.Option.with(lib.getCodec(lib.DomainId)), eventSet: lib.getCodec(DomainEventSet)}))

export type AssetEventSet = Set<'Created' | 'Deleted' | 'Added' | 'Removed'>
export const AssetEventSet: lib.CodecContainer<AssetEventSet> = lib.defineCodec(lib.bitmapCodec<AssetEventSet extends Set<infer T> ? T : never>({ Created: 1, Deleted: 2, Added: 4, Removed: 8 }))

/**
 * Structure with named fields.
 */
export interface AssetEventFilter { idMatcher: lib.Option<lib.AssetId>, eventSet: AssetEventSet }
/**
 * Codec of the structure.
 */
export const AssetEventFilter: lib.CodecContainer<AssetEventFilter> = lib.defineCodec(lib.structCodec<AssetEventFilter>(['idMatcher', 'eventSet'], {idMatcher: lib.Option.with(lib.getCodec(lib.AssetId)), eventSet: lib.getCodec(AssetEventSet)}))

export type AssetDefinitionEventSet = Set<'Created' | 'Deleted' | 'MetadataInserted' | 'MetadataRemoved' | 'MintabilityChanged' | 'TotalQuantityChanged' | 'OwnerChanged'>
export const AssetDefinitionEventSet: lib.CodecContainer<AssetDefinitionEventSet> = lib.defineCodec(lib.bitmapCodec<AssetDefinitionEventSet extends Set<infer T> ? T : never>({ Created: 1, Deleted: 2, MetadataInserted: 4, MetadataRemoved: 8, MintabilityChanged: 16, TotalQuantityChanged: 32, OwnerChanged: 64 }))

/**
 * Structure with named fields.
 */
export interface AssetDefinitionEventFilter { idMatcher: lib.Option<lib.AssetDefinitionId>, eventSet: AssetDefinitionEventSet }
/**
 * Codec of the structure.
 */
export const AssetDefinitionEventFilter: lib.CodecContainer<AssetDefinitionEventFilter> = lib.defineCodec(lib.structCodec<AssetDefinitionEventFilter>(['idMatcher', 'eventSet'], {idMatcher: lib.Option.with(lib.getCodec(lib.AssetDefinitionId)), eventSet: lib.getCodec(AssetDefinitionEventSet)}))

export type NftEventSet = Set<'Created' | 'Deleted' | 'MetadataInserted' | 'MetadataRemoved' | 'OwnerChanged'>
export const NftEventSet: lib.CodecContainer<NftEventSet> = lib.defineCodec(lib.bitmapCodec<NftEventSet extends Set<infer T> ? T : never>({ Created: 1, Deleted: 2, MetadataInserted: 4, MetadataRemoved: 8, OwnerChanged: 16 }))

/**
 * Structure with named fields.
 */
export interface NftEventFilter { idMatcher: lib.Option<lib.NftId>, eventSet: NftEventSet }
/**
 * Codec of the structure.
 */
export const NftEventFilter: lib.CodecContainer<NftEventFilter> = lib.defineCodec(lib.structCodec<NftEventFilter>(['idMatcher', 'eventSet'], {idMatcher: lib.Option.with(lib.getCodec(lib.NftId)), eventSet: lib.getCodec(NftEventSet)}))

export type TriggerEventSet = Set<'Created' | 'Deleted' | 'Extended' | 'Shortened' | 'MetadataInserted' | 'MetadataRemoved'>
export const TriggerEventSet: lib.CodecContainer<TriggerEventSet> = lib.defineCodec(lib.bitmapCodec<TriggerEventSet extends Set<infer T> ? T : never>({ Created: 1, Deleted: 2, Extended: 4, Shortened: 8, MetadataInserted: 16, MetadataRemoved: 32 }))

/**
 * Structure with named fields.
 */
export interface TriggerEventFilter { idMatcher: lib.Option<TriggerId>, eventSet: TriggerEventSet }
/**
 * Codec of the structure.
 */
export const TriggerEventFilter: lib.CodecContainer<TriggerEventFilter> = lib.defineCodec(lib.structCodec<TriggerEventFilter>(['idMatcher', 'eventSet'], {idMatcher: lib.Option.with(lib.getCodec(TriggerId)), eventSet: lib.getCodec(TriggerEventSet)}))

export type RoleEventSet = Set<'Created' | 'Deleted' | 'PermissionAdded' | 'PermissionRemoved'>
export const RoleEventSet: lib.CodecContainer<RoleEventSet> = lib.defineCodec(lib.bitmapCodec<RoleEventSet extends Set<infer T> ? T : never>({ Created: 1, Deleted: 2, PermissionAdded: 4, PermissionRemoved: 8 }))

/**
 * Structure with named fields.
 */
export interface RoleEventFilter { idMatcher: lib.Option<RoleId>, eventSet: RoleEventSet }
/**
 * Codec of the structure.
 */
export const RoleEventFilter: lib.CodecContainer<RoleEventFilter> = lib.defineCodec(lib.structCodec<RoleEventFilter>(['idMatcher', 'eventSet'], {idMatcher: lib.Option.with(lib.getCodec(RoleId)), eventSet: lib.getCodec(RoleEventSet)}))

export type ConfigurationEventSet = Set<'Changed'>
export const ConfigurationEventSet: lib.CodecContainer<ConfigurationEventSet> = lib.defineCodec(lib.bitmapCodec<ConfigurationEventSet extends Set<infer T> ? T : never>({ Changed: 1 }))

/**
 * Structure with named fields.
 */
export interface ConfigurationEventFilter { eventSet: ConfigurationEventSet }
/**
 * Codec of the structure.
 */
export const ConfigurationEventFilter: lib.CodecContainer<ConfigurationEventFilter> = lib.defineCodec(lib.structCodec<ConfigurationEventFilter>(['eventSet'], {eventSet: lib.getCodec(ConfigurationEventSet)}))

export type ExecutorEventSet = Set<'Upgraded'>
export const ExecutorEventSet: lib.CodecContainer<ExecutorEventSet> = lib.defineCodec(lib.bitmapCodec<ExecutorEventSet extends Set<infer T> ? T : never>({ Upgraded: 1 }))

/**
 * Structure with named fields.
 */
export interface ExecutorEventFilter { eventSet: ExecutorEventSet }
/**
 * Codec of the structure.
 */
export const ExecutorEventFilter: lib.CodecContainer<ExecutorEventFilter> = lib.defineCodec(lib.structCodec<ExecutorEventFilter>(['eventSet'], {eventSet: lib.getCodec(ExecutorEventSet)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Any`
 * - `Peer`
 * - `Domain`
 * - `Account`
 * - `Asset`
 * - `AssetDefinition`
 * - `Nft`
 * - `Trigger`
 * - `Role`
 * - `Configuration`
 * - `Executor`
 * 
 * TODO how to construct, how to use
 */
export type DataEventFilter = lib.VariantUnit<'Any'> | lib.Variant<'Peer', PeerEventFilter> | lib.Variant<'Domain', DomainEventFilter> | lib.Variant<'Account', AccountEventFilter> | lib.Variant<'Asset', AssetEventFilter> | lib.Variant<'AssetDefinition', AssetDefinitionEventFilter> | lib.Variant<'Nft', NftEventFilter> | lib.Variant<'Trigger', TriggerEventFilter> | lib.Variant<'Role', RoleEventFilter> | lib.Variant<'Configuration', ConfigurationEventFilter> | lib.Variant<'Executor', ExecutorEventFilter>
/**
 * Codec and constructors for enumeration {@link DataEventFilter}.
 */
export const DataEventFilter: lib.CodecContainer<DataEventFilter> & { Any: lib.VariantUnit<'Any'>, Peer: <const T extends PeerEventFilter>(value: T) => lib.Variant<'Peer', T>, Domain: <const T extends DomainEventFilter>(value: T) => lib.Variant<'Domain', T>, Account: <const T extends AccountEventFilter>(value: T) => lib.Variant<'Account', T>, Asset: <const T extends AssetEventFilter>(value: T) => lib.Variant<'Asset', T>, AssetDefinition: <const T extends AssetDefinitionEventFilter>(value: T) => lib.Variant<'AssetDefinition', T>, Nft: <const T extends NftEventFilter>(value: T) => lib.Variant<'Nft', T>, Trigger: <const T extends TriggerEventFilter>(value: T) => lib.Variant<'Trigger', T>, Role: <const T extends RoleEventFilter>(value: T) => lib.Variant<'Role', T>, Configuration: <const T extends ConfigurationEventFilter>(value: T) => lib.Variant<'Configuration', T>, Executor: <const T extends ExecutorEventFilter>(value: T) => lib.Variant<'Executor', T> } = { ...{ Any: Object.freeze({ kind: 'Any' }), Peer: <const T extends PeerEventFilter>(value: T): lib.Variant<'Peer', T> => ({ kind: 'Peer', value }), Domain: <const T extends DomainEventFilter>(value: T): lib.Variant<'Domain', T> => ({ kind: 'Domain', value }), Account: <const T extends AccountEventFilter>(value: T): lib.Variant<'Account', T> => ({ kind: 'Account', value }), Asset: <const T extends AssetEventFilter>(value: T): lib.Variant<'Asset', T> => ({ kind: 'Asset', value }), AssetDefinition: <const T extends AssetDefinitionEventFilter>(value: T): lib.Variant<'AssetDefinition', T> => ({ kind: 'AssetDefinition', value }), Nft: <const T extends NftEventFilter>(value: T): lib.Variant<'Nft', T> => ({ kind: 'Nft', value }), Trigger: <const T extends TriggerEventFilter>(value: T): lib.Variant<'Trigger', T> => ({ kind: 'Trigger', value }), Role: <const T extends RoleEventFilter>(value: T): lib.Variant<'Role', T> => ({ kind: 'Role', value }), Configuration: <const T extends ConfigurationEventFilter>(value: T): lib.Variant<'Configuration', T> => ({ kind: 'Configuration', value }), Executor: <const T extends ExecutorEventFilter>(value: T): lib.Variant<'Executor', T> => ({ kind: 'Executor', value }) }, ...lib.defineCodec(lib.enumCodec<{ Any: [], Peer: [PeerEventFilter], Domain: [DomainEventFilter], Account: [AccountEventFilter], Asset: [AssetEventFilter], AssetDefinition: [AssetDefinitionEventFilter], Nft: [NftEventFilter], Trigger: [TriggerEventFilter], Role: [RoleEventFilter], Configuration: [ConfigurationEventFilter], Executor: [ExecutorEventFilter] }>({ Any: [0], Peer: [1, lib.getCodec(PeerEventFilter)], Domain: [2, lib.getCodec(DomainEventFilter)], Account: [3, lib.getCodec(AccountEventFilter)], Asset: [4, lib.getCodec(AssetEventFilter)], AssetDefinition: [5, lib.getCodec(AssetDefinitionEventFilter)], Nft: [6, lib.getCodec(NftEventFilter)], Trigger: [7, lib.getCodec(TriggerEventFilter)], Role: [8, lib.getCodec(RoleEventFilter)], Configuration: [9, lib.getCodec(ConfigurationEventFilter)], Executor: [10, lib.getCodec(ExecutorEventFilter)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface Schedule { start: lib.Timestamp, period: lib.Option<lib.Duration> }
/**
 * Codec of the structure.
 */
export const Schedule: lib.CodecContainer<Schedule> = lib.defineCodec(lib.structCodec<Schedule>(['start', 'period'], {start: lib.getCodec(lib.Timestamp), period: lib.Option.with(lib.getCodec(lib.Duration))}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `PreCommit`
 * - `Schedule`
 * 
 * TODO how to construct, how to use
 */
export type ExecutionTime = lib.VariantUnit<'PreCommit'> | lib.Variant<'Schedule', Schedule>
/**
 * Codec and constructors for enumeration {@link ExecutionTime}.
 */
export const ExecutionTime: lib.CodecContainer<ExecutionTime> & { PreCommit: lib.VariantUnit<'PreCommit'>, Schedule: <const T extends Schedule>(value: T) => lib.Variant<'Schedule', T> } = { ...{ PreCommit: Object.freeze({ kind: 'PreCommit' }), Schedule: <const T extends Schedule>(value: T): lib.Variant<'Schedule', T> => ({ kind: 'Schedule', value }) }, ...lib.defineCodec(lib.enumCodec<{ PreCommit: [], Schedule: [Schedule] }>({ PreCommit: [0], Schedule: [1, lib.getCodec(Schedule)] }).discriminated()) }

export type TimeEventFilter = ExecutionTime
export const TimeEventFilter = ExecutionTime

/**
 * Structure with named fields.
 */
export interface ExecuteTriggerEventFilter { triggerId: lib.Option<TriggerId>, authority: lib.Option<lib.AccountId> }
/**
 * Codec of the structure.
 */
export const ExecuteTriggerEventFilter: lib.CodecContainer<ExecuteTriggerEventFilter> = lib.defineCodec(lib.structCodec<ExecuteTriggerEventFilter>(['triggerId', 'authority'], {triggerId: lib.Option.with(lib.getCodec(TriggerId)), authority: lib.Option.with(lib.getCodec(lib.AccountId))}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Success`
 * - `Failure`
 * 
 * TODO how to construct, how to use
 */
export type TriggerCompletedOutcomeType = lib.VariantUnit<'Success'> | lib.VariantUnit<'Failure'>
/**
 * Codec and constructors for enumeration {@link TriggerCompletedOutcomeType}.
 */
export const TriggerCompletedOutcomeType: lib.CodecContainer<TriggerCompletedOutcomeType> & { Success: lib.VariantUnit<'Success'>, Failure: lib.VariantUnit<'Failure'> } = { ...{ Success: Object.freeze({ kind: 'Success' }), Failure: Object.freeze({ kind: 'Failure' }) }, ...lib.defineCodec(lib.enumCodec<{ Success: [], Failure: [] }>({ Success: [0], Failure: [1] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface TriggerCompletedEventFilter { triggerId: lib.Option<TriggerId>, outcomeType: lib.Option<TriggerCompletedOutcomeType> }
/**
 * Codec of the structure.
 */
export const TriggerCompletedEventFilter: lib.CodecContainer<TriggerCompletedEventFilter> = lib.defineCodec(lib.structCodec<TriggerCompletedEventFilter>(['triggerId', 'outcomeType'], {triggerId: lib.Option.with(lib.getCodec(TriggerId)), outcomeType: lib.Option.with(lib.getCodec(TriggerCompletedOutcomeType))}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Pipeline`
 * - `Data`
 * - `Time`
 * - `ExecuteTrigger`
 * - `TriggerCompleted`
 * 
 * TODO how to construct, how to use
 */
export type EventFilterBox = lib.Variant<'Pipeline', PipelineEventFilterBox> | lib.Variant<'Data', DataEventFilter> | lib.Variant<'Time', TimeEventFilter> | lib.Variant<'ExecuteTrigger', ExecuteTriggerEventFilter> | lib.Variant<'TriggerCompleted', TriggerCompletedEventFilter>
/**
 * Codec and constructors for enumeration {@link EventFilterBox}.
 */
export const EventFilterBox: lib.CodecContainer<EventFilterBox> & { Pipeline: { Transaction: <const T extends TransactionEventFilter>(value: T) => lib.Variant<'Pipeline', lib.Variant<'Transaction', T>>, Block: <const T extends BlockEventFilter>(value: T) => lib.Variant<'Pipeline', lib.Variant<'Block', T>> }, Data: { Any: lib.Variant<'Data', lib.VariantUnit<'Any'>>, Peer: <const T extends PeerEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Peer', T>>, Domain: <const T extends DomainEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', T>>, Account: <const T extends AccountEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Account', T>>, Asset: <const T extends AssetEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Asset', T>>, AssetDefinition: <const T extends AssetDefinitionEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'AssetDefinition', T>>, Nft: <const T extends NftEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Nft', T>>, Trigger: <const T extends TriggerEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', T>>, Role: <const T extends RoleEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Role', T>>, Configuration: <const T extends ConfigurationEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Configuration', T>>, Executor: <const T extends ExecutorEventFilter>(value: T) => lib.Variant<'Data', lib.Variant<'Executor', T>> }, Time: { PreCommit: lib.Variant<'Time', lib.VariantUnit<'PreCommit'>>, Schedule: <const T extends Schedule>(value: T) => lib.Variant<'Time', lib.Variant<'Schedule', T>> }, ExecuteTrigger: <const T extends ExecuteTriggerEventFilter>(value: T) => lib.Variant<'ExecuteTrigger', T>, TriggerCompleted: <const T extends TriggerCompletedEventFilter>(value: T) => lib.Variant<'TriggerCompleted', T> } = { ...{ Pipeline: { Transaction: <const T extends TransactionEventFilter>(value: T): lib.Variant<'Pipeline', lib.Variant<'Transaction', T>> => ({ kind: 'Pipeline', value: PipelineEventFilterBox.Transaction(value) }), Block: <const T extends BlockEventFilter>(value: T): lib.Variant<'Pipeline', lib.Variant<'Block', T>> => ({ kind: 'Pipeline', value: PipelineEventFilterBox.Block(value) }) }, Data: { Any: Object.freeze<lib.Variant<'Data', lib.VariantUnit<'Any'>>>({ kind: 'Data', value: DataEventFilter.Any }), Peer: <const T extends PeerEventFilter>(value: T): lib.Variant<'Data', lib.Variant<'Peer', T>> => ({ kind: 'Data', value: DataEventFilter.Peer(value) }), Domain: <const T extends DomainEventFilter>(value: T): lib.Variant<'Data', lib.Variant<'Domain', T>> => ({ kind: 'Data', value: DataEventFilter.Domain(value) }), Account: <const T extends AccountEventFilter>(value: T): lib.Variant<'Data', lib.Variant<'Account', T>> => ({ kind: 'Data', value: DataEventFilter.Account(value) }), Asset: <const T extends AssetEventFilter>(value: T): lib.Variant<'Data', lib.Variant<'Asset', T>> => ({ kind: 'Data', value: DataEventFilter.Asset(value) }), AssetDefinition: <const T extends AssetDefinitionEventFilter>(value: T): lib.Variant<'Data', lib.Variant<'AssetDefinition', T>> => ({ kind: 'Data', value: DataEventFilter.AssetDefinition(value) }), Nft: <const T extends NftEventFilter>(value: T): lib.Variant<'Data', lib.Variant<'Nft', T>> => ({ kind: 'Data', value: DataEventFilter.Nft(value) }), Trigger: <const T extends TriggerEventFilter>(value: T): lib.Variant<'Data', lib.Variant<'Trigger', T>> => ({ kind: 'Data', value: DataEventFilter.Trigger(value) }), Role: <const T extends RoleEventFilter>(value: T): lib.Variant<'Data', lib.Variant<'Role', T>> => ({ kind: 'Data', value: DataEventFilter.Role(value) }), Configuration: <const T extends ConfigurationEventFilter>(value: T): lib.Variant<'Data', lib.Variant<'Configuration', T>> => ({ kind: 'Data', value: DataEventFilter.Configuration(value) }), Executor: <const T extends ExecutorEventFilter>(value: T): lib.Variant<'Data', lib.Variant<'Executor', T>> => ({ kind: 'Data', value: DataEventFilter.Executor(value) }) }, Time: { PreCommit: Object.freeze<lib.Variant<'Time', lib.VariantUnit<'PreCommit'>>>({ kind: 'Time', value: TimeEventFilter.PreCommit }), Schedule: <const T extends Schedule>(value: T): lib.Variant<'Time', lib.Variant<'Schedule', T>> => ({ kind: 'Time', value: TimeEventFilter.Schedule(value) }) }, ExecuteTrigger: <const T extends ExecuteTriggerEventFilter>(value: T): lib.Variant<'ExecuteTrigger', T> => ({ kind: 'ExecuteTrigger', value }), TriggerCompleted: <const T extends TriggerCompletedEventFilter>(value: T): lib.Variant<'TriggerCompleted', T> => ({ kind: 'TriggerCompleted', value }) }, ...lib.defineCodec(lib.enumCodec<{ Pipeline: [PipelineEventFilterBox], Data: [DataEventFilter], Time: [TimeEventFilter], ExecuteTrigger: [ExecuteTriggerEventFilter], TriggerCompleted: [TriggerCompletedEventFilter] }>({ Pipeline: [0, lib.getCodec(PipelineEventFilterBox)], Data: [1, lib.getCodec(DataEventFilter)], Time: [2, lib.getCodec(TimeEventFilter)], ExecuteTrigger: [3, lib.getCodec(ExecuteTriggerEventFilter)], TriggerCompleted: [4, lib.getCodec(TriggerCompletedEventFilter)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface Action { executable: Executable, repeats: Repeats, authority: lib.AccountId, filter: EventFilterBox, metadata: Metadata }
/**
 * Codec of the structure.
 */
export const Action: lib.CodecContainer<Action> = lib.defineCodec(lib.structCodec<Action>(['executable', 'repeats', 'authority', 'filter', 'metadata'], {executable: lib.getCodec(Executable), repeats: lib.getCodec(Repeats), authority: lib.getCodec(lib.AccountId), filter: lib.getCodec(EventFilterBox), metadata: lib.getCodec(Metadata)}))

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type ActionPredicateAtom = never
/**
 * Codec for {@link ActionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const ActionPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */
export type ActionProjectionPredicate = lib.Variant<'Atom', ActionPredicateAtom> | lib.Variant<'Metadata', MetadataProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link ActionProjectionPredicate}.
 */
export const ActionProjectionPredicate: lib.CodecContainer<ActionProjectionPredicate> & { Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>> } } = { ...{ Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T): lib.Variant<'Metadata', lib.Variant<'Key', T>> => ({ kind: 'Metadata', value: MetadataProjectionPredicate.Key(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [ActionPredicateAtom], Metadata: [MetadataProjectionPredicate] }>({ Atom: [0, lib.getCodec(ActionPredicateAtom)], Metadata: [1, lib.getCodec(MetadataProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */
export type ActionProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Metadata', MetadataProjectionSelector>
/**
 * Codec and constructors for enumeration {@link ActionProjectionSelector}.
 */
export const ActionProjectionSelector: lib.CodecContainer<ActionProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Metadata: { Atom: lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>, Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Metadata: { Atom: Object.freeze<lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>>({ kind: 'Metadata', value: MetadataProjectionSelector.Atom }), Key: <const T extends MetadataKeyProjectionSelector>(value: T): lib.Variant<'Metadata', lib.Variant<'Key', T>> => ({ kind: 'Metadata', value: MetadataProjectionSelector.Key(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Metadata: [MetadataProjectionSelector] }>({ Atom: [0], Metadata: [1, lib.getCodec(MetadataProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Infinitely`
 * - `Once`
 * - `Not`
 * 
 * TODO how to construct, how to use
 */
export type Mintable = lib.VariantUnit<'Infinitely'> | lib.VariantUnit<'Once'> | lib.VariantUnit<'Not'>
/**
 * Codec and constructors for enumeration {@link Mintable}.
 */
export const Mintable: lib.CodecContainer<Mintable> & { Infinitely: lib.VariantUnit<'Infinitely'>, Once: lib.VariantUnit<'Once'>, Not: lib.VariantUnit<'Not'> } = { ...{ Infinitely: Object.freeze({ kind: 'Infinitely' }), Once: Object.freeze({ kind: 'Once' }), Not: Object.freeze({ kind: 'Not' }) }, ...lib.defineCodec(lib.enumCodec<{ Infinitely: [], Once: [], Not: [] }>({ Infinitely: [0], Once: [1], Not: [2] }).discriminated()) }

export type IpfsPath = lib.String
export const IpfsPath = lib.String

/**
 * Structure with named fields.
 */
export interface AssetDefinition { id: lib.AssetDefinitionId, spec: NumericSpec, mintable: Mintable, logo: lib.Option<IpfsPath>, metadata: Metadata, ownedBy: lib.AccountId, totalQuantity: Numeric }
/**
 * Codec of the structure.
 */
export const AssetDefinition: lib.CodecContainer<AssetDefinition> = lib.defineCodec(lib.structCodec<AssetDefinition>(['id', 'spec', 'mintable', 'logo', 'metadata', 'ownedBy', 'totalQuantity'], {id: lib.getCodec(lib.AssetDefinitionId), spec: lib.getCodec(NumericSpec), mintable: lib.getCodec(Mintable), logo: lib.Option.with(lib.getCodec(IpfsPath)), metadata: lib.getCodec(Metadata), ownedBy: lib.getCodec(lib.AccountId), totalQuantity: lib.getCodec(Numeric)}))

/**
 * Structure with named fields.
 */
export interface AssetDefinitionTotalQuantityChanged { assetDefinition: lib.AssetDefinitionId, totalAmount: Numeric }
/**
 * Codec of the structure.
 */
export const AssetDefinitionTotalQuantityChanged: lib.CodecContainer<AssetDefinitionTotalQuantityChanged> = lib.defineCodec(lib.structCodec<AssetDefinitionTotalQuantityChanged>(['assetDefinition', 'totalAmount'], {assetDefinition: lib.getCodec(lib.AssetDefinitionId), totalAmount: lib.getCodec(Numeric)}))

/**
 * Structure with named fields.
 */
export interface AssetDefinitionOwnerChanged { assetDefinition: lib.AssetDefinitionId, newOwner: lib.AccountId }
/**
 * Codec of the structure.
 */
export const AssetDefinitionOwnerChanged: lib.CodecContainer<AssetDefinitionOwnerChanged> = lib.defineCodec(lib.structCodec<AssetDefinitionOwnerChanged>(['assetDefinition', 'newOwner'], {assetDefinition: lib.getCodec(lib.AssetDefinitionId), newOwner: lib.getCodec(lib.AccountId)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `MetadataInserted`
 * - `MetadataRemoved`
 * - `MintabilityChanged`
 * - `TotalQuantityChanged`
 * - `OwnerChanged`
 * 
 * TODO how to construct, how to use
 */
export type AssetDefinitionEvent = lib.Variant<'Created', AssetDefinition> | lib.Variant<'Deleted', lib.AssetDefinitionId> | lib.Variant<'MetadataInserted', MetadataChanged<lib.AssetDefinitionId>> | lib.Variant<'MetadataRemoved', MetadataChanged<lib.AssetDefinitionId>> | lib.Variant<'MintabilityChanged', lib.AssetDefinitionId> | lib.Variant<'TotalQuantityChanged', AssetDefinitionTotalQuantityChanged> | lib.Variant<'OwnerChanged', AssetDefinitionOwnerChanged>
/**
 * Codec and constructors for enumeration {@link AssetDefinitionEvent}.
 */
export const AssetDefinitionEvent: lib.CodecContainer<AssetDefinitionEvent> & { Created: <const T extends AssetDefinition>(value: T) => lib.Variant<'Created', T>, Deleted: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Deleted', T>, MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'MetadataInserted', T>, MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'MetadataRemoved', T>, MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'MintabilityChanged', T>, TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T) => lib.Variant<'TotalQuantityChanged', T>, OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T) => lib.Variant<'OwnerChanged', T> } = { ...{ Created: <const T extends AssetDefinition>(value: T): lib.Variant<'Created', T> => ({ kind: 'Created', value }), Deleted: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Deleted', T> => ({ kind: 'Deleted', value }), MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T): lib.Variant<'MetadataInserted', T> => ({ kind: 'MetadataInserted', value }), MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T): lib.Variant<'MetadataRemoved', T> => ({ kind: 'MetadataRemoved', value }), MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'MintabilityChanged', T> => ({ kind: 'MintabilityChanged', value }), TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T): lib.Variant<'TotalQuantityChanged', T> => ({ kind: 'TotalQuantityChanged', value }), OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T): lib.Variant<'OwnerChanged', T> => ({ kind: 'OwnerChanged', value }) }, ...lib.defineCodec(lib.enumCodec<{ Created: [AssetDefinition], Deleted: [lib.AssetDefinitionId], MetadataInserted: [MetadataChanged<lib.AssetDefinitionId>], MetadataRemoved: [MetadataChanged<lib.AssetDefinitionId>], MintabilityChanged: [lib.AssetDefinitionId], TotalQuantityChanged: [AssetDefinitionTotalQuantityChanged], OwnerChanged: [AssetDefinitionOwnerChanged] }>({ Created: [0, lib.getCodec(AssetDefinition)], Deleted: [1, lib.getCodec(lib.AssetDefinitionId)], MetadataInserted: [2, MetadataChanged.with(lib.getCodec(lib.AssetDefinitionId))], MetadataRemoved: [3, MetadataChanged.with(lib.getCodec(lib.AssetDefinitionId))], MintabilityChanged: [4, lib.getCodec(lib.AssetDefinitionId)], TotalQuantityChanged: [5, lib.getCodec(AssetDefinitionTotalQuantityChanged)], OwnerChanged: [6, lib.getCodec(AssetDefinitionOwnerChanged)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type AssetDefinitionIdPredicateAtom = lib.Variant<'Equals', lib.AssetDefinitionId>
/**
 * Codec and constructors for enumeration {@link AssetDefinitionIdPredicateAtom}.
 */
export const AssetDefinitionIdPredicateAtom: lib.CodecContainer<AssetDefinitionIdPredicateAtom> & { Equals: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [lib.AssetDefinitionId] }>({ Equals: [0, lib.getCodec(lib.AssetDefinitionId)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */
export type AssetDefinitionIdProjectionPredicate = lib.Variant<'Atom', AssetDefinitionIdPredicateAtom> | lib.Variant<'Domain', DomainIdProjectionPredicate> | lib.Variant<'Name', NameProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link AssetDefinitionIdProjectionPredicate}.
 */
export const AssetDefinitionIdProjectionPredicate: lib.CodecContainer<AssetDefinitionIdProjectionPredicate> & { Atom: { Equals: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>> } } } = { ...{ Atom: { Equals: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: AssetDefinitionIdPredicateAtom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.EndsWith(value) }) } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.EndsWith(value) }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [AssetDefinitionIdPredicateAtom], Domain: [DomainIdProjectionPredicate], Name: [NameProjectionPredicate] }>({ Atom: [0, lib.getCodec(AssetDefinitionIdPredicateAtom)], Domain: [1, lib.getCodec(DomainIdProjectionPredicate)], Name: [2, lib.getCodec(NameProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */
export type AssetDefinitionIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Domain', DomainIdProjectionSelector> | lib.Variant<'Name', NameProjectionSelector>
/**
 * Codec and constructors for enumeration {@link AssetDefinitionIdProjectionSelector}.
 */
export const AssetDefinitionIdProjectionSelector: lib.CodecContainer<AssetDefinitionIdProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Domain: { Atom: lib.Variant<'Domain', lib.VariantUnit<'Atom'>>, Name: { Atom: lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>> } }, Name: { Atom: lib.Variant<'Name', lib.VariantUnit<'Atom'>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Domain: { Atom: Object.freeze<lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>({ kind: 'Domain', value: DomainIdProjectionSelector.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>({ kind: 'Domain', value: DomainIdProjectionSelector.Name.Atom }) } }, Name: { Atom: Object.freeze<lib.Variant<'Name', lib.VariantUnit<'Atom'>>>({ kind: 'Name', value: NameProjectionSelector.Atom }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Domain: [DomainIdProjectionSelector], Name: [NameProjectionSelector] }>({ Atom: [0], Domain: [1, lib.getCodec(DomainIdProjectionSelector)], Name: [2, lib.getCodec(NameProjectionSelector)] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type AssetDefinitionPredicateAtom = never
/**
 * Codec for {@link AssetDefinitionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const AssetDefinitionPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */
export type AssetDefinitionProjectionPredicate = lib.Variant<'Atom', AssetDefinitionPredicateAtom> | lib.Variant<'Id', AssetDefinitionIdProjectionPredicate> | lib.Variant<'Metadata', MetadataProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link AssetDefinitionProjectionPredicate}.
 */
export const AssetDefinitionProjectionPredicate: lib.CodecContainer<AssetDefinitionProjectionPredicate> & { Id: { Atom: { Equals: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> } } }, Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>> } } = { ...{ Id: { Atom: { Equals: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Id', value: AssetDefinitionIdProjectionPredicate.Atom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: AssetDefinitionIdProjectionPredicate.Domain.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Id', value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>> => ({ kind: 'Id', value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>> => ({ kind: 'Id', value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> => ({ kind: 'Id', value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.EndsWith(value) }) } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: AssetDefinitionIdProjectionPredicate.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>> => ({ kind: 'Id', value: AssetDefinitionIdProjectionPredicate.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>> => ({ kind: 'Id', value: AssetDefinitionIdProjectionPredicate.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> => ({ kind: 'Id', value: AssetDefinitionIdProjectionPredicate.Name.Atom.EndsWith(value) }) } } }, Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T): lib.Variant<'Metadata', lib.Variant<'Key', T>> => ({ kind: 'Metadata', value: MetadataProjectionPredicate.Key(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [AssetDefinitionPredicateAtom], Id: [AssetDefinitionIdProjectionPredicate], Metadata: [MetadataProjectionPredicate] }>({ Atom: [0, lib.getCodec(AssetDefinitionPredicateAtom)], Id: [1, lib.getCodec(AssetDefinitionIdProjectionPredicate)], Metadata: [2, lib.getCodec(MetadataProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */
export type AssetDefinitionProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', AssetDefinitionIdProjectionSelector> | lib.Variant<'Metadata', MetadataProjectionSelector>
/**
 * Codec and constructors for enumeration {@link AssetDefinitionProjectionSelector}.
 */
export const AssetDefinitionProjectionSelector: lib.CodecContainer<AssetDefinitionProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Id: { Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>, Domain: { Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>, Name: { Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>> } }, Name: { Atom: lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>> } }, Metadata: { Atom: lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>, Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Id: { Atom: Object.freeze<lib.Variant<'Id', lib.VariantUnit<'Atom'>>>({ kind: 'Id', value: AssetDefinitionIdProjectionSelector.Atom }), Domain: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: AssetDefinitionIdProjectionSelector.Domain.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>({ kind: 'Id', value: AssetDefinitionIdProjectionSelector.Domain.Name.Atom }) } }, Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: AssetDefinitionIdProjectionSelector.Name.Atom }) } }, Metadata: { Atom: Object.freeze<lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>>({ kind: 'Metadata', value: MetadataProjectionSelector.Atom }), Key: <const T extends MetadataKeyProjectionSelector>(value: T): lib.Variant<'Metadata', lib.Variant<'Key', T>> => ({ kind: 'Metadata', value: MetadataProjectionSelector.Key(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Id: [AssetDefinitionIdProjectionSelector], Metadata: [MetadataProjectionSelector] }>({ Atom: [0], Id: [1, lib.getCodec(AssetDefinitionIdProjectionSelector)], Metadata: [2, lib.getCodec(MetadataProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type AssetIdPredicateAtom = lib.Variant<'Equals', lib.AssetId>
/**
 * Codec and constructors for enumeration {@link AssetIdPredicateAtom}.
 */
export const AssetIdPredicateAtom: lib.CodecContainer<AssetIdPredicateAtom> & { Equals: <const T extends lib.AssetId>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends lib.AssetId>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [lib.AssetId] }>({ Equals: [0, lib.getCodec(lib.AssetId)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Account`
 * - `Definition`
 * 
 * TODO how to construct, how to use
 */
export type AssetIdProjectionPredicate = lib.Variant<'Atom', AssetIdPredicateAtom> | lib.Variant<'Account', AccountIdProjectionPredicate> | lib.Variant<'Definition', AssetDefinitionIdProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link AssetIdProjectionPredicate}.
 */
export const AssetIdProjectionPredicate: lib.CodecContainer<AssetIdProjectionPredicate> & { Atom: { Equals: <const T extends lib.AssetId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> }, Account: { Atom: { Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Account', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Account', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> } } }, Definition: { Atom: { Equals: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Definition', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> } } } } = { ...{ Atom: { Equals: <const T extends lib.AssetId>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: AssetIdPredicateAtom.Equals(value) }) }, Account: { Atom: { Equals: <const T extends lib.AccountId>(value: T): lib.Variant<'Account', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Account', value: AccountIdProjectionPredicate.Atom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Account', value: AccountIdProjectionPredicate.Domain.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Account', value: AccountIdProjectionPredicate.Domain.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>> => ({ kind: 'Account', value: AccountIdProjectionPredicate.Domain.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>> => ({ kind: 'Account', value: AccountIdProjectionPredicate.Domain.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> => ({ kind: 'Account', value: AccountIdProjectionPredicate.Domain.Name.Atom.EndsWith(value) }) } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T): lib.Variant<'Account', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Account', value: AccountIdProjectionPredicate.Signatory.Atom.Equals(value) }) } } }, Definition: { Atom: { Equals: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Definition', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Definition', value: AssetDefinitionIdProjectionPredicate.Atom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Definition', value: AssetDefinitionIdProjectionPredicate.Domain.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Definition', value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>> => ({ kind: 'Definition', value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>> => ({ kind: 'Definition', value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> => ({ kind: 'Definition', value: AssetDefinitionIdProjectionPredicate.Domain.Name.Atom.EndsWith(value) }) } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Definition', value: AssetDefinitionIdProjectionPredicate.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>> => ({ kind: 'Definition', value: AssetDefinitionIdProjectionPredicate.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>> => ({ kind: 'Definition', value: AssetDefinitionIdProjectionPredicate.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> => ({ kind: 'Definition', value: AssetDefinitionIdProjectionPredicate.Name.Atom.EndsWith(value) }) } } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [AssetIdPredicateAtom], Account: [AccountIdProjectionPredicate], Definition: [AssetDefinitionIdProjectionPredicate] }>({ Atom: [0, lib.getCodec(AssetIdPredicateAtom)], Account: [1, lib.getCodec(AccountIdProjectionPredicate)], Definition: [2, lib.getCodec(AssetDefinitionIdProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Account`
 * - `Definition`
 * 
 * TODO how to construct, how to use
 */
export type AssetIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Account', AccountIdProjectionSelector> | lib.Variant<'Definition', AssetDefinitionIdProjectionSelector>
/**
 * Codec and constructors for enumeration {@link AssetIdProjectionSelector}.
 */
export const AssetIdProjectionSelector: lib.CodecContainer<AssetIdProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Account: { Atom: lib.Variant<'Account', lib.VariantUnit<'Atom'>>, Domain: { Atom: lib.Variant<'Account', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>, Name: { Atom: lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>> } }, Signatory: { Atom: lib.Variant<'Account', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>> } }, Definition: { Atom: lib.Variant<'Definition', lib.VariantUnit<'Atom'>>, Domain: { Atom: lib.Variant<'Definition', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>, Name: { Atom: lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>> } }, Name: { Atom: lib.Variant<'Definition', lib.Variant<'Name', lib.VariantUnit<'Atom'>>> } } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Account: { Atom: Object.freeze<lib.Variant<'Account', lib.VariantUnit<'Atom'>>>({ kind: 'Account', value: AccountIdProjectionSelector.Atom }), Domain: { Atom: Object.freeze<lib.Variant<'Account', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>({ kind: 'Account', value: AccountIdProjectionSelector.Domain.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>({ kind: 'Account', value: AccountIdProjectionSelector.Domain.Name.Atom }) } }, Signatory: { Atom: Object.freeze<lib.Variant<'Account', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>>({ kind: 'Account', value: AccountIdProjectionSelector.Signatory.Atom }) } }, Definition: { Atom: Object.freeze<lib.Variant<'Definition', lib.VariantUnit<'Atom'>>>({ kind: 'Definition', value: AssetDefinitionIdProjectionSelector.Atom }), Domain: { Atom: Object.freeze<lib.Variant<'Definition', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>({ kind: 'Definition', value: AssetDefinitionIdProjectionSelector.Domain.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>({ kind: 'Definition', value: AssetDefinitionIdProjectionSelector.Domain.Name.Atom }) } }, Name: { Atom: Object.freeze<lib.Variant<'Definition', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>({ kind: 'Definition', value: AssetDefinitionIdProjectionSelector.Name.Atom }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Account: [AccountIdProjectionSelector], Definition: [AssetDefinitionIdProjectionSelector] }>({ Atom: [0], Account: [1, lib.getCodec(AccountIdProjectionSelector)], Definition: [2, lib.getCodec(AssetDefinitionIdProjectionSelector)] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type AssetPredicateAtom = never
/**
 * Codec for {@link AssetPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const AssetPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type NumericProjectionPredicate = never
/**
 * Codec for {@link NumericProjectionPredicate}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const NumericProjectionPredicate: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Value`
 * 
 * TODO how to construct, how to use
 */
export type AssetProjectionPredicate = lib.Variant<'Atom', AssetPredicateAtom> | lib.Variant<'Id', AssetIdProjectionPredicate> | lib.Variant<'Value', NumericProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link AssetProjectionPredicate}.
 */
export const AssetProjectionPredicate: lib.CodecContainer<AssetProjectionPredicate> & { Id: { Atom: { Equals: <const T extends lib.AssetId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Account: { Atom: { Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>> } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> } } }, Definition: { Atom: { Equals: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>> } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> } } } } } = { ...{ Id: { Atom: { Equals: <const T extends lib.AssetId>(value: T): lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Atom.Equals(value) }) }, Account: { Atom: { Equals: <const T extends lib.AccountId>(value: T): lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Account.Atom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Account.Domain.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Account.Domain.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Account.Domain.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Account.Domain.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Account.Domain.Name.Atom.EndsWith(value) }) } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T): lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Account.Signatory.Atom.Equals(value) }) } } }, Definition: { Atom: { Equals: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Definition.Atom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Definition.Domain.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Definition.Domain.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Definition.Domain.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Definition.Domain.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Definition.Domain.Name.Atom.EndsWith(value) }) } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Definition.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Definition.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Definition.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> => ({ kind: 'Id', value: AssetIdProjectionPredicate.Definition.Name.Atom.EndsWith(value) }) } } } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [AssetPredicateAtom], Id: [AssetIdProjectionPredicate], Value: [NumericProjectionPredicate] }>({ Atom: [0, lib.getCodec(AssetPredicateAtom)], Id: [1, lib.getCodec(AssetIdProjectionPredicate)], Value: [2, lib.getCodec(NumericProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type NumericProjectionSelector = lib.VariantUnit<'Atom'>
/**
 * Codec and constructors for enumeration {@link NumericProjectionSelector}.
 */
export const NumericProjectionSelector: lib.CodecContainer<NumericProjectionSelector> & { Atom: lib.VariantUnit<'Atom'> } = { ...{ Atom: Object.freeze({ kind: 'Atom' }) }, ...lib.defineCodec(lib.enumCodec<{ Atom: [] }>({ Atom: [0] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Value`
 * 
 * TODO how to construct, how to use
 */
export type AssetProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', AssetIdProjectionSelector> | lib.Variant<'Value', NumericProjectionSelector>
/**
 * Codec and constructors for enumeration {@link AssetProjectionSelector}.
 */
export const AssetProjectionSelector: lib.CodecContainer<AssetProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Id: { Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>, Account: { Atom: lib.Variant<'Id', lib.Variant<'Account', lib.VariantUnit<'Atom'>>>, Domain: { Atom: lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>, Name: { Atom: lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>> } }, Signatory: { Atom: lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>> } }, Definition: { Atom: lib.Variant<'Id', lib.Variant<'Definition', lib.VariantUnit<'Atom'>>>, Domain: { Atom: lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>, Name: { Atom: lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>> } }, Name: { Atom: lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>> } } }, Value: { Atom: lib.Variant<'Value', lib.VariantUnit<'Atom'>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Id: { Atom: Object.freeze<lib.Variant<'Id', lib.VariantUnit<'Atom'>>>({ kind: 'Id', value: AssetIdProjectionSelector.Atom }), Account: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Account', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: AssetIdProjectionSelector.Account.Atom }), Domain: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>>({ kind: 'Id', value: AssetIdProjectionSelector.Account.Domain.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>>({ kind: 'Id', value: AssetIdProjectionSelector.Account.Domain.Name.Atom }) } }, Signatory: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Account', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>>>({ kind: 'Id', value: AssetIdProjectionSelector.Account.Signatory.Atom }) } }, Definition: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Definition', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: AssetIdProjectionSelector.Definition.Atom }), Domain: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>>({ kind: 'Id', value: AssetIdProjectionSelector.Definition.Domain.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>>({ kind: 'Id', value: AssetIdProjectionSelector.Definition.Domain.Name.Atom }) } }, Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Definition', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>({ kind: 'Id', value: AssetIdProjectionSelector.Definition.Name.Atom }) } } }, Value: { Atom: Object.freeze<lib.Variant<'Value', lib.VariantUnit<'Atom'>>>({ kind: 'Value', value: NumericProjectionSelector.Atom }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Id: [AssetIdProjectionSelector], Value: [NumericProjectionSelector] }>({ Atom: [0], Id: [1, lib.getCodec(AssetIdProjectionSelector)], Value: [2, lib.getCodec(NumericProjectionSelector)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface BlockHeader { height: lib.NonZero<lib.U64>, prevBlockHash: lib.Option<lib.Hash>, transactionsHash: lib.Option<lib.Hash>, creationTime: lib.Timestamp, viewChangeIndex: lib.U32 }
/**
 * Codec of the structure.
 */
export const BlockHeader: lib.CodecContainer<BlockHeader> = lib.defineCodec(lib.structCodec<BlockHeader>(['height', 'prevBlockHash', 'transactionsHash', 'creationTime', 'viewChangeIndex'], {height: lib.NonZero.with(lib.getCodec(lib.U64)), prevBlockHash: lib.Option.with(lib.getCodec(lib.Hash)), transactionsHash: lib.Option.with(lib.getCodec(lib.Hash)), creationTime: lib.getCodec(lib.Timestamp), viewChangeIndex: lib.getCodec(lib.U32)}))

/**
 * Structure with named fields.
 */
export interface BlockEvent { header: BlockHeader, status: BlockStatus }
/**
 * Codec of the structure.
 */
export const BlockEvent: lib.CodecContainer<BlockEvent> = lib.defineCodec(lib.structCodec<BlockEvent>(['header', 'status'], {header: lib.getCodec(BlockHeader), status: lib.getCodec(BlockStatus)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type BlockHeaderHashPredicateAtom = lib.Variant<'Equals', lib.Hash>
/**
 * Codec and constructors for enumeration {@link BlockHeaderHashPredicateAtom}.
 */
export const BlockHeaderHashPredicateAtom: lib.CodecContainer<BlockHeaderHashPredicateAtom> & { Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends lib.Hash>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [lib.Hash] }>({ Equals: [0, lib.getCodec(lib.Hash)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type BlockHeaderHashProjectionPredicate = lib.Variant<'Atom', BlockHeaderHashPredicateAtom>
/**
 * Codec and constructors for enumeration {@link BlockHeaderHashProjectionPredicate}.
 */
export const BlockHeaderHashProjectionPredicate: lib.CodecContainer<BlockHeaderHashProjectionPredicate> & { Atom: { Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> } } = { ...{ Atom: { Equals: <const T extends lib.Hash>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: BlockHeaderHashPredicateAtom.Equals(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [BlockHeaderHashPredicateAtom] }>({ Atom: [0, lib.getCodec(BlockHeaderHashPredicateAtom)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type BlockHeaderHashProjectionSelector = lib.VariantUnit<'Atom'>
/**
 * Codec and constructors for enumeration {@link BlockHeaderHashProjectionSelector}.
 */
export const BlockHeaderHashProjectionSelector: lib.CodecContainer<BlockHeaderHashProjectionSelector> & { Atom: lib.VariantUnit<'Atom'> } = { ...{ Atom: Object.freeze({ kind: 'Atom' }) }, ...lib.defineCodec(lib.enumCodec<{ Atom: [] }>({ Atom: [0] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type BlockHeaderPredicateAtom = never
/**
 * Codec for {@link BlockHeaderPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const BlockHeaderPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Hash`
 * 
 * TODO how to construct, how to use
 */
export type BlockHeaderProjectionPredicate = lib.Variant<'Atom', BlockHeaderPredicateAtom> | lib.Variant<'Hash', BlockHeaderHashProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link BlockHeaderProjectionPredicate}.
 */
export const BlockHeaderProjectionPredicate: lib.CodecContainer<BlockHeaderProjectionPredicate> & { Hash: { Atom: { Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>> } } } = { ...{ Hash: { Atom: { Equals: <const T extends lib.Hash>(value: T): lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Hash', value: BlockHeaderHashProjectionPredicate.Atom.Equals(value) }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [BlockHeaderPredicateAtom], Hash: [BlockHeaderHashProjectionPredicate] }>({ Atom: [0, lib.getCodec(BlockHeaderPredicateAtom)], Hash: [1, lib.getCodec(BlockHeaderHashProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Hash`
 * 
 * TODO how to construct, how to use
 */
export type BlockHeaderProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Hash', BlockHeaderHashProjectionSelector>
/**
 * Codec and constructors for enumeration {@link BlockHeaderProjectionSelector}.
 */
export const BlockHeaderProjectionSelector: lib.CodecContainer<BlockHeaderProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Hash: { Atom: lib.Variant<'Hash', lib.VariantUnit<'Atom'>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Hash: { Atom: Object.freeze<lib.Variant<'Hash', lib.VariantUnit<'Atom'>>>({ kind: 'Hash', value: BlockHeaderHashProjectionSelector.Atom }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Hash: [BlockHeaderHashProjectionSelector] }>({ Atom: [0], Hash: [1, lib.getCodec(BlockHeaderHashProjectionSelector)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface BlockSignature { peerTopologyIndex: lib.U64, signature: lib.Signature }
/**
 * Codec of the structure.
 */
export const BlockSignature: lib.CodecContainer<BlockSignature> = lib.defineCodec(lib.structCodec<BlockSignature>(['peerTopologyIndex', 'signature'], {peerTopologyIndex: lib.getCodec(lib.U64), signature: lib.getCodec(lib.Signature)}))

export type ChainId = lib.String
export const ChainId = lib.String

/**
 * Structure with named fields.
 */
export interface TransactionPayload { chain: ChainId, authority: lib.AccountId, creationTime: lib.Timestamp, instructions: Executable, timeToLive: lib.Option<lib.NonZero<lib.Duration>>, nonce: lib.Option<lib.NonZero<lib.U32>>, metadata: Metadata }
/**
 * Codec of the structure.
 */
export const TransactionPayload: lib.CodecContainer<TransactionPayload> = lib.defineCodec(lib.structCodec<TransactionPayload>(['chain', 'authority', 'creationTime', 'instructions', 'timeToLive', 'nonce', 'metadata'], {chain: lib.getCodec(ChainId), authority: lib.getCodec(lib.AccountId), creationTime: lib.getCodec(lib.Timestamp), instructions: lib.getCodec(Executable), timeToLive: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.Duration))), nonce: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U32))), metadata: lib.getCodec(Metadata)}))

/**
 * Structure with named fields.
 */
export interface SignedTransactionV1 { signature: lib.Signature, payload: TransactionPayload }
/**
 * Codec of the structure.
 */
export const SignedTransactionV1: lib.CodecContainer<SignedTransactionV1> = lib.defineCodec(lib.structCodec<SignedTransactionV1>(['signature', 'payload'], {signature: lib.getCodec(lib.Signature), payload: lib.getCodec(TransactionPayload)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `V1`
 * 
 * TODO how to construct, how to use
 */
export type SignedTransaction = lib.Variant<'V1', SignedTransactionV1>
/**
 * Codec and constructors for enumeration {@link SignedTransaction}.
 */
export const SignedTransaction: lib.CodecContainer<SignedTransaction> & { V1: <const T extends SignedTransactionV1>(value: T) => lib.Variant<'V1', T> } = { ...{ V1: <const T extends SignedTransactionV1>(value: T): lib.Variant<'V1', T> => ({ kind: 'V1', value }) }, ...lib.defineCodec(lib.enumCodec<{ V1: [SignedTransactionV1] }>({ V1: [1, lib.getCodec(SignedTransactionV1)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface BlockPayload { header: BlockHeader, transactions: lib.Vec<SignedTransaction> }
/**
 * Codec of the structure.
 */
export const BlockPayload: lib.CodecContainer<BlockPayload> = lib.defineCodec(lib.structCodec<BlockPayload>(['header', 'transactions'], {header: lib.getCodec(BlockHeader), transactions: lib.Vec.with(lib.getCodec(SignedTransaction))}))

/**
 * Structure with named fields.
 */
export interface TransactionErrorWithIndex { index: lib.U64, error: TransactionRejectionReason }
/**
 * Codec of the structure.
 */
export const TransactionErrorWithIndex: lib.CodecContainer<TransactionErrorWithIndex> = lib.defineCodec(lib.structCodec<TransactionErrorWithIndex>(['index', 'error'], {index: lib.getCodec(lib.U64), error: lib.getCodec(TransactionRejectionReason)}))

export type TransactionErrors = lib.BTreeSet<TransactionErrorWithIndex>
export const TransactionErrors: lib.CodecContainer<TransactionErrors> = lib.defineCodec(lib.BTreeSet.withCmp(lib.getCodec(TransactionErrorWithIndex), (a, b) => lib.ordCompare(a.index, b.index)))

/**
 * Structure with named fields.
 */
export interface SignedBlockV1 { signatures: lib.Vec<BlockSignature>, payload: BlockPayload, errors: TransactionErrors }
/**
 * Codec of the structure.
 */
export const SignedBlockV1: lib.CodecContainer<SignedBlockV1> = lib.defineCodec(lib.structCodec<SignedBlockV1>(['signatures', 'payload', 'errors'], {signatures: lib.Vec.with(lib.getCodec(BlockSignature)), payload: lib.getCodec(BlockPayload), errors: lib.getCodec(TransactionErrors)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `V1`
 * 
 * TODO how to construct, how to use
 */
export type SignedBlock = lib.Variant<'V1', SignedBlockV1>
/**
 * Codec and constructors for enumeration {@link SignedBlock}.
 */
export const SignedBlock: lib.CodecContainer<SignedBlock> & { V1: <const T extends SignedBlockV1>(value: T) => lib.Variant<'V1', T> } = { ...{ V1: <const T extends SignedBlockV1>(value: T): lib.Variant<'V1', T> => ({ kind: 'V1', value }) }, ...lib.defineCodec(lib.enumCodec<{ V1: [SignedBlockV1] }>({ V1: [1, lib.getCodec(SignedBlockV1)] }).discriminated()) }

export type BlockMessage = SignedBlock
export const BlockMessage = SignedBlock

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `MaxTransactions`
 * 
 * TODO how to construct, how to use
 */
export type BlockParameter = lib.Variant<'MaxTransactions', lib.NonZero<lib.U64>>
/**
 * Codec and constructors for enumeration {@link BlockParameter}.
 */
export const BlockParameter: lib.CodecContainer<BlockParameter> & { MaxTransactions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'MaxTransactions', T> } = { ...{ MaxTransactions: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'MaxTransactions', T> => ({ kind: 'MaxTransactions', value }) }, ...lib.defineCodec(lib.enumCodec<{ MaxTransactions: [lib.NonZero<lib.U64>] }>({ MaxTransactions: [0, lib.NonZero.with(lib.getCodec(lib.U64))] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface BlockParameters { maxTransactions: lib.NonZero<lib.U64> }
/**
 * Codec of the structure.
 */
export const BlockParameters: lib.CodecContainer<BlockParameters> = lib.defineCodec(lib.structCodec<BlockParameters>(['maxTransactions'], {maxTransactions: lib.NonZero.with(lib.getCodec(lib.U64))}))

/**
 * Structure with named fields.
 */
export interface BlockSubscriptionRequest { fromBlockHeight: lib.NonZero<lib.U64> }
/**
 * Codec of the structure.
 */
export const BlockSubscriptionRequest: lib.CodecContainer<BlockSubscriptionRequest> = lib.defineCodec(lib.structCodec<BlockSubscriptionRequest>(['fromBlockHeight'], {fromBlockHeight: lib.NonZero.with(lib.getCodec(lib.U64))}))

/**
 * Structure with named fields and generic parameters.
 */
export interface Burn<T0, T1> { object: T0, destination: T1 }
/**
 * Codec constructor for the structure with generic parameters.
 */
export const Burn = { /**
 * Create a codec with the actual codecs for generic parameters.
 */
with: <T0, T1>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>): lib.GenCodec<Burn<T0, T1>> => lib.structCodec<Burn<T0, T1>>(['object', 'destination'], {object: t0, destination: t1}) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Asset`
 * - `TriggerRepetitions`
 * 
 * TODO how to construct, how to use
 */
export type BurnBox = lib.Variant<'Asset', Burn<Numeric, lib.AssetId>> | lib.Variant<'TriggerRepetitions', Burn<lib.U32, TriggerId>>
/**
 * Codec and constructors for enumeration {@link BurnBox}.
 */
export const BurnBox: lib.CodecContainer<BurnBox> & { Asset: <const T extends Burn<Numeric, lib.AssetId>>(value: T) => lib.Variant<'Asset', T>, TriggerRepetitions: <const T extends Burn<lib.U32, TriggerId>>(value: T) => lib.Variant<'TriggerRepetitions', T> } = { ...{ Asset: <const T extends Burn<Numeric, lib.AssetId>>(value: T): lib.Variant<'Asset', T> => ({ kind: 'Asset', value }), TriggerRepetitions: <const T extends Burn<lib.U32, TriggerId>>(value: T): lib.Variant<'TriggerRepetitions', T> => ({ kind: 'TriggerRepetitions', value }) }, ...lib.defineCodec(lib.enumCodec<{ Asset: [Burn<Numeric, lib.AssetId>], TriggerRepetitions: [Burn<lib.U32, TriggerId>] }>({ Asset: [0, Burn.with(lib.getCodec(Numeric), lib.getCodec(lib.AssetId))], TriggerRepetitions: [1, Burn.with(lib.getCodec(lib.U32), lib.getCodec(TriggerId))] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface CanBurnAsset { asset: lib.AssetId }
/**
 * Codec of the structure.
 */
export const CanBurnAsset: lib.CodecContainer<CanBurnAsset> = lib.defineCodec(lib.structCodec<CanBurnAsset>(['asset'], {asset: lib.getCodec(lib.AssetId)}))

/**
 * Structure with named fields.
 */
export interface CanBurnAssetWithDefinition { assetDefinition: lib.AssetDefinitionId }
/**
 * Codec of the structure.
 */
export const CanBurnAssetWithDefinition: lib.CodecContainer<CanBurnAssetWithDefinition> = lib.defineCodec(lib.structCodec<CanBurnAssetWithDefinition>(['assetDefinition'], {assetDefinition: lib.getCodec(lib.AssetDefinitionId)}))

/**
 * Structure with named fields.
 */
export interface CanExecuteTrigger { trigger: TriggerId }
/**
 * Codec of the structure.
 */
export const CanExecuteTrigger: lib.CodecContainer<CanExecuteTrigger> = lib.defineCodec(lib.structCodec<CanExecuteTrigger>(['trigger'], {trigger: lib.getCodec(TriggerId)}))

/**
 * Structure with named fields.
 */
export interface CanMintAsset { asset: lib.AssetId }
/**
 * Codec of the structure.
 */
export const CanMintAsset: lib.CodecContainer<CanMintAsset> = lib.defineCodec(lib.structCodec<CanMintAsset>(['asset'], {asset: lib.getCodec(lib.AssetId)}))

/**
 * Structure with named fields.
 */
export interface CanMintAssetWithDefinition { assetDefinition: lib.AssetDefinitionId }
/**
 * Codec of the structure.
 */
export const CanMintAssetWithDefinition: lib.CodecContainer<CanMintAssetWithDefinition> = lib.defineCodec(lib.structCodec<CanMintAssetWithDefinition>(['assetDefinition'], {assetDefinition: lib.getCodec(lib.AssetDefinitionId)}))

/**
 * Structure with named fields.
 */
export interface CanModifyAccountMetadata { account: lib.AccountId }
/**
 * Codec of the structure.
 */
export const CanModifyAccountMetadata: lib.CodecContainer<CanModifyAccountMetadata> = lib.defineCodec(lib.structCodec<CanModifyAccountMetadata>(['account'], {account: lib.getCodec(lib.AccountId)}))

/**
 * Structure with named fields.
 */
export interface CanModifyAssetDefinitionMetadata { assetDefinition: lib.AssetDefinitionId }
/**
 * Codec of the structure.
 */
export const CanModifyAssetDefinitionMetadata: lib.CodecContainer<CanModifyAssetDefinitionMetadata> = lib.defineCodec(lib.structCodec<CanModifyAssetDefinitionMetadata>(['assetDefinition'], {assetDefinition: lib.getCodec(lib.AssetDefinitionId)}))

/**
 * Structure with named fields.
 */
export interface CanModifyDomainMetadata { domain: lib.DomainId }
/**
 * Codec of the structure.
 */
export const CanModifyDomainMetadata: lib.CodecContainer<CanModifyDomainMetadata> = lib.defineCodec(lib.structCodec<CanModifyDomainMetadata>(['domain'], {domain: lib.getCodec(lib.DomainId)}))

/**
 * Structure with named fields.
 */
export interface CanModifyNftMetadata { nft: lib.NftId }
/**
 * Codec of the structure.
 */
export const CanModifyNftMetadata: lib.CodecContainer<CanModifyNftMetadata> = lib.defineCodec(lib.structCodec<CanModifyNftMetadata>(['nft'], {nft: lib.getCodec(lib.NftId)}))

/**
 * Structure with named fields.
 */
export interface CanModifyTrigger { trigger: TriggerId }
/**
 * Codec of the structure.
 */
export const CanModifyTrigger: lib.CodecContainer<CanModifyTrigger> = lib.defineCodec(lib.structCodec<CanModifyTrigger>(['trigger'], {trigger: lib.getCodec(TriggerId)}))

/**
 * Structure with named fields.
 */
export interface CanModifyTriggerMetadata { trigger: TriggerId }
/**
 * Codec of the structure.
 */
export const CanModifyTriggerMetadata: lib.CodecContainer<CanModifyTriggerMetadata> = lib.defineCodec(lib.structCodec<CanModifyTriggerMetadata>(['trigger'], {trigger: lib.getCodec(TriggerId)}))

/**
 * Structure with named fields.
 */
export interface CanRegisterAccount { domain: lib.DomainId }
/**
 * Codec of the structure.
 */
export const CanRegisterAccount: lib.CodecContainer<CanRegisterAccount> = lib.defineCodec(lib.structCodec<CanRegisterAccount>(['domain'], {domain: lib.getCodec(lib.DomainId)}))

/**
 * Structure with named fields.
 */
export interface CanRegisterAssetDefinition { domain: lib.DomainId }
/**
 * Codec of the structure.
 */
export const CanRegisterAssetDefinition: lib.CodecContainer<CanRegisterAssetDefinition> = lib.defineCodec(lib.structCodec<CanRegisterAssetDefinition>(['domain'], {domain: lib.getCodec(lib.DomainId)}))

/**
 * Structure with named fields.
 */
export interface CanRegisterNft { domain: lib.DomainId }
/**
 * Codec of the structure.
 */
export const CanRegisterNft: lib.CodecContainer<CanRegisterNft> = lib.defineCodec(lib.structCodec<CanRegisterNft>(['domain'], {domain: lib.getCodec(lib.DomainId)}))

/**
 * Structure with named fields.
 */
export interface CanRegisterTrigger { authority: lib.AccountId }
/**
 * Codec of the structure.
 */
export const CanRegisterTrigger: lib.CodecContainer<CanRegisterTrigger> = lib.defineCodec(lib.structCodec<CanRegisterTrigger>(['authority'], {authority: lib.getCodec(lib.AccountId)}))

/**
 * Structure with named fields.
 */
export interface CanTransferAsset { asset: lib.AssetId }
/**
 * Codec of the structure.
 */
export const CanTransferAsset: lib.CodecContainer<CanTransferAsset> = lib.defineCodec(lib.structCodec<CanTransferAsset>(['asset'], {asset: lib.getCodec(lib.AssetId)}))

/**
 * Structure with named fields.
 */
export interface CanTransferAssetWithDefinition { assetDefinition: lib.AssetDefinitionId }
/**
 * Codec of the structure.
 */
export const CanTransferAssetWithDefinition: lib.CodecContainer<CanTransferAssetWithDefinition> = lib.defineCodec(lib.structCodec<CanTransferAssetWithDefinition>(['assetDefinition'], {assetDefinition: lib.getCodec(lib.AssetDefinitionId)}))

/**
 * Structure with named fields.
 */
export interface CanTransferNft { nft: lib.NftId }
/**
 * Codec of the structure.
 */
export const CanTransferNft: lib.CodecContainer<CanTransferNft> = lib.defineCodec(lib.structCodec<CanTransferNft>(['nft'], {nft: lib.getCodec(lib.NftId)}))

/**
 * Structure with named fields.
 */
export interface CanUnregisterAccount { account: lib.AccountId }
/**
 * Codec of the structure.
 */
export const CanUnregisterAccount: lib.CodecContainer<CanUnregisterAccount> = lib.defineCodec(lib.structCodec<CanUnregisterAccount>(['account'], {account: lib.getCodec(lib.AccountId)}))

/**
 * Structure with named fields.
 */
export interface CanUnregisterAssetDefinition { assetDefinition: lib.AssetDefinitionId }
/**
 * Codec of the structure.
 */
export const CanUnregisterAssetDefinition: lib.CodecContainer<CanUnregisterAssetDefinition> = lib.defineCodec(lib.structCodec<CanUnregisterAssetDefinition>(['assetDefinition'], {assetDefinition: lib.getCodec(lib.AssetDefinitionId)}))

/**
 * Structure with named fields.
 */
export interface CanUnregisterDomain { domain: lib.DomainId }
/**
 * Codec of the structure.
 */
export const CanUnregisterDomain: lib.CodecContainer<CanUnregisterDomain> = lib.defineCodec(lib.structCodec<CanUnregisterDomain>(['domain'], {domain: lib.getCodec(lib.DomainId)}))

/**
 * Structure with named fields.
 */
export interface CanUnregisterNft { nft: lib.NftId }
/**
 * Codec of the structure.
 */
export const CanUnregisterNft: lib.CodecContainer<CanUnregisterNft> = lib.defineCodec(lib.structCodec<CanUnregisterNft>(['nft'], {nft: lib.getCodec(lib.NftId)}))

/**
 * Structure with named fields.
 */
export interface CanUnregisterTrigger { trigger: TriggerId }
/**
 * Codec of the structure.
 */
export const CanUnregisterTrigger: lib.CodecContainer<CanUnregisterTrigger> = lib.defineCodec(lib.structCodec<CanUnregisterTrigger>(['trigger'], {trigger: lib.getCodec(TriggerId)}))

/**
 * Structure with named fields.
 */
export interface CommittedTransaction { blockHash: lib.Hash, value: SignedTransaction, error: lib.Option<TransactionRejectionReason> }
/**
 * Codec of the structure.
 */
export const CommittedTransaction: lib.CodecContainer<CommittedTransaction> = lib.defineCodec(lib.structCodec<CommittedTransaction>(['blockHash', 'value', 'error'], {blockHash: lib.getCodec(lib.Hash), value: lib.getCodec(SignedTransaction), error: lib.Option.with(lib.getCodec(TransactionRejectionReason))}))

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type CommittedTransactionPredicateAtom = never
/**
 * Codec for {@link CommittedTransactionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const CommittedTransactionPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type SignedTransactionPredicateAtom = never
/**
 * Codec for {@link SignedTransactionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const SignedTransactionPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type TransactionHashPredicateAtom = lib.Variant<'Equals', lib.Hash>
/**
 * Codec and constructors for enumeration {@link TransactionHashPredicateAtom}.
 */
export const TransactionHashPredicateAtom: lib.CodecContainer<TransactionHashPredicateAtom> & { Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends lib.Hash>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [lib.Hash] }>({ Equals: [0, lib.getCodec(lib.Hash)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type TransactionHashProjectionPredicate = lib.Variant<'Atom', TransactionHashPredicateAtom>
/**
 * Codec and constructors for enumeration {@link TransactionHashProjectionPredicate}.
 */
export const TransactionHashProjectionPredicate: lib.CodecContainer<TransactionHashProjectionPredicate> & { Atom: { Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> } } = { ...{ Atom: { Equals: <const T extends lib.Hash>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: TransactionHashPredicateAtom.Equals(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [TransactionHashPredicateAtom] }>({ Atom: [0, lib.getCodec(TransactionHashPredicateAtom)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Hash`
 * - `Authority`
 * 
 * TODO how to construct, how to use
 */
export type SignedTransactionProjectionPredicate = lib.Variant<'Atom', SignedTransactionPredicateAtom> | lib.Variant<'Hash', TransactionHashProjectionPredicate> | lib.Variant<'Authority', AccountIdProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link SignedTransactionProjectionPredicate}.
 */
export const SignedTransactionProjectionPredicate: lib.CodecContainer<SignedTransactionProjectionPredicate> & { Hash: { Atom: { Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>> } }, Authority: { Atom: { Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Authority', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Authority', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> } } } } = { ...{ Hash: { Atom: { Equals: <const T extends lib.Hash>(value: T): lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Hash', value: TransactionHashProjectionPredicate.Atom.Equals(value) }) } }, Authority: { Atom: { Equals: <const T extends lib.AccountId>(value: T): lib.Variant<'Authority', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Authority', value: AccountIdProjectionPredicate.Atom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Authority', value: AccountIdProjectionPredicate.Domain.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Authority', value: AccountIdProjectionPredicate.Domain.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>> => ({ kind: 'Authority', value: AccountIdProjectionPredicate.Domain.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>> => ({ kind: 'Authority', value: AccountIdProjectionPredicate.Domain.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> => ({ kind: 'Authority', value: AccountIdProjectionPredicate.Domain.Name.Atom.EndsWith(value) }) } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T): lib.Variant<'Authority', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Authority', value: AccountIdProjectionPredicate.Signatory.Atom.Equals(value) }) } } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [SignedTransactionPredicateAtom], Hash: [TransactionHashProjectionPredicate], Authority: [AccountIdProjectionPredicate] }>({ Atom: [0, lib.getCodec(SignedTransactionPredicateAtom)], Hash: [1, lib.getCodec(TransactionHashProjectionPredicate)], Authority: [2, lib.getCodec(AccountIdProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `IsSome`
 * 
 * TODO how to construct, how to use
 */
export type TransactionErrorPredicateAtom = lib.VariantUnit<'IsSome'>
/**
 * Codec and constructors for enumeration {@link TransactionErrorPredicateAtom}.
 */
export const TransactionErrorPredicateAtom: lib.CodecContainer<TransactionErrorPredicateAtom> & { IsSome: lib.VariantUnit<'IsSome'> } = { ...{ IsSome: Object.freeze({ kind: 'IsSome' }) }, ...lib.defineCodec(lib.enumCodec<{ IsSome: [] }>({ IsSome: [0] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type TransactionErrorProjectionPredicate = lib.Variant<'Atom', TransactionErrorPredicateAtom>
/**
 * Codec and constructors for enumeration {@link TransactionErrorProjectionPredicate}.
 */
export const TransactionErrorProjectionPredicate: lib.CodecContainer<TransactionErrorProjectionPredicate> & { Atom: { IsSome: lib.Variant<'Atom', lib.VariantUnit<'IsSome'>> } } = { ...{ Atom: { IsSome: Object.freeze<lib.Variant<'Atom', lib.VariantUnit<'IsSome'>>>({ kind: 'Atom', value: TransactionErrorPredicateAtom.IsSome }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [TransactionErrorPredicateAtom] }>({ Atom: [0, lib.getCodec(TransactionErrorPredicateAtom)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `BlockHash`
 * - `Value`
 * - `Error`
 * 
 * TODO how to construct, how to use
 */
export type CommittedTransactionProjectionPredicate = lib.Variant<'Atom', CommittedTransactionPredicateAtom> | lib.Variant<'BlockHash', BlockHeaderHashProjectionPredicate> | lib.Variant<'Value', SignedTransactionProjectionPredicate> | lib.Variant<'Error', TransactionErrorProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link CommittedTransactionProjectionPredicate}.
 */
export const CommittedTransactionProjectionPredicate: lib.CodecContainer<CommittedTransactionProjectionPredicate> & { BlockHash: { Atom: { Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'BlockHash', lib.Variant<'Atom', lib.Variant<'Equals', T>>> } }, Value: { Hash: { Atom: { Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Value', lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> } }, Authority: { Atom: { Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>> } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> } } } }, Error: { Atom: { IsSome: lib.Variant<'Error', lib.Variant<'Atom', lib.VariantUnit<'IsSome'>>> } } } = { ...{ BlockHash: { Atom: { Equals: <const T extends lib.Hash>(value: T): lib.Variant<'BlockHash', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'BlockHash', value: BlockHeaderHashProjectionPredicate.Atom.Equals(value) }) } }, Value: { Hash: { Atom: { Equals: <const T extends lib.Hash>(value: T): lib.Variant<'Value', lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Value', value: SignedTransactionProjectionPredicate.Hash.Atom.Equals(value) }) } }, Authority: { Atom: { Equals: <const T extends lib.AccountId>(value: T): lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Value', value: SignedTransactionProjectionPredicate.Authority.Atom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Value', value: SignedTransactionProjectionPredicate.Authority.Domain.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>> => ({ kind: 'Value', value: SignedTransactionProjectionPredicate.Authority.Domain.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>> => ({ kind: 'Value', value: SignedTransactionProjectionPredicate.Authority.Domain.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>> => ({ kind: 'Value', value: SignedTransactionProjectionPredicate.Authority.Domain.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>>> => ({ kind: 'Value', value: SignedTransactionProjectionPredicate.Authority.Domain.Name.Atom.EndsWith(value) }) } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T): lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Value', value: SignedTransactionProjectionPredicate.Authority.Signatory.Atom.Equals(value) }) } } } }, Error: { Atom: { IsSome: Object.freeze<lib.Variant<'Error', lib.Variant<'Atom', lib.VariantUnit<'IsSome'>>>>({ kind: 'Error', value: TransactionErrorProjectionPredicate.Atom.IsSome }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [CommittedTransactionPredicateAtom], BlockHash: [BlockHeaderHashProjectionPredicate], Value: [SignedTransactionProjectionPredicate], Error: [TransactionErrorProjectionPredicate] }>({ Atom: [0, lib.getCodec(CommittedTransactionPredicateAtom)], BlockHash: [1, lib.getCodec(BlockHeaderHashProjectionPredicate)], Value: [2, lib.getCodec(SignedTransactionProjectionPredicate)], Error: [3, lib.getCodec(TransactionErrorProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type TransactionHashProjectionSelector = lib.VariantUnit<'Atom'>
/**
 * Codec and constructors for enumeration {@link TransactionHashProjectionSelector}.
 */
export const TransactionHashProjectionSelector: lib.CodecContainer<TransactionHashProjectionSelector> & { Atom: lib.VariantUnit<'Atom'> } = { ...{ Atom: Object.freeze({ kind: 'Atom' }) }, ...lib.defineCodec(lib.enumCodec<{ Atom: [] }>({ Atom: [0] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Hash`
 * - `Authority`
 * 
 * TODO how to construct, how to use
 */
export type SignedTransactionProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Hash', TransactionHashProjectionSelector> | lib.Variant<'Authority', AccountIdProjectionSelector>
/**
 * Codec and constructors for enumeration {@link SignedTransactionProjectionSelector}.
 */
export const SignedTransactionProjectionSelector: lib.CodecContainer<SignedTransactionProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Hash: { Atom: lib.Variant<'Hash', lib.VariantUnit<'Atom'>> }, Authority: { Atom: lib.Variant<'Authority', lib.VariantUnit<'Atom'>>, Domain: { Atom: lib.Variant<'Authority', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>, Name: { Atom: lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>> } }, Signatory: { Atom: lib.Variant<'Authority', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>> } } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Hash: { Atom: Object.freeze<lib.Variant<'Hash', lib.VariantUnit<'Atom'>>>({ kind: 'Hash', value: TransactionHashProjectionSelector.Atom }) }, Authority: { Atom: Object.freeze<lib.Variant<'Authority', lib.VariantUnit<'Atom'>>>({ kind: 'Authority', value: AccountIdProjectionSelector.Atom }), Domain: { Atom: Object.freeze<lib.Variant<'Authority', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>({ kind: 'Authority', value: AccountIdProjectionSelector.Domain.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>({ kind: 'Authority', value: AccountIdProjectionSelector.Domain.Name.Atom }) } }, Signatory: { Atom: Object.freeze<lib.Variant<'Authority', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>>({ kind: 'Authority', value: AccountIdProjectionSelector.Signatory.Atom }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Hash: [TransactionHashProjectionSelector], Authority: [AccountIdProjectionSelector] }>({ Atom: [0], Hash: [1, lib.getCodec(TransactionHashProjectionSelector)], Authority: [2, lib.getCodec(AccountIdProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type TransactionErrorProjectionSelector = lib.VariantUnit<'Atom'>
/**
 * Codec and constructors for enumeration {@link TransactionErrorProjectionSelector}.
 */
export const TransactionErrorProjectionSelector: lib.CodecContainer<TransactionErrorProjectionSelector> & { Atom: lib.VariantUnit<'Atom'> } = { ...{ Atom: Object.freeze({ kind: 'Atom' }) }, ...lib.defineCodec(lib.enumCodec<{ Atom: [] }>({ Atom: [0] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `BlockHash`
 * - `Value`
 * - `Error`
 * 
 * TODO how to construct, how to use
 */
export type CommittedTransactionProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'BlockHash', BlockHeaderHashProjectionSelector> | lib.Variant<'Value', SignedTransactionProjectionSelector> | lib.Variant<'Error', TransactionErrorProjectionSelector>
/**
 * Codec and constructors for enumeration {@link CommittedTransactionProjectionSelector}.
 */
export const CommittedTransactionProjectionSelector: lib.CodecContainer<CommittedTransactionProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, BlockHash: { Atom: lib.Variant<'BlockHash', lib.VariantUnit<'Atom'>> }, Value: { Atom: lib.Variant<'Value', lib.VariantUnit<'Atom'>>, Hash: { Atom: lib.Variant<'Value', lib.Variant<'Hash', lib.VariantUnit<'Atom'>>> }, Authority: { Atom: lib.Variant<'Value', lib.Variant<'Authority', lib.VariantUnit<'Atom'>>>, Domain: { Atom: lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>, Name: { Atom: lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>> } }, Signatory: { Atom: lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>> } } }, Error: { Atom: lib.Variant<'Error', lib.VariantUnit<'Atom'>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), BlockHash: { Atom: Object.freeze<lib.Variant<'BlockHash', lib.VariantUnit<'Atom'>>>({ kind: 'BlockHash', value: BlockHeaderHashProjectionSelector.Atom }) }, Value: { Atom: Object.freeze<lib.Variant<'Value', lib.VariantUnit<'Atom'>>>({ kind: 'Value', value: SignedTransactionProjectionSelector.Atom }), Hash: { Atom: Object.freeze<lib.Variant<'Value', lib.Variant<'Hash', lib.VariantUnit<'Atom'>>>>({ kind: 'Value', value: SignedTransactionProjectionSelector.Hash.Atom }) }, Authority: { Atom: Object.freeze<lib.Variant<'Value', lib.Variant<'Authority', lib.VariantUnit<'Atom'>>>>({ kind: 'Value', value: SignedTransactionProjectionSelector.Authority.Atom }), Domain: { Atom: Object.freeze<lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>>({ kind: 'Value', value: SignedTransactionProjectionSelector.Authority.Domain.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>>({ kind: 'Value', value: SignedTransactionProjectionSelector.Authority.Domain.Name.Atom }) } }, Signatory: { Atom: Object.freeze<lib.Variant<'Value', lib.Variant<'Authority', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>>>({ kind: 'Value', value: SignedTransactionProjectionSelector.Authority.Signatory.Atom }) } } }, Error: { Atom: Object.freeze<lib.Variant<'Error', lib.VariantUnit<'Atom'>>>({ kind: 'Error', value: TransactionErrorProjectionSelector.Atom }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], BlockHash: [BlockHeaderHashProjectionSelector], Value: [SignedTransactionProjectionSelector], Error: [TransactionErrorProjectionSelector] }>({ Atom: [0], BlockHash: [1, lib.getCodec(BlockHeaderHashProjectionSelector)], Value: [2, lib.getCodec(SignedTransactionProjectionSelector)], Error: [3, lib.getCodec(TransactionErrorProjectionSelector)] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type DomainPredicateAtom = never
/**
 * Codec for {@link DomainPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const DomainPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */
export type DomainProjectionPredicate = lib.Variant<'Atom', DomainPredicateAtom> | lib.Variant<'Id', DomainIdProjectionPredicate> | lib.Variant<'Metadata', MetadataProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link DomainProjectionPredicate}.
 */
export const DomainProjectionPredicate: lib.CodecContainer<DomainProjectionPredicate> & { Id: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> } } }, Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>> } } = { ...{ Id: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Id', value: DomainIdProjectionPredicate.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: DomainIdProjectionPredicate.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>> => ({ kind: 'Id', value: DomainIdProjectionPredicate.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>> => ({ kind: 'Id', value: DomainIdProjectionPredicate.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> => ({ kind: 'Id', value: DomainIdProjectionPredicate.Name.Atom.EndsWith(value) }) } } }, Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T): lib.Variant<'Metadata', lib.Variant<'Key', T>> => ({ kind: 'Metadata', value: MetadataProjectionPredicate.Key(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [DomainPredicateAtom], Id: [DomainIdProjectionPredicate], Metadata: [MetadataProjectionPredicate] }>({ Atom: [0, lib.getCodec(DomainPredicateAtom)], Id: [1, lib.getCodec(DomainIdProjectionPredicate)], Metadata: [2, lib.getCodec(MetadataProjectionPredicate)] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type NftPredicateAtom = never
/**
 * Codec for {@link NftPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const NftPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type NftIdPredicateAtom = lib.Variant<'Equals', lib.NftId>
/**
 * Codec and constructors for enumeration {@link NftIdPredicateAtom}.
 */
export const NftIdPredicateAtom: lib.CodecContainer<NftIdPredicateAtom> & { Equals: <const T extends lib.NftId>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends lib.NftId>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [lib.NftId] }>({ Equals: [0, lib.getCodec(lib.NftId)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */
export type NftIdProjectionPredicate = lib.Variant<'Atom', NftIdPredicateAtom> | lib.Variant<'Domain', DomainIdProjectionPredicate> | lib.Variant<'Name', NameProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link NftIdProjectionPredicate}.
 */
export const NftIdProjectionPredicate: lib.CodecContainer<NftIdProjectionPredicate> & { Atom: { Equals: <const T extends lib.NftId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>> } } } = { ...{ Atom: { Equals: <const T extends lib.NftId>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: NftIdPredicateAtom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> => ({ kind: 'Domain', value: DomainIdProjectionPredicate.Name.Atom.EndsWith(value) }) } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.EndsWith(value) }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [NftIdPredicateAtom], Domain: [DomainIdProjectionPredicate], Name: [NameProjectionPredicate] }>({ Atom: [0, lib.getCodec(NftIdPredicateAtom)], Domain: [1, lib.getCodec(DomainIdProjectionPredicate)], Name: [2, lib.getCodec(NameProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * - `AccountId`
 * 
 * TODO how to construct, how to use
 */
export type NftProjectionPredicate = lib.Variant<'Atom', NftPredicateAtom> | lib.Variant<'Id', NftIdProjectionPredicate> | lib.Variant<'Metadata', MetadataProjectionPredicate> | lib.Variant<'AccountId', AccountIdProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link NftProjectionPredicate}.
 */
export const NftProjectionPredicate: lib.CodecContainer<NftProjectionPredicate> & { Id: { Atom: { Equals: <const T extends lib.NftId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> } } }, Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>> }, AccountId: { Atom: { Equals: <const T extends lib.AccountId>(value: T) => lib.Variant<'AccountId', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T) => lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'AccountId', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> } } } } = { ...{ Id: { Atom: { Equals: <const T extends lib.NftId>(value: T): lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Id', value: NftIdProjectionPredicate.Atom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: NftIdProjectionPredicate.Domain.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'Id', value: NftIdProjectionPredicate.Domain.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>> => ({ kind: 'Id', value: NftIdProjectionPredicate.Domain.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>> => ({ kind: 'Id', value: NftIdProjectionPredicate.Domain.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> => ({ kind: 'Id', value: NftIdProjectionPredicate.Domain.Name.Atom.EndsWith(value) }) } } }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: NftIdProjectionPredicate.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>> => ({ kind: 'Id', value: NftIdProjectionPredicate.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>> => ({ kind: 'Id', value: NftIdProjectionPredicate.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> => ({ kind: 'Id', value: NftIdProjectionPredicate.Name.Atom.EndsWith(value) }) } } }, Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T): lib.Variant<'Metadata', lib.Variant<'Key', T>> => ({ kind: 'Metadata', value: MetadataProjectionPredicate.Key(value) }) }, AccountId: { Atom: { Equals: <const T extends lib.AccountId>(value: T): lib.Variant<'AccountId', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'AccountId', value: AccountIdProjectionPredicate.Atom.Equals(value) }) }, Domain: { Atom: { Equals: <const T extends lib.DomainId>(value: T): lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'AccountId', value: AccountIdProjectionPredicate.Domain.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>> => ({ kind: 'AccountId', value: AccountIdProjectionPredicate.Domain.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>> => ({ kind: 'AccountId', value: AccountIdProjectionPredicate.Domain.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>> => ({ kind: 'AccountId', value: AccountIdProjectionPredicate.Domain.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>>> => ({ kind: 'AccountId', value: AccountIdProjectionPredicate.Domain.Name.Atom.EndsWith(value) }) } } }, Signatory: { Atom: { Equals: <const T extends lib.PublicKey>(value: T): lib.Variant<'AccountId', lib.Variant<'Signatory', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'AccountId', value: AccountIdProjectionPredicate.Signatory.Atom.Equals(value) }) } } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [NftPredicateAtom], Id: [NftIdProjectionPredicate], Metadata: [MetadataProjectionPredicate], AccountId: [AccountIdProjectionPredicate] }>({ Atom: [0, lib.getCodec(NftPredicateAtom)], Id: [1, lib.getCodec(NftIdProjectionPredicate)], Metadata: [2, lib.getCodec(MetadataProjectionPredicate)], AccountId: [3, lib.getCodec(AccountIdProjectionPredicate)] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type PeerIdPredicateAtom = never
/**
 * Codec for {@link PeerIdPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const PeerIdPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `PublicKey`
 * 
 * TODO how to construct, how to use
 */
export type PeerIdProjectionPredicate = lib.Variant<'Atom', PeerIdPredicateAtom> | lib.Variant<'PublicKey', PublicKeyProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link PeerIdProjectionPredicate}.
 */
export const PeerIdProjectionPredicate: lib.CodecContainer<PeerIdProjectionPredicate> & { PublicKey: { Atom: { Equals: <const T extends lib.PublicKey>(value: T) => lib.Variant<'PublicKey', lib.Variant<'Atom', lib.Variant<'Equals', T>>> } } } = { ...{ PublicKey: { Atom: { Equals: <const T extends lib.PublicKey>(value: T): lib.Variant<'PublicKey', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'PublicKey', value: PublicKeyProjectionPredicate.Atom.Equals(value) }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [PeerIdPredicateAtom], PublicKey: [PublicKeyProjectionPredicate] }>({ Atom: [0, lib.getCodec(PeerIdPredicateAtom)], PublicKey: [1, lib.getCodec(PublicKeyProjectionPredicate)] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type PermissionProjectionPredicate = never
/**
 * Codec for {@link PermissionProjectionPredicate}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const PermissionProjectionPredicate: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type RolePredicateAtom = never
/**
 * Codec for {@link RolePredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const RolePredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type RoleIdPredicateAtom = lib.Variant<'Equals', RoleId>
/**
 * Codec and constructors for enumeration {@link RoleIdPredicateAtom}.
 */
export const RoleIdPredicateAtom: lib.CodecContainer<RoleIdPredicateAtom> & { Equals: <const T extends RoleId>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends RoleId>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [RoleId] }>({ Equals: [0, lib.getCodec(RoleId)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */
export type RoleIdProjectionPredicate = lib.Variant<'Atom', RoleIdPredicateAtom> | lib.Variant<'Name', NameProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link RoleIdProjectionPredicate}.
 */
export const RoleIdProjectionPredicate: lib.CodecContainer<RoleIdProjectionPredicate> & { Atom: { Equals: <const T extends RoleId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>> } } } = { ...{ Atom: { Equals: <const T extends RoleId>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: RoleIdPredicateAtom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.EndsWith(value) }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [RoleIdPredicateAtom], Name: [NameProjectionPredicate] }>({ Atom: [0, lib.getCodec(RoleIdPredicateAtom)], Name: [1, lib.getCodec(NameProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * 
 * TODO how to construct, how to use
 */
export type RoleProjectionPredicate = lib.Variant<'Atom', RolePredicateAtom> | lib.Variant<'Id', RoleIdProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link RoleProjectionPredicate}.
 */
export const RoleProjectionPredicate: lib.CodecContainer<RoleProjectionPredicate> & { Id: { Atom: { Equals: <const T extends RoleId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> } } } } = { ...{ Id: { Atom: { Equals: <const T extends RoleId>(value: T): lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Id', value: RoleIdProjectionPredicate.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: RoleIdProjectionPredicate.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>> => ({ kind: 'Id', value: RoleIdProjectionPredicate.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>> => ({ kind: 'Id', value: RoleIdProjectionPredicate.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> => ({ kind: 'Id', value: RoleIdProjectionPredicate.Name.Atom.EndsWith(value) }) } } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [RolePredicateAtom], Id: [RoleIdProjectionPredicate] }>({ Atom: [0, lib.getCodec(RolePredicateAtom)], Id: [1, lib.getCodec(RoleIdProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `IsEmpty`
 * 
 * TODO how to construct, how to use
 */
export type SignedBlockPredicateAtom = lib.VariantUnit<'IsEmpty'>
/**
 * Codec and constructors for enumeration {@link SignedBlockPredicateAtom}.
 */
export const SignedBlockPredicateAtom: lib.CodecContainer<SignedBlockPredicateAtom> & { IsEmpty: lib.VariantUnit<'IsEmpty'> } = { ...{ IsEmpty: Object.freeze({ kind: 'IsEmpty' }) }, ...lib.defineCodec(lib.enumCodec<{ IsEmpty: [] }>({ IsEmpty: [0] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Header`
 * 
 * TODO how to construct, how to use
 */
export type SignedBlockProjectionPredicate = lib.Variant<'Atom', SignedBlockPredicateAtom> | lib.Variant<'Header', BlockHeaderProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link SignedBlockProjectionPredicate}.
 */
export const SignedBlockProjectionPredicate: lib.CodecContainer<SignedBlockProjectionPredicate> & { Atom: { IsEmpty: lib.Variant<'Atom', lib.VariantUnit<'IsEmpty'>> }, Header: { Hash: { Atom: { Equals: <const T extends lib.Hash>(value: T) => lib.Variant<'Header', lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> } } } } = { ...{ Atom: { IsEmpty: Object.freeze<lib.Variant<'Atom', lib.VariantUnit<'IsEmpty'>>>({ kind: 'Atom', value: SignedBlockPredicateAtom.IsEmpty }) }, Header: { Hash: { Atom: { Equals: <const T extends lib.Hash>(value: T): lib.Variant<'Header', lib.Variant<'Hash', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Header', value: BlockHeaderProjectionPredicate.Hash.Atom.Equals(value) }) } } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [SignedBlockPredicateAtom], Header: [BlockHeaderProjectionPredicate] }>({ Atom: [0, lib.getCodec(SignedBlockPredicateAtom)], Header: [1, lib.getCodec(BlockHeaderProjectionPredicate)] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type TriggerPredicateAtom = never
/**
 * Codec for {@link TriggerPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const TriggerPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Equals`
 * 
 * TODO how to construct, how to use
 */
export type TriggerIdPredicateAtom = lib.Variant<'Equals', TriggerId>
/**
 * Codec and constructors for enumeration {@link TriggerIdPredicateAtom}.
 */
export const TriggerIdPredicateAtom: lib.CodecContainer<TriggerIdPredicateAtom> & { Equals: <const T extends TriggerId>(value: T) => lib.Variant<'Equals', T> } = { ...{ Equals: <const T extends TriggerId>(value: T): lib.Variant<'Equals', T> => ({ kind: 'Equals', value }) }, ...lib.defineCodec(lib.enumCodec<{ Equals: [TriggerId] }>({ Equals: [0, lib.getCodec(TriggerId)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */
export type TriggerIdProjectionPredicate = lib.Variant<'Atom', TriggerIdPredicateAtom> | lib.Variant<'Name', NameProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link TriggerIdProjectionPredicate}.
 */
export const TriggerIdProjectionPredicate: lib.CodecContainer<TriggerIdProjectionPredicate> & { Atom: { Equals: <const T extends TriggerId>(value: T) => lib.Variant<'Atom', lib.Variant<'Equals', T>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>> } } } = { ...{ Atom: { Equals: <const T extends TriggerId>(value: T): lib.Variant<'Atom', lib.Variant<'Equals', T>> => ({ kind: 'Atom', value: TriggerIdPredicateAtom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>> => ({ kind: 'Name', value: NameProjectionPredicate.Atom.EndsWith(value) }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [TriggerIdPredicateAtom], Name: [NameProjectionPredicate] }>({ Atom: [0, lib.getCodec(TriggerIdPredicateAtom)], Name: [1, lib.getCodec(NameProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Action`
 * 
 * TODO how to construct, how to use
 */
export type TriggerProjectionPredicate = lib.Variant<'Atom', TriggerPredicateAtom> | lib.Variant<'Id', TriggerIdProjectionPredicate> | lib.Variant<'Action', ActionProjectionPredicate>
/**
 * Codec and constructors for enumeration {@link TriggerProjectionPredicate}.
 */
export const TriggerProjectionPredicate: lib.CodecContainer<TriggerProjectionPredicate> & { Id: { Atom: { Equals: <const T extends TriggerId>(value: T) => lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> }, Name: { Atom: { Equals: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>>, Contains: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>>, StartsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>>, EndsWith: <const T extends lib.String>(value: T) => lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> } } }, Action: { Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T) => lib.Variant<'Action', lib.Variant<'Metadata', lib.Variant<'Key', T>>> } } } = { ...{ Id: { Atom: { Equals: <const T extends TriggerId>(value: T): lib.Variant<'Id', lib.Variant<'Atom', lib.Variant<'Equals', T>>> => ({ kind: 'Id', value: TriggerIdProjectionPredicate.Atom.Equals(value) }) }, Name: { Atom: { Equals: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Equals', T>>>> => ({ kind: 'Id', value: TriggerIdProjectionPredicate.Name.Atom.Equals(value) }), Contains: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'Contains', T>>>> => ({ kind: 'Id', value: TriggerIdProjectionPredicate.Name.Atom.Contains(value) }), StartsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'StartsWith', T>>>> => ({ kind: 'Id', value: TriggerIdProjectionPredicate.Name.Atom.StartsWith(value) }), EndsWith: <const T extends lib.String>(value: T): lib.Variant<'Id', lib.Variant<'Name', lib.Variant<'Atom', lib.Variant<'EndsWith', T>>>> => ({ kind: 'Id', value: TriggerIdProjectionPredicate.Name.Atom.EndsWith(value) }) } } }, Action: { Metadata: { Key: <const T extends MetadataKeyProjectionPredicate>(value: T): lib.Variant<'Action', lib.Variant<'Metadata', lib.Variant<'Key', T>>> => ({ kind: 'Action', value: ActionProjectionPredicate.Metadata.Key(value) }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [TriggerPredicateAtom], Id: [TriggerIdProjectionPredicate], Action: [ActionProjectionPredicate] }>({ Atom: [0, lib.getCodec(TriggerPredicateAtom)], Id: [1, lib.getCodec(TriggerIdProjectionPredicate)], Action: [2, lib.getCodec(ActionProjectionPredicate)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `BlockTime`
 * - `CommitTime`
 * - `MaxClockDrift`
 * 
 * TODO how to construct, how to use
 */
export type SumeragiParameter = lib.Variant<'BlockTime', lib.Duration> | lib.Variant<'CommitTime', lib.Duration> | lib.Variant<'MaxClockDrift', lib.Duration>
/**
 * Codec and constructors for enumeration {@link SumeragiParameter}.
 */
export const SumeragiParameter: lib.CodecContainer<SumeragiParameter> & { BlockTime: <const T extends lib.Duration>(value: T) => lib.Variant<'BlockTime', T>, CommitTime: <const T extends lib.Duration>(value: T) => lib.Variant<'CommitTime', T>, MaxClockDrift: <const T extends lib.Duration>(value: T) => lib.Variant<'MaxClockDrift', T> } = { ...{ BlockTime: <const T extends lib.Duration>(value: T): lib.Variant<'BlockTime', T> => ({ kind: 'BlockTime', value }), CommitTime: <const T extends lib.Duration>(value: T): lib.Variant<'CommitTime', T> => ({ kind: 'CommitTime', value }), MaxClockDrift: <const T extends lib.Duration>(value: T): lib.Variant<'MaxClockDrift', T> => ({ kind: 'MaxClockDrift', value }) }, ...lib.defineCodec(lib.enumCodec<{ BlockTime: [lib.Duration], CommitTime: [lib.Duration], MaxClockDrift: [lib.Duration] }>({ BlockTime: [0, lib.getCodec(lib.Duration)], CommitTime: [1, lib.getCodec(lib.Duration)], MaxClockDrift: [2, lib.getCodec(lib.Duration)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `MaxInstructions`
 * - `SmartContractSize`
 * 
 * TODO how to construct, how to use
 */
export type TransactionParameter = lib.Variant<'MaxInstructions', lib.NonZero<lib.U64>> | lib.Variant<'SmartContractSize', lib.NonZero<lib.U64>>
/**
 * Codec and constructors for enumeration {@link TransactionParameter}.
 */
export const TransactionParameter: lib.CodecContainer<TransactionParameter> & { MaxInstructions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'MaxInstructions', T>, SmartContractSize: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SmartContractSize', T> } = { ...{ MaxInstructions: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'MaxInstructions', T> => ({ kind: 'MaxInstructions', value }), SmartContractSize: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'SmartContractSize', T> => ({ kind: 'SmartContractSize', value }) }, ...lib.defineCodec(lib.enumCodec<{ MaxInstructions: [lib.NonZero<lib.U64>], SmartContractSize: [lib.NonZero<lib.U64>] }>({ MaxInstructions: [0, lib.NonZero.with(lib.getCodec(lib.U64))], SmartContractSize: [1, lib.NonZero.with(lib.getCodec(lib.U64))] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Fuel`
 * - `Memory`
 * 
 * TODO how to construct, how to use
 */
export type SmartContractParameter = lib.Variant<'Fuel', lib.NonZero<lib.U64>> | lib.Variant<'Memory', lib.NonZero<lib.U64>>
/**
 * Codec and constructors for enumeration {@link SmartContractParameter}.
 */
export const SmartContractParameter: lib.CodecContainer<SmartContractParameter> & { Fuel: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Fuel', T>, Memory: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Memory', T> } = { ...{ Fuel: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'Fuel', T> => ({ kind: 'Fuel', value }), Memory: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'Memory', T> => ({ kind: 'Memory', value }) }, ...lib.defineCodec(lib.enumCodec<{ Fuel: [lib.NonZero<lib.U64>], Memory: [lib.NonZero<lib.U64>] }>({ Fuel: [0, lib.NonZero.with(lib.getCodec(lib.U64))], Memory: [1, lib.NonZero.with(lib.getCodec(lib.U64))] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface CustomParameter { id: CustomParameterId, payload: lib.Json }
/**
 * Codec of the structure.
 */
export const CustomParameter: lib.CodecContainer<CustomParameter> = lib.defineCodec(lib.structCodec<CustomParameter>(['id', 'payload'], {id: lib.getCodec(CustomParameterId), payload: lib.getCodec(lib.Json)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Sumeragi`
 * - `Block`
 * - `Transaction`
 * - `SmartContract`
 * - `Executor`
 * - `Custom`
 * 
 * TODO how to construct, how to use
 */
export type Parameter = lib.Variant<'Sumeragi', SumeragiParameter> | lib.Variant<'Block', BlockParameter> | lib.Variant<'Transaction', TransactionParameter> | lib.Variant<'SmartContract', SmartContractParameter> | lib.Variant<'Executor', SmartContractParameter> | lib.Variant<'Custom', CustomParameter>
/**
 * Codec and constructors for enumeration {@link Parameter}.
 */
export const Parameter: lib.CodecContainer<Parameter> & { Sumeragi: { BlockTime: <const T extends lib.Duration>(value: T) => lib.Variant<'Sumeragi', lib.Variant<'BlockTime', T>>, CommitTime: <const T extends lib.Duration>(value: T) => lib.Variant<'Sumeragi', lib.Variant<'CommitTime', T>>, MaxClockDrift: <const T extends lib.Duration>(value: T) => lib.Variant<'Sumeragi', lib.Variant<'MaxClockDrift', T>> }, Block: { MaxTransactions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Block', lib.Variant<'MaxTransactions', T>> }, Transaction: { MaxInstructions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Transaction', lib.Variant<'MaxInstructions', T>>, SmartContractSize: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Transaction', lib.Variant<'SmartContractSize', T>> }, SmartContract: { Fuel: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SmartContract', lib.Variant<'Fuel', T>>, Memory: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SmartContract', lib.Variant<'Memory', T>> }, Executor: { Fuel: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Executor', lib.Variant<'Fuel', T>>, Memory: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'Executor', lib.Variant<'Memory', T>> }, Custom: <const T extends CustomParameter>(value: T) => lib.Variant<'Custom', T> } = { ...{ Sumeragi: { BlockTime: <const T extends lib.Duration>(value: T): lib.Variant<'Sumeragi', lib.Variant<'BlockTime', T>> => ({ kind: 'Sumeragi', value: SumeragiParameter.BlockTime(value) }), CommitTime: <const T extends lib.Duration>(value: T): lib.Variant<'Sumeragi', lib.Variant<'CommitTime', T>> => ({ kind: 'Sumeragi', value: SumeragiParameter.CommitTime(value) }), MaxClockDrift: <const T extends lib.Duration>(value: T): lib.Variant<'Sumeragi', lib.Variant<'MaxClockDrift', T>> => ({ kind: 'Sumeragi', value: SumeragiParameter.MaxClockDrift(value) }) }, Block: { MaxTransactions: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'Block', lib.Variant<'MaxTransactions', T>> => ({ kind: 'Block', value: BlockParameter.MaxTransactions(value) }) }, Transaction: { MaxInstructions: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'Transaction', lib.Variant<'MaxInstructions', T>> => ({ kind: 'Transaction', value: TransactionParameter.MaxInstructions(value) }), SmartContractSize: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'Transaction', lib.Variant<'SmartContractSize', T>> => ({ kind: 'Transaction', value: TransactionParameter.SmartContractSize(value) }) }, SmartContract: { Fuel: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'SmartContract', lib.Variant<'Fuel', T>> => ({ kind: 'SmartContract', value: SmartContractParameter.Fuel(value) }), Memory: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'SmartContract', lib.Variant<'Memory', T>> => ({ kind: 'SmartContract', value: SmartContractParameter.Memory(value) }) }, Executor: { Fuel: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'Executor', lib.Variant<'Fuel', T>> => ({ kind: 'Executor', value: SmartContractParameter.Fuel(value) }), Memory: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'Executor', lib.Variant<'Memory', T>> => ({ kind: 'Executor', value: SmartContractParameter.Memory(value) }) }, Custom: <const T extends CustomParameter>(value: T): lib.Variant<'Custom', T> => ({ kind: 'Custom', value }) }, ...lib.defineCodec(lib.enumCodec<{ Sumeragi: [SumeragiParameter], Block: [BlockParameter], Transaction: [TransactionParameter], SmartContract: [SmartContractParameter], Executor: [SmartContractParameter], Custom: [CustomParameter] }>({ Sumeragi: [0, lib.getCodec(SumeragiParameter)], Block: [1, lib.getCodec(BlockParameter)], Transaction: [2, lib.getCodec(TransactionParameter)], SmartContract: [3, lib.getCodec(SmartContractParameter)], Executor: [4, lib.getCodec(SmartContractParameter)], Custom: [5, lib.getCodec(CustomParameter)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface ParameterChanged { oldValue: Parameter, newValue: Parameter }
/**
 * Codec of the structure.
 */
export const ParameterChanged: lib.CodecContainer<ParameterChanged> = lib.defineCodec(lib.structCodec<ParameterChanged>(['oldValue', 'newValue'], {oldValue: lib.getCodec(Parameter), newValue: lib.getCodec(Parameter)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Changed`
 * 
 * TODO how to construct, how to use
 */
export type ConfigurationEvent = lib.Variant<'Changed', ParameterChanged>
/**
 * Codec and constructors for enumeration {@link ConfigurationEvent}.
 */
export const ConfigurationEvent: lib.CodecContainer<ConfigurationEvent> & { Changed: <const T extends ParameterChanged>(value: T) => lib.Variant<'Changed', T> } = { ...{ Changed: <const T extends ParameterChanged>(value: T): lib.Variant<'Changed', T> => ({ kind: 'Changed', value }) }, ...lib.defineCodec(lib.enumCodec<{ Changed: [ParameterChanged] }>({ Changed: [0, lib.getCodec(ParameterChanged)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface CustomInstruction { payload: lib.Json }
/**
 * Codec of the structure.
 */
export const CustomInstruction: lib.CodecContainer<CustomInstruction> = lib.defineCodec(lib.structCodec<CustomInstruction>(['payload'], {payload: lib.getCodec(lib.Json)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Added`
 * - `Removed`
 * 
 * TODO how to construct, how to use
 */
export type PeerEvent = lib.Variant<'Added', PeerId> | lib.Variant<'Removed', PeerId>
/**
 * Codec and constructors for enumeration {@link PeerEvent}.
 */
export const PeerEvent: lib.CodecContainer<PeerEvent> & { Added: <const T extends PeerId>(value: T) => lib.Variant<'Added', T>, Removed: <const T extends PeerId>(value: T) => lib.Variant<'Removed', T> } = { ...{ Added: <const T extends PeerId>(value: T): lib.Variant<'Added', T> => ({ kind: 'Added', value }), Removed: <const T extends PeerId>(value: T): lib.Variant<'Removed', T> => ({ kind: 'Removed', value }) }, ...lib.defineCodec(lib.enumCodec<{ Added: [PeerId], Removed: [PeerId] }>({ Added: [0, lib.getCodec(PeerId)], Removed: [1, lib.getCodec(PeerId)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface Domain { id: lib.DomainId, logo: lib.Option<IpfsPath>, metadata: Metadata, ownedBy: lib.AccountId }
/**
 * Codec of the structure.
 */
export const Domain: lib.CodecContainer<Domain> = lib.defineCodec(lib.structCodec<Domain>(['id', 'logo', 'metadata', 'ownedBy'], {id: lib.getCodec(lib.DomainId), logo: lib.Option.with(lib.getCodec(IpfsPath)), metadata: lib.getCodec(Metadata), ownedBy: lib.getCodec(lib.AccountId)}))

/**
 * Structure with named fields.
 */
export interface Nft { id: lib.NftId, content: Metadata, ownedBy: lib.AccountId }
/**
 * Codec of the structure.
 */
export const Nft: lib.CodecContainer<Nft> = lib.defineCodec(lib.structCodec<Nft>(['id', 'content', 'ownedBy'], {id: lib.getCodec(lib.NftId), content: lib.getCodec(Metadata), ownedBy: lib.getCodec(lib.AccountId)}))

/**
 * Structure with named fields.
 */
export interface NftOwnerChanged { nft: lib.NftId, newOwner: lib.AccountId }
/**
 * Codec of the structure.
 */
export const NftOwnerChanged: lib.CodecContainer<NftOwnerChanged> = lib.defineCodec(lib.structCodec<NftOwnerChanged>(['nft', 'newOwner'], {nft: lib.getCodec(lib.NftId), newOwner: lib.getCodec(lib.AccountId)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `MetadataInserted`
 * - `MetadataRemoved`
 * - `OwnerChanged`
 * 
 * TODO how to construct, how to use
 */
export type NftEvent = lib.Variant<'Created', Nft> | lib.Variant<'Deleted', lib.NftId> | lib.Variant<'MetadataInserted', MetadataChanged<lib.NftId>> | lib.Variant<'MetadataRemoved', MetadataChanged<lib.NftId>> | lib.Variant<'OwnerChanged', NftOwnerChanged>
/**
 * Codec and constructors for enumeration {@link NftEvent}.
 */
export const NftEvent: lib.CodecContainer<NftEvent> & { Created: <const T extends Nft>(value: T) => lib.Variant<'Created', T>, Deleted: <const T extends lib.NftId>(value: T) => lib.Variant<'Deleted', T>, MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'MetadataInserted', T>, MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'MetadataRemoved', T>, OwnerChanged: <const T extends NftOwnerChanged>(value: T) => lib.Variant<'OwnerChanged', T> } = { ...{ Created: <const T extends Nft>(value: T): lib.Variant<'Created', T> => ({ kind: 'Created', value }), Deleted: <const T extends lib.NftId>(value: T): lib.Variant<'Deleted', T> => ({ kind: 'Deleted', value }), MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T): lib.Variant<'MetadataInserted', T> => ({ kind: 'MetadataInserted', value }), MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T): lib.Variant<'MetadataRemoved', T> => ({ kind: 'MetadataRemoved', value }), OwnerChanged: <const T extends NftOwnerChanged>(value: T): lib.Variant<'OwnerChanged', T> => ({ kind: 'OwnerChanged', value }) }, ...lib.defineCodec(lib.enumCodec<{ Created: [Nft], Deleted: [lib.NftId], MetadataInserted: [MetadataChanged<lib.NftId>], MetadataRemoved: [MetadataChanged<lib.NftId>], OwnerChanged: [NftOwnerChanged] }>({ Created: [0, lib.getCodec(Nft)], Deleted: [1, lib.getCodec(lib.NftId)], MetadataInserted: [2, MetadataChanged.with(lib.getCodec(lib.NftId))], MetadataRemoved: [3, MetadataChanged.with(lib.getCodec(lib.NftId))], OwnerChanged: [4, lib.getCodec(NftOwnerChanged)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface DomainOwnerChanged { domain: lib.DomainId, newOwner: lib.AccountId }
/**
 * Codec of the structure.
 */
export const DomainOwnerChanged: lib.CodecContainer<DomainOwnerChanged> = lib.defineCodec(lib.structCodec<DomainOwnerChanged>(['domain', 'newOwner'], {domain: lib.getCodec(lib.DomainId), newOwner: lib.getCodec(lib.AccountId)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `AssetDefinition`
 * - `Nft`
 * - `Account`
 * - `MetadataInserted`
 * - `MetadataRemoved`
 * - `OwnerChanged`
 * 
 * TODO how to construct, how to use
 */
export type DomainEvent = lib.Variant<'Created', Domain> | lib.Variant<'Deleted', lib.DomainId> | lib.Variant<'AssetDefinition', AssetDefinitionEvent> | lib.Variant<'Nft', NftEvent> | lib.Variant<'Account', AccountEvent> | lib.Variant<'MetadataInserted', MetadataChanged<lib.DomainId>> | lib.Variant<'MetadataRemoved', MetadataChanged<lib.DomainId>> | lib.Variant<'OwnerChanged', DomainOwnerChanged>
/**
 * Codec and constructors for enumeration {@link DomainEvent}.
 */
export const DomainEvent: lib.CodecContainer<DomainEvent> & { Created: <const T extends Domain>(value: T) => lib.Variant<'Created', T>, Deleted: <const T extends lib.DomainId>(value: T) => lib.Variant<'Deleted', T>, AssetDefinition: { Created: <const T extends AssetDefinition>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'Created', T>>, Deleted: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'Deleted', T>>, MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'MetadataInserted', T>>, MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'MetadataRemoved', T>>, MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'MintabilityChanged', T>>, TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'TotalQuantityChanged', T>>, OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T) => lib.Variant<'AssetDefinition', lib.Variant<'OwnerChanged', T>> }, Nft: { Created: <const T extends Nft>(value: T) => lib.Variant<'Nft', lib.Variant<'Created', T>>, Deleted: <const T extends lib.NftId>(value: T) => lib.Variant<'Nft', lib.Variant<'Deleted', T>>, MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Nft', lib.Variant<'MetadataInserted', T>>, MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Nft', lib.Variant<'MetadataRemoved', T>>, OwnerChanged: <const T extends NftOwnerChanged>(value: T) => lib.Variant<'Nft', lib.Variant<'OwnerChanged', T>> }, Account: { Created: <const T extends Account>(value: T) => lib.Variant<'Account', lib.Variant<'Created', T>>, Deleted: <const T extends lib.AccountId>(value: T) => lib.Variant<'Account', lib.Variant<'Deleted', T>>, Asset: { Created: <const T extends Asset>(value: T) => lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Created', T>>>, Deleted: <const T extends lib.AssetId>(value: T) => lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Deleted', T>>>, Added: <const T extends AssetChanged>(value: T) => lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Added', T>>>, Removed: <const T extends AssetChanged>(value: T) => lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Removed', T>>> }, PermissionAdded: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Account', lib.Variant<'PermissionAdded', T>>, PermissionRemoved: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Account', lib.Variant<'PermissionRemoved', T>>, RoleGranted: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Account', lib.Variant<'RoleGranted', T>>, RoleRevoked: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Account', lib.Variant<'RoleRevoked', T>>, MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Account', lib.Variant<'MetadataInserted', T>>, MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Account', lib.Variant<'MetadataRemoved', T>> }, MetadataInserted: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'MetadataInserted', T>, MetadataRemoved: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'MetadataRemoved', T>, OwnerChanged: <const T extends DomainOwnerChanged>(value: T) => lib.Variant<'OwnerChanged', T> } = { ...{ Created: <const T extends Domain>(value: T): lib.Variant<'Created', T> => ({ kind: 'Created', value }), Deleted: <const T extends lib.DomainId>(value: T): lib.Variant<'Deleted', T> => ({ kind: 'Deleted', value }), AssetDefinition: { Created: <const T extends AssetDefinition>(value: T): lib.Variant<'AssetDefinition', lib.Variant<'Created', T>> => ({ kind: 'AssetDefinition', value: AssetDefinitionEvent.Created(value) }), Deleted: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'AssetDefinition', lib.Variant<'Deleted', T>> => ({ kind: 'AssetDefinition', value: AssetDefinitionEvent.Deleted(value) }), MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T): lib.Variant<'AssetDefinition', lib.Variant<'MetadataInserted', T>> => ({ kind: 'AssetDefinition', value: AssetDefinitionEvent.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T): lib.Variant<'AssetDefinition', lib.Variant<'MetadataRemoved', T>> => ({ kind: 'AssetDefinition', value: AssetDefinitionEvent.MetadataRemoved(value) }), MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'AssetDefinition', lib.Variant<'MintabilityChanged', T>> => ({ kind: 'AssetDefinition', value: AssetDefinitionEvent.MintabilityChanged(value) }), TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T): lib.Variant<'AssetDefinition', lib.Variant<'TotalQuantityChanged', T>> => ({ kind: 'AssetDefinition', value: AssetDefinitionEvent.TotalQuantityChanged(value) }), OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T): lib.Variant<'AssetDefinition', lib.Variant<'OwnerChanged', T>> => ({ kind: 'AssetDefinition', value: AssetDefinitionEvent.OwnerChanged(value) }) }, Nft: { Created: <const T extends Nft>(value: T): lib.Variant<'Nft', lib.Variant<'Created', T>> => ({ kind: 'Nft', value: NftEvent.Created(value) }), Deleted: <const T extends lib.NftId>(value: T): lib.Variant<'Nft', lib.Variant<'Deleted', T>> => ({ kind: 'Nft', value: NftEvent.Deleted(value) }), MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T): lib.Variant<'Nft', lib.Variant<'MetadataInserted', T>> => ({ kind: 'Nft', value: NftEvent.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T): lib.Variant<'Nft', lib.Variant<'MetadataRemoved', T>> => ({ kind: 'Nft', value: NftEvent.MetadataRemoved(value) }), OwnerChanged: <const T extends NftOwnerChanged>(value: T): lib.Variant<'Nft', lib.Variant<'OwnerChanged', T>> => ({ kind: 'Nft', value: NftEvent.OwnerChanged(value) }) }, Account: { Created: <const T extends Account>(value: T): lib.Variant<'Account', lib.Variant<'Created', T>> => ({ kind: 'Account', value: AccountEvent.Created(value) }), Deleted: <const T extends lib.AccountId>(value: T): lib.Variant<'Account', lib.Variant<'Deleted', T>> => ({ kind: 'Account', value: AccountEvent.Deleted(value) }), Asset: { Created: <const T extends Asset>(value: T): lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Created', T>>> => ({ kind: 'Account', value: AccountEvent.Asset.Created(value) }), Deleted: <const T extends lib.AssetId>(value: T): lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Deleted', T>>> => ({ kind: 'Account', value: AccountEvent.Asset.Deleted(value) }), Added: <const T extends AssetChanged>(value: T): lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Added', T>>> => ({ kind: 'Account', value: AccountEvent.Asset.Added(value) }), Removed: <const T extends AssetChanged>(value: T): lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Removed', T>>> => ({ kind: 'Account', value: AccountEvent.Asset.Removed(value) }) }, PermissionAdded: <const T extends AccountPermissionChanged>(value: T): lib.Variant<'Account', lib.Variant<'PermissionAdded', T>> => ({ kind: 'Account', value: AccountEvent.PermissionAdded(value) }), PermissionRemoved: <const T extends AccountPermissionChanged>(value: T): lib.Variant<'Account', lib.Variant<'PermissionRemoved', T>> => ({ kind: 'Account', value: AccountEvent.PermissionRemoved(value) }), RoleGranted: <const T extends AccountRoleChanged>(value: T): lib.Variant<'Account', lib.Variant<'RoleGranted', T>> => ({ kind: 'Account', value: AccountEvent.RoleGranted(value) }), RoleRevoked: <const T extends AccountRoleChanged>(value: T): lib.Variant<'Account', lib.Variant<'RoleRevoked', T>> => ({ kind: 'Account', value: AccountEvent.RoleRevoked(value) }), MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T): lib.Variant<'Account', lib.Variant<'MetadataInserted', T>> => ({ kind: 'Account', value: AccountEvent.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T): lib.Variant<'Account', lib.Variant<'MetadataRemoved', T>> => ({ kind: 'Account', value: AccountEvent.MetadataRemoved(value) }) }, MetadataInserted: <const T extends MetadataChanged<lib.DomainId>>(value: T): lib.Variant<'MetadataInserted', T> => ({ kind: 'MetadataInserted', value }), MetadataRemoved: <const T extends MetadataChanged<lib.DomainId>>(value: T): lib.Variant<'MetadataRemoved', T> => ({ kind: 'MetadataRemoved', value }), OwnerChanged: <const T extends DomainOwnerChanged>(value: T): lib.Variant<'OwnerChanged', T> => ({ kind: 'OwnerChanged', value }) }, ...lib.defineCodec(lib.enumCodec<{ Created: [Domain], Deleted: [lib.DomainId], AssetDefinition: [AssetDefinitionEvent], Nft: [NftEvent], Account: [AccountEvent], MetadataInserted: [MetadataChanged<lib.DomainId>], MetadataRemoved: [MetadataChanged<lib.DomainId>], OwnerChanged: [DomainOwnerChanged] }>({ Created: [0, lib.getCodec(Domain)], Deleted: [1, lib.getCodec(lib.DomainId)], AssetDefinition: [2, lib.getCodec(AssetDefinitionEvent)], Nft: [3, lib.getCodec(NftEvent)], Account: [4, lib.getCodec(AccountEvent)], MetadataInserted: [5, MetadataChanged.with(lib.getCodec(lib.DomainId))], MetadataRemoved: [6, MetadataChanged.with(lib.getCodec(lib.DomainId))], OwnerChanged: [7, lib.getCodec(DomainOwnerChanged)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface TriggerNumberOfExecutionsChanged { trigger: TriggerId, by: lib.U32 }
/**
 * Codec of the structure.
 */
export const TriggerNumberOfExecutionsChanged: lib.CodecContainer<TriggerNumberOfExecutionsChanged> = lib.defineCodec(lib.structCodec<TriggerNumberOfExecutionsChanged>(['trigger', 'by'], {trigger: lib.getCodec(TriggerId), by: lib.getCodec(lib.U32)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `Extended`
 * - `Shortened`
 * - `MetadataInserted`
 * - `MetadataRemoved`
 * 
 * TODO how to construct, how to use
 */
export type TriggerEvent = lib.Variant<'Created', TriggerId> | lib.Variant<'Deleted', TriggerId> | lib.Variant<'Extended', TriggerNumberOfExecutionsChanged> | lib.Variant<'Shortened', TriggerNumberOfExecutionsChanged> | lib.Variant<'MetadataInserted', MetadataChanged<TriggerId>> | lib.Variant<'MetadataRemoved', MetadataChanged<TriggerId>>
/**
 * Codec and constructors for enumeration {@link TriggerEvent}.
 */
export const TriggerEvent: lib.CodecContainer<TriggerEvent> & { Created: <const T extends TriggerId>(value: T) => lib.Variant<'Created', T>, Deleted: <const T extends TriggerId>(value: T) => lib.Variant<'Deleted', T>, Extended: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Extended', T>, Shortened: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Shortened', T>, MetadataInserted: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'MetadataInserted', T>, MetadataRemoved: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'MetadataRemoved', T> } = { ...{ Created: <const T extends TriggerId>(value: T): lib.Variant<'Created', T> => ({ kind: 'Created', value }), Deleted: <const T extends TriggerId>(value: T): lib.Variant<'Deleted', T> => ({ kind: 'Deleted', value }), Extended: <const T extends TriggerNumberOfExecutionsChanged>(value: T): lib.Variant<'Extended', T> => ({ kind: 'Extended', value }), Shortened: <const T extends TriggerNumberOfExecutionsChanged>(value: T): lib.Variant<'Shortened', T> => ({ kind: 'Shortened', value }), MetadataInserted: <const T extends MetadataChanged<TriggerId>>(value: T): lib.Variant<'MetadataInserted', T> => ({ kind: 'MetadataInserted', value }), MetadataRemoved: <const T extends MetadataChanged<TriggerId>>(value: T): lib.Variant<'MetadataRemoved', T> => ({ kind: 'MetadataRemoved', value }) }, ...lib.defineCodec(lib.enumCodec<{ Created: [TriggerId], Deleted: [TriggerId], Extended: [TriggerNumberOfExecutionsChanged], Shortened: [TriggerNumberOfExecutionsChanged], MetadataInserted: [MetadataChanged<TriggerId>], MetadataRemoved: [MetadataChanged<TriggerId>] }>({ Created: [0, lib.getCodec(TriggerId)], Deleted: [1, lib.getCodec(TriggerId)], Extended: [2, lib.getCodec(TriggerNumberOfExecutionsChanged)], Shortened: [3, lib.getCodec(TriggerNumberOfExecutionsChanged)], MetadataInserted: [4, MetadataChanged.with(lib.getCodec(TriggerId))], MetadataRemoved: [5, MetadataChanged.with(lib.getCodec(TriggerId))] }).discriminated()) }

export type PermissionsSet = lib.BTreeSet<Permission>
export const PermissionsSet: lib.CodecContainer<PermissionsSet> = lib.defineCodec(lib.BTreeSet.withCmp(lib.getCodec(Permission), (a, b) => {  
                const names = lib.ordCompare(a.name, b.name)
                if (names !== 0) return names
                return lib.ordCompare(a.payload, b.payload)
              }))

/**
 * Structure with named fields.
 */
export interface Role { id: RoleId, permissions: PermissionsSet }
/**
 * Codec of the structure.
 */
export const Role: lib.CodecContainer<Role> = lib.defineCodec(lib.structCodec<Role>(['id', 'permissions'], {id: lib.getCodec(RoleId), permissions: lib.getCodec(PermissionsSet)}))

/**
 * Structure with named fields.
 */
export interface RolePermissionChanged { role: RoleId, permission: Permission }
/**
 * Codec of the structure.
 */
export const RolePermissionChanged: lib.CodecContainer<RolePermissionChanged> = lib.defineCodec(lib.structCodec<RolePermissionChanged>(['role', 'permission'], {role: lib.getCodec(RoleId), permission: lib.getCodec(Permission)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Created`
 * - `Deleted`
 * - `PermissionAdded`
 * - `PermissionRemoved`
 * 
 * TODO how to construct, how to use
 */
export type RoleEvent = lib.Variant<'Created', Role> | lib.Variant<'Deleted', RoleId> | lib.Variant<'PermissionAdded', RolePermissionChanged> | lib.Variant<'PermissionRemoved', RolePermissionChanged>
/**
 * Codec and constructors for enumeration {@link RoleEvent}.
 */
export const RoleEvent: lib.CodecContainer<RoleEvent> & { Created: <const T extends Role>(value: T) => lib.Variant<'Created', T>, Deleted: <const T extends RoleId>(value: T) => lib.Variant<'Deleted', T>, PermissionAdded: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'PermissionAdded', T>, PermissionRemoved: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'PermissionRemoved', T> } = { ...{ Created: <const T extends Role>(value: T): lib.Variant<'Created', T> => ({ kind: 'Created', value }), Deleted: <const T extends RoleId>(value: T): lib.Variant<'Deleted', T> => ({ kind: 'Deleted', value }), PermissionAdded: <const T extends RolePermissionChanged>(value: T): lib.Variant<'PermissionAdded', T> => ({ kind: 'PermissionAdded', value }), PermissionRemoved: <const T extends RolePermissionChanged>(value: T): lib.Variant<'PermissionRemoved', T> => ({ kind: 'PermissionRemoved', value }) }, ...lib.defineCodec(lib.enumCodec<{ Created: [Role], Deleted: [RoleId], PermissionAdded: [RolePermissionChanged], PermissionRemoved: [RolePermissionChanged] }>({ Created: [0, lib.getCodec(Role)], Deleted: [1, lib.getCodec(RoleId)], PermissionAdded: [2, lib.getCodec(RolePermissionChanged)], PermissionRemoved: [3, lib.getCodec(RolePermissionChanged)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface ExecutorDataModel { parameters: lib.BTreeMap<CustomParameterId, CustomParameter>, instructions: lib.BTreeSet<lib.String>, permissions: lib.BTreeSet<lib.String>, schema: lib.Json }
/**
 * Codec of the structure.
 */
export const ExecutorDataModel: lib.CodecContainer<ExecutorDataModel> = lib.defineCodec(lib.structCodec<ExecutorDataModel>(['parameters', 'instructions', 'permissions', 'schema'], {parameters: lib.BTreeMap.with(lib.getCodec(CustomParameterId), lib.getCodec(CustomParameter)), instructions: lib.BTreeSet.with(lib.getCodec(lib.String)), permissions: lib.BTreeSet.with(lib.getCodec(lib.String)), schema: lib.getCodec(lib.Json)}))

/**
 * Structure with named fields.
 */
export interface ExecutorUpgrade { newDataModel: ExecutorDataModel }
/**
 * Codec of the structure.
 */
export const ExecutorUpgrade: lib.CodecContainer<ExecutorUpgrade> = lib.defineCodec(lib.structCodec<ExecutorUpgrade>(['newDataModel'], {newDataModel: lib.getCodec(ExecutorDataModel)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Upgraded`
 * 
 * TODO how to construct, how to use
 */
export type ExecutorEvent = lib.Variant<'Upgraded', ExecutorUpgrade>
/**
 * Codec and constructors for enumeration {@link ExecutorEvent}.
 */
export const ExecutorEvent: lib.CodecContainer<ExecutorEvent> & { Upgraded: <const T extends ExecutorUpgrade>(value: T) => lib.Variant<'Upgraded', T> } = { ...{ Upgraded: <const T extends ExecutorUpgrade>(value: T): lib.Variant<'Upgraded', T> => ({ kind: 'Upgraded', value }) }, ...lib.defineCodec(lib.enumCodec<{ Upgraded: [ExecutorUpgrade] }>({ Upgraded: [0, lib.getCodec(ExecutorUpgrade)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Peer`
 * - `Domain`
 * - `Trigger`
 * - `Role`
 * - `Configuration`
 * - `Executor`
 * 
 * TODO how to construct, how to use
 */
export type DataEvent = lib.Variant<'Peer', PeerEvent> | lib.Variant<'Domain', DomainEvent> | lib.Variant<'Trigger', TriggerEvent> | lib.Variant<'Role', RoleEvent> | lib.Variant<'Configuration', ConfigurationEvent> | lib.Variant<'Executor', ExecutorEvent>
/**
 * Codec and constructors for enumeration {@link DataEvent}.
 */
export const DataEvent: lib.CodecContainer<DataEvent> & { Peer: { Added: <const T extends PeerId>(value: T) => lib.Variant<'Peer', lib.Variant<'Added', T>>, Removed: <const T extends PeerId>(value: T) => lib.Variant<'Peer', lib.Variant<'Removed', T>> }, Domain: { Created: <const T extends Domain>(value: T) => lib.Variant<'Domain', lib.Variant<'Created', T>>, Deleted: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', lib.Variant<'Deleted', T>>, AssetDefinition: { Created: <const T extends AssetDefinition>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Created', T>>>, Deleted: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Deleted', T>>>, MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataInserted', T>>>, MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataRemoved', T>>>, MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MintabilityChanged', T>>>, TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'TotalQuantityChanged', T>>>, OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'OwnerChanged', T>>> }, Nft: { Created: <const T extends Nft>(value: T) => lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Created', T>>>, Deleted: <const T extends lib.NftId>(value: T) => lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Deleted', T>>>, MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataInserted', T>>>, MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataRemoved', T>>>, OwnerChanged: <const T extends NftOwnerChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'OwnerChanged', T>>> }, Account: { Created: <const T extends Account>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Created', T>>>, Deleted: <const T extends lib.AccountId>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Deleted', T>>>, Asset: { Created: <const T extends Asset>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Created', T>>>>, Deleted: <const T extends lib.AssetId>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Deleted', T>>>>, Added: <const T extends AssetChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Added', T>>>>, Removed: <const T extends AssetChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Removed', T>>>> }, PermissionAdded: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionAdded', T>>>, PermissionRemoved: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionRemoved', T>>>, RoleGranted: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleGranted', T>>>, RoleRevoked: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleRevoked', T>>>, MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataInserted', T>>>, MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataRemoved', T>>> }, MetadataInserted: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'Domain', lib.Variant<'MetadataInserted', T>>, MetadataRemoved: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'Domain', lib.Variant<'MetadataRemoved', T>>, OwnerChanged: <const T extends DomainOwnerChanged>(value: T) => lib.Variant<'Domain', lib.Variant<'OwnerChanged', T>> }, Trigger: { Created: <const T extends TriggerId>(value: T) => lib.Variant<'Trigger', lib.Variant<'Created', T>>, Deleted: <const T extends TriggerId>(value: T) => lib.Variant<'Trigger', lib.Variant<'Deleted', T>>, Extended: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Trigger', lib.Variant<'Extended', T>>, Shortened: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Trigger', lib.Variant<'Shortened', T>>, MetadataInserted: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'Trigger', lib.Variant<'MetadataInserted', T>>, MetadataRemoved: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'Trigger', lib.Variant<'MetadataRemoved', T>> }, Role: { Created: <const T extends Role>(value: T) => lib.Variant<'Role', lib.Variant<'Created', T>>, Deleted: <const T extends RoleId>(value: T) => lib.Variant<'Role', lib.Variant<'Deleted', T>>, PermissionAdded: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'Role', lib.Variant<'PermissionAdded', T>>, PermissionRemoved: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'Role', lib.Variant<'PermissionRemoved', T>> }, Configuration: { Changed: <const T extends ParameterChanged>(value: T) => lib.Variant<'Configuration', lib.Variant<'Changed', T>> }, Executor: { Upgraded: <const T extends ExecutorUpgrade>(value: T) => lib.Variant<'Executor', lib.Variant<'Upgraded', T>> } } = { ...{ Peer: { Added: <const T extends PeerId>(value: T): lib.Variant<'Peer', lib.Variant<'Added', T>> => ({ kind: 'Peer', value: PeerEvent.Added(value) }), Removed: <const T extends PeerId>(value: T): lib.Variant<'Peer', lib.Variant<'Removed', T>> => ({ kind: 'Peer', value: PeerEvent.Removed(value) }) }, Domain: { Created: <const T extends Domain>(value: T): lib.Variant<'Domain', lib.Variant<'Created', T>> => ({ kind: 'Domain', value: DomainEvent.Created(value) }), Deleted: <const T extends lib.DomainId>(value: T): lib.Variant<'Domain', lib.Variant<'Deleted', T>> => ({ kind: 'Domain', value: DomainEvent.Deleted(value) }), AssetDefinition: { Created: <const T extends AssetDefinition>(value: T): lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Created', T>>> => ({ kind: 'Domain', value: DomainEvent.AssetDefinition.Created(value) }), Deleted: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Deleted', T>>> => ({ kind: 'Domain', value: DomainEvent.AssetDefinition.Deleted(value) }), MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T): lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataInserted', T>>> => ({ kind: 'Domain', value: DomainEvent.AssetDefinition.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T): lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataRemoved', T>>> => ({ kind: 'Domain', value: DomainEvent.AssetDefinition.MetadataRemoved(value) }), MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MintabilityChanged', T>>> => ({ kind: 'Domain', value: DomainEvent.AssetDefinition.MintabilityChanged(value) }), TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T): lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'TotalQuantityChanged', T>>> => ({ kind: 'Domain', value: DomainEvent.AssetDefinition.TotalQuantityChanged(value) }), OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T): lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'OwnerChanged', T>>> => ({ kind: 'Domain', value: DomainEvent.AssetDefinition.OwnerChanged(value) }) }, Nft: { Created: <const T extends Nft>(value: T): lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Created', T>>> => ({ kind: 'Domain', value: DomainEvent.Nft.Created(value) }), Deleted: <const T extends lib.NftId>(value: T): lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Deleted', T>>> => ({ kind: 'Domain', value: DomainEvent.Nft.Deleted(value) }), MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T): lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataInserted', T>>> => ({ kind: 'Domain', value: DomainEvent.Nft.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T): lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataRemoved', T>>> => ({ kind: 'Domain', value: DomainEvent.Nft.MetadataRemoved(value) }), OwnerChanged: <const T extends NftOwnerChanged>(value: T): lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'OwnerChanged', T>>> => ({ kind: 'Domain', value: DomainEvent.Nft.OwnerChanged(value) }) }, Account: { Created: <const T extends Account>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Created', T>>> => ({ kind: 'Domain', value: DomainEvent.Account.Created(value) }), Deleted: <const T extends lib.AccountId>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Deleted', T>>> => ({ kind: 'Domain', value: DomainEvent.Account.Deleted(value) }), Asset: { Created: <const T extends Asset>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Created', T>>>> => ({ kind: 'Domain', value: DomainEvent.Account.Asset.Created(value) }), Deleted: <const T extends lib.AssetId>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Deleted', T>>>> => ({ kind: 'Domain', value: DomainEvent.Account.Asset.Deleted(value) }), Added: <const T extends AssetChanged>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Added', T>>>> => ({ kind: 'Domain', value: DomainEvent.Account.Asset.Added(value) }), Removed: <const T extends AssetChanged>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Removed', T>>>> => ({ kind: 'Domain', value: DomainEvent.Account.Asset.Removed(value) }) }, PermissionAdded: <const T extends AccountPermissionChanged>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionAdded', T>>> => ({ kind: 'Domain', value: DomainEvent.Account.PermissionAdded(value) }), PermissionRemoved: <const T extends AccountPermissionChanged>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionRemoved', T>>> => ({ kind: 'Domain', value: DomainEvent.Account.PermissionRemoved(value) }), RoleGranted: <const T extends AccountRoleChanged>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleGranted', T>>> => ({ kind: 'Domain', value: DomainEvent.Account.RoleGranted(value) }), RoleRevoked: <const T extends AccountRoleChanged>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleRevoked', T>>> => ({ kind: 'Domain', value: DomainEvent.Account.RoleRevoked(value) }), MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataInserted', T>>> => ({ kind: 'Domain', value: DomainEvent.Account.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T): lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataRemoved', T>>> => ({ kind: 'Domain', value: DomainEvent.Account.MetadataRemoved(value) }) }, MetadataInserted: <const T extends MetadataChanged<lib.DomainId>>(value: T): lib.Variant<'Domain', lib.Variant<'MetadataInserted', T>> => ({ kind: 'Domain', value: DomainEvent.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.DomainId>>(value: T): lib.Variant<'Domain', lib.Variant<'MetadataRemoved', T>> => ({ kind: 'Domain', value: DomainEvent.MetadataRemoved(value) }), OwnerChanged: <const T extends DomainOwnerChanged>(value: T): lib.Variant<'Domain', lib.Variant<'OwnerChanged', T>> => ({ kind: 'Domain', value: DomainEvent.OwnerChanged(value) }) }, Trigger: { Created: <const T extends TriggerId>(value: T): lib.Variant<'Trigger', lib.Variant<'Created', T>> => ({ kind: 'Trigger', value: TriggerEvent.Created(value) }), Deleted: <const T extends TriggerId>(value: T): lib.Variant<'Trigger', lib.Variant<'Deleted', T>> => ({ kind: 'Trigger', value: TriggerEvent.Deleted(value) }), Extended: <const T extends TriggerNumberOfExecutionsChanged>(value: T): lib.Variant<'Trigger', lib.Variant<'Extended', T>> => ({ kind: 'Trigger', value: TriggerEvent.Extended(value) }), Shortened: <const T extends TriggerNumberOfExecutionsChanged>(value: T): lib.Variant<'Trigger', lib.Variant<'Shortened', T>> => ({ kind: 'Trigger', value: TriggerEvent.Shortened(value) }), MetadataInserted: <const T extends MetadataChanged<TriggerId>>(value: T): lib.Variant<'Trigger', lib.Variant<'MetadataInserted', T>> => ({ kind: 'Trigger', value: TriggerEvent.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<TriggerId>>(value: T): lib.Variant<'Trigger', lib.Variant<'MetadataRemoved', T>> => ({ kind: 'Trigger', value: TriggerEvent.MetadataRemoved(value) }) }, Role: { Created: <const T extends Role>(value: T): lib.Variant<'Role', lib.Variant<'Created', T>> => ({ kind: 'Role', value: RoleEvent.Created(value) }), Deleted: <const T extends RoleId>(value: T): lib.Variant<'Role', lib.Variant<'Deleted', T>> => ({ kind: 'Role', value: RoleEvent.Deleted(value) }), PermissionAdded: <const T extends RolePermissionChanged>(value: T): lib.Variant<'Role', lib.Variant<'PermissionAdded', T>> => ({ kind: 'Role', value: RoleEvent.PermissionAdded(value) }), PermissionRemoved: <const T extends RolePermissionChanged>(value: T): lib.Variant<'Role', lib.Variant<'PermissionRemoved', T>> => ({ kind: 'Role', value: RoleEvent.PermissionRemoved(value) }) }, Configuration: { Changed: <const T extends ParameterChanged>(value: T): lib.Variant<'Configuration', lib.Variant<'Changed', T>> => ({ kind: 'Configuration', value: ConfigurationEvent.Changed(value) }) }, Executor: { Upgraded: <const T extends ExecutorUpgrade>(value: T): lib.Variant<'Executor', lib.Variant<'Upgraded', T>> => ({ kind: 'Executor', value: ExecutorEvent.Upgraded(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Peer: [PeerEvent], Domain: [DomainEvent], Trigger: [TriggerEvent], Role: [RoleEvent], Configuration: [ConfigurationEvent], Executor: [ExecutorEvent] }>({ Peer: [0, lib.getCodec(PeerEvent)], Domain: [1, lib.getCodec(DomainEvent)], Trigger: [2, lib.getCodec(TriggerEvent)], Role: [3, lib.getCodec(RoleEvent)], Configuration: [4, lib.getCodec(ConfigurationEvent)], Executor: [5, lib.getCodec(ExecutorEvent)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * 
 * TODO how to construct, how to use
 */
export type DomainProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', DomainIdProjectionSelector> | lib.Variant<'Metadata', MetadataProjectionSelector>
/**
 * Codec and constructors for enumeration {@link DomainProjectionSelector}.
 */
export const DomainProjectionSelector: lib.CodecContainer<DomainProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Id: { Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>, Name: { Atom: lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>> } }, Metadata: { Atom: lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>, Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Id: { Atom: Object.freeze<lib.Variant<'Id', lib.VariantUnit<'Atom'>>>({ kind: 'Id', value: DomainIdProjectionSelector.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: DomainIdProjectionSelector.Name.Atom }) } }, Metadata: { Atom: Object.freeze<lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>>({ kind: 'Metadata', value: MetadataProjectionSelector.Atom }), Key: <const T extends MetadataKeyProjectionSelector>(value: T): lib.Variant<'Metadata', lib.Variant<'Key', T>> => ({ kind: 'Metadata', value: MetadataProjectionSelector.Key(value) }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Id: [DomainIdProjectionSelector], Metadata: [MetadataProjectionSelector] }>({ Atom: [0], Id: [1, lib.getCodec(DomainIdProjectionSelector)], Metadata: [2, lib.getCodec(MetadataProjectionSelector)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface TransactionEvent { hash: lib.Hash, blockHeight: lib.Option<lib.NonZero<lib.U64>>, status: TransactionStatus }
/**
 * Codec of the structure.
 */
export const TransactionEvent: lib.CodecContainer<TransactionEvent> = lib.defineCodec(lib.structCodec<TransactionEvent>(['hash', 'blockHeight', 'status'], {hash: lib.getCodec(lib.Hash), blockHeight: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U64))), status: lib.getCodec(TransactionStatus)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Transaction`
 * - `Block`
 * 
 * TODO how to construct, how to use
 */
export type PipelineEventBox = lib.Variant<'Transaction', TransactionEvent> | lib.Variant<'Block', BlockEvent>
/**
 * Codec and constructors for enumeration {@link PipelineEventBox}.
 */
export const PipelineEventBox: lib.CodecContainer<PipelineEventBox> & { Transaction: <const T extends TransactionEvent>(value: T) => lib.Variant<'Transaction', T>, Block: <const T extends BlockEvent>(value: T) => lib.Variant<'Block', T> } = { ...{ Transaction: <const T extends TransactionEvent>(value: T): lib.Variant<'Transaction', T> => ({ kind: 'Transaction', value }), Block: <const T extends BlockEvent>(value: T): lib.Variant<'Block', T> => ({ kind: 'Block', value }) }, ...lib.defineCodec(lib.enumCodec<{ Transaction: [TransactionEvent], Block: [BlockEvent] }>({ Transaction: [0, lib.getCodec(TransactionEvent)], Block: [1, lib.getCodec(BlockEvent)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface TimeInterval { since: lib.Timestamp, length: lib.Duration }
/**
 * Codec of the structure.
 */
export const TimeInterval: lib.CodecContainer<TimeInterval> = lib.defineCodec(lib.structCodec<TimeInterval>(['since', 'length'], {since: lib.getCodec(lib.Timestamp), length: lib.getCodec(lib.Duration)}))

/**
 * Structure with named fields.
 */
export interface TimeEvent { interval: TimeInterval }
/**
 * Codec of the structure.
 */
export const TimeEvent: lib.CodecContainer<TimeEvent> = lib.defineCodec(lib.structCodec<TimeEvent>(['interval'], {interval: lib.getCodec(TimeInterval)}))

/**
 * Structure with named fields.
 */
export interface ExecuteTriggerEvent { triggerId: TriggerId, authority: lib.AccountId, args: lib.Json }
/**
 * Codec of the structure.
 */
export const ExecuteTriggerEvent: lib.CodecContainer<ExecuteTriggerEvent> = lib.defineCodec(lib.structCodec<ExecuteTriggerEvent>(['triggerId', 'authority', 'args'], {triggerId: lib.getCodec(TriggerId), authority: lib.getCodec(lib.AccountId), args: lib.getCodec(lib.Json)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Success`
 * - `Failure`
 * 
 * TODO how to construct, how to use
 */
export type TriggerCompletedOutcome = lib.VariantUnit<'Success'> | lib.Variant<'Failure', lib.String>
/**
 * Codec and constructors for enumeration {@link TriggerCompletedOutcome}.
 */
export const TriggerCompletedOutcome: lib.CodecContainer<TriggerCompletedOutcome> & { Success: lib.VariantUnit<'Success'>, Failure: <const T extends lib.String>(value: T) => lib.Variant<'Failure', T> } = { ...{ Success: Object.freeze({ kind: 'Success' }), Failure: <const T extends lib.String>(value: T): lib.Variant<'Failure', T> => ({ kind: 'Failure', value }) }, ...lib.defineCodec(lib.enumCodec<{ Success: [], Failure: [lib.String] }>({ Success: [0], Failure: [1, lib.getCodec(lib.String)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface TriggerCompletedEvent { triggerId: TriggerId, outcome: TriggerCompletedOutcome }
/**
 * Codec of the structure.
 */
export const TriggerCompletedEvent: lib.CodecContainer<TriggerCompletedEvent> = lib.defineCodec(lib.structCodec<TriggerCompletedEvent>(['triggerId', 'outcome'], {triggerId: lib.getCodec(TriggerId), outcome: lib.getCodec(TriggerCompletedOutcome)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Pipeline`
 * - `Data`
 * - `Time`
 * - `ExecuteTrigger`
 * - `TriggerCompleted`
 * 
 * TODO how to construct, how to use
 */
export type EventBox = lib.Variant<'Pipeline', PipelineEventBox> | lib.Variant<'Data', DataEvent> | lib.Variant<'Time', TimeEvent> | lib.Variant<'ExecuteTrigger', ExecuteTriggerEvent> | lib.Variant<'TriggerCompleted', TriggerCompletedEvent>
/**
 * Codec and constructors for enumeration {@link EventBox}.
 */
export const EventBox: lib.CodecContainer<EventBox> & { Pipeline: { Transaction: <const T extends TransactionEvent>(value: T) => lib.Variant<'Pipeline', lib.Variant<'Transaction', T>>, Block: <const T extends BlockEvent>(value: T) => lib.Variant<'Pipeline', lib.Variant<'Block', T>> }, Data: { Peer: { Added: <const T extends PeerId>(value: T) => lib.Variant<'Data', lib.Variant<'Peer', lib.Variant<'Added', T>>>, Removed: <const T extends PeerId>(value: T) => lib.Variant<'Data', lib.Variant<'Peer', lib.Variant<'Removed', T>>> }, Domain: { Created: <const T extends Domain>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Created', T>>>, Deleted: <const T extends lib.DomainId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Deleted', T>>>, AssetDefinition: { Created: <const T extends AssetDefinition>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Created', T>>>>, Deleted: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Deleted', T>>>>, MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataInserted', T>>>>, MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataRemoved', T>>>>, MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MintabilityChanged', T>>>>, TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'TotalQuantityChanged', T>>>>, OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'OwnerChanged', T>>>> }, Nft: { Created: <const T extends Nft>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Created', T>>>>, Deleted: <const T extends lib.NftId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Deleted', T>>>>, MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataInserted', T>>>>, MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataRemoved', T>>>>, OwnerChanged: <const T extends NftOwnerChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'OwnerChanged', T>>>> }, Account: { Created: <const T extends Account>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Created', T>>>>, Deleted: <const T extends lib.AccountId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Deleted', T>>>>, Asset: { Created: <const T extends Asset>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Created', T>>>>>, Deleted: <const T extends lib.AssetId>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Deleted', T>>>>>, Added: <const T extends AssetChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Added', T>>>>>, Removed: <const T extends AssetChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Removed', T>>>>> }, PermissionAdded: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionAdded', T>>>>, PermissionRemoved: <const T extends AccountPermissionChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionRemoved', T>>>>, RoleGranted: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleGranted', T>>>>, RoleRevoked: <const T extends AccountRoleChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleRevoked', T>>>>, MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataInserted', T>>>>, MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataRemoved', T>>>> }, MetadataInserted: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'MetadataInserted', T>>>, MetadataRemoved: <const T extends MetadataChanged<lib.DomainId>>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'MetadataRemoved', T>>>, OwnerChanged: <const T extends DomainOwnerChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'OwnerChanged', T>>> }, Trigger: { Created: <const T extends TriggerId>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Created', T>>>, Deleted: <const T extends TriggerId>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Deleted', T>>>, Extended: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Extended', T>>>, Shortened: <const T extends TriggerNumberOfExecutionsChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Shortened', T>>>, MetadataInserted: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'MetadataInserted', T>>>, MetadataRemoved: <const T extends MetadataChanged<TriggerId>>(value: T) => lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'MetadataRemoved', T>>> }, Role: { Created: <const T extends Role>(value: T) => lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'Created', T>>>, Deleted: <const T extends RoleId>(value: T) => lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'Deleted', T>>>, PermissionAdded: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'PermissionAdded', T>>>, PermissionRemoved: <const T extends RolePermissionChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'PermissionRemoved', T>>> }, Configuration: { Changed: <const T extends ParameterChanged>(value: T) => lib.Variant<'Data', lib.Variant<'Configuration', lib.Variant<'Changed', T>>> }, Executor: { Upgraded: <const T extends ExecutorUpgrade>(value: T) => lib.Variant<'Data', lib.Variant<'Executor', lib.Variant<'Upgraded', T>>> } }, Time: <const T extends TimeEvent>(value: T) => lib.Variant<'Time', T>, ExecuteTrigger: <const T extends ExecuteTriggerEvent>(value: T) => lib.Variant<'ExecuteTrigger', T>, TriggerCompleted: <const T extends TriggerCompletedEvent>(value: T) => lib.Variant<'TriggerCompleted', T> } = { ...{ Pipeline: { Transaction: <const T extends TransactionEvent>(value: T): lib.Variant<'Pipeline', lib.Variant<'Transaction', T>> => ({ kind: 'Pipeline', value: PipelineEventBox.Transaction(value) }), Block: <const T extends BlockEvent>(value: T): lib.Variant<'Pipeline', lib.Variant<'Block', T>> => ({ kind: 'Pipeline', value: PipelineEventBox.Block(value) }) }, Data: { Peer: { Added: <const T extends PeerId>(value: T): lib.Variant<'Data', lib.Variant<'Peer', lib.Variant<'Added', T>>> => ({ kind: 'Data', value: DataEvent.Peer.Added(value) }), Removed: <const T extends PeerId>(value: T): lib.Variant<'Data', lib.Variant<'Peer', lib.Variant<'Removed', T>>> => ({ kind: 'Data', value: DataEvent.Peer.Removed(value) }) }, Domain: { Created: <const T extends Domain>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Created', T>>> => ({ kind: 'Data', value: DataEvent.Domain.Created(value) }), Deleted: <const T extends lib.DomainId>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Deleted', T>>> => ({ kind: 'Data', value: DataEvent.Domain.Deleted(value) }), AssetDefinition: { Created: <const T extends AssetDefinition>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Created', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.AssetDefinition.Created(value) }), Deleted: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'Deleted', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.AssetDefinition.Deleted(value) }), MetadataInserted: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataInserted', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.AssetDefinition.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.AssetDefinitionId>>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MetadataRemoved', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.AssetDefinition.MetadataRemoved(value) }), MintabilityChanged: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'MintabilityChanged', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.AssetDefinition.MintabilityChanged(value) }), TotalQuantityChanged: <const T extends AssetDefinitionTotalQuantityChanged>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'TotalQuantityChanged', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.AssetDefinition.TotalQuantityChanged(value) }), OwnerChanged: <const T extends AssetDefinitionOwnerChanged>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'AssetDefinition', lib.Variant<'OwnerChanged', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.AssetDefinition.OwnerChanged(value) }) }, Nft: { Created: <const T extends Nft>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Created', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Nft.Created(value) }), Deleted: <const T extends lib.NftId>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'Deleted', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Nft.Deleted(value) }), MetadataInserted: <const T extends MetadataChanged<lib.NftId>>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataInserted', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Nft.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.NftId>>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'MetadataRemoved', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Nft.MetadataRemoved(value) }), OwnerChanged: <const T extends NftOwnerChanged>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Nft', lib.Variant<'OwnerChanged', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Nft.OwnerChanged(value) }) }, Account: { Created: <const T extends Account>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Created', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.Created(value) }), Deleted: <const T extends lib.AccountId>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Deleted', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.Deleted(value) }), Asset: { Created: <const T extends Asset>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Created', T>>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.Asset.Created(value) }), Deleted: <const T extends lib.AssetId>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Deleted', T>>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.Asset.Deleted(value) }), Added: <const T extends AssetChanged>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Added', T>>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.Asset.Added(value) }), Removed: <const T extends AssetChanged>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'Asset', lib.Variant<'Removed', T>>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.Asset.Removed(value) }) }, PermissionAdded: <const T extends AccountPermissionChanged>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionAdded', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.PermissionAdded(value) }), PermissionRemoved: <const T extends AccountPermissionChanged>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'PermissionRemoved', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.PermissionRemoved(value) }), RoleGranted: <const T extends AccountRoleChanged>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleGranted', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.RoleGranted(value) }), RoleRevoked: <const T extends AccountRoleChanged>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'RoleRevoked', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.RoleRevoked(value) }), MetadataInserted: <const T extends MetadataChanged<lib.AccountId>>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataInserted', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.AccountId>>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'Account', lib.Variant<'MetadataRemoved', T>>>> => ({ kind: 'Data', value: DataEvent.Domain.Account.MetadataRemoved(value) }) }, MetadataInserted: <const T extends MetadataChanged<lib.DomainId>>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'MetadataInserted', T>>> => ({ kind: 'Data', value: DataEvent.Domain.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<lib.DomainId>>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'MetadataRemoved', T>>> => ({ kind: 'Data', value: DataEvent.Domain.MetadataRemoved(value) }), OwnerChanged: <const T extends DomainOwnerChanged>(value: T): lib.Variant<'Data', lib.Variant<'Domain', lib.Variant<'OwnerChanged', T>>> => ({ kind: 'Data', value: DataEvent.Domain.OwnerChanged(value) }) }, Trigger: { Created: <const T extends TriggerId>(value: T): lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Created', T>>> => ({ kind: 'Data', value: DataEvent.Trigger.Created(value) }), Deleted: <const T extends TriggerId>(value: T): lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Deleted', T>>> => ({ kind: 'Data', value: DataEvent.Trigger.Deleted(value) }), Extended: <const T extends TriggerNumberOfExecutionsChanged>(value: T): lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Extended', T>>> => ({ kind: 'Data', value: DataEvent.Trigger.Extended(value) }), Shortened: <const T extends TriggerNumberOfExecutionsChanged>(value: T): lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'Shortened', T>>> => ({ kind: 'Data', value: DataEvent.Trigger.Shortened(value) }), MetadataInserted: <const T extends MetadataChanged<TriggerId>>(value: T): lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'MetadataInserted', T>>> => ({ kind: 'Data', value: DataEvent.Trigger.MetadataInserted(value) }), MetadataRemoved: <const T extends MetadataChanged<TriggerId>>(value: T): lib.Variant<'Data', lib.Variant<'Trigger', lib.Variant<'MetadataRemoved', T>>> => ({ kind: 'Data', value: DataEvent.Trigger.MetadataRemoved(value) }) }, Role: { Created: <const T extends Role>(value: T): lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'Created', T>>> => ({ kind: 'Data', value: DataEvent.Role.Created(value) }), Deleted: <const T extends RoleId>(value: T): lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'Deleted', T>>> => ({ kind: 'Data', value: DataEvent.Role.Deleted(value) }), PermissionAdded: <const T extends RolePermissionChanged>(value: T): lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'PermissionAdded', T>>> => ({ kind: 'Data', value: DataEvent.Role.PermissionAdded(value) }), PermissionRemoved: <const T extends RolePermissionChanged>(value: T): lib.Variant<'Data', lib.Variant<'Role', lib.Variant<'PermissionRemoved', T>>> => ({ kind: 'Data', value: DataEvent.Role.PermissionRemoved(value) }) }, Configuration: { Changed: <const T extends ParameterChanged>(value: T): lib.Variant<'Data', lib.Variant<'Configuration', lib.Variant<'Changed', T>>> => ({ kind: 'Data', value: DataEvent.Configuration.Changed(value) }) }, Executor: { Upgraded: <const T extends ExecutorUpgrade>(value: T): lib.Variant<'Data', lib.Variant<'Executor', lib.Variant<'Upgraded', T>>> => ({ kind: 'Data', value: DataEvent.Executor.Upgraded(value) }) } }, Time: <const T extends TimeEvent>(value: T): lib.Variant<'Time', T> => ({ kind: 'Time', value }), ExecuteTrigger: <const T extends ExecuteTriggerEvent>(value: T): lib.Variant<'ExecuteTrigger', T> => ({ kind: 'ExecuteTrigger', value }), TriggerCompleted: <const T extends TriggerCompletedEvent>(value: T): lib.Variant<'TriggerCompleted', T> => ({ kind: 'TriggerCompleted', value }) }, ...lib.defineCodec(lib.enumCodec<{ Pipeline: [PipelineEventBox], Data: [DataEvent], Time: [TimeEvent], ExecuteTrigger: [ExecuteTriggerEvent], TriggerCompleted: [TriggerCompletedEvent] }>({ Pipeline: [0, lib.getCodec(PipelineEventBox)], Data: [1, lib.getCodec(DataEvent)], Time: [2, lib.getCodec(TimeEvent)], ExecuteTrigger: [3, lib.getCodec(ExecuteTriggerEvent)], TriggerCompleted: [4, lib.getCodec(TriggerCompletedEvent)] }).discriminated()) }

export type EventMessage = EventBox
export const EventMessage = EventBox

/**
 * Structure with named fields.
 */
export interface EventSubscriptionRequest { filters: lib.Vec<EventFilterBox> }
/**
 * Codec of the structure.
 */
export const EventSubscriptionRequest: lib.CodecContainer<EventSubscriptionRequest> = lib.defineCodec(lib.structCodec<EventSubscriptionRequest>(['filters'], {filters: lib.Vec.with(lib.getCodec(EventFilterBox))}))

/**
 * Structure with named fields.
 */
export interface ExecuteTrigger { trigger: TriggerId, args: lib.Json }
/**
 * Codec of the structure.
 */
export const ExecuteTrigger: lib.CodecContainer<ExecuteTrigger> = lib.defineCodec(lib.structCodec<ExecuteTrigger>(['trigger', 'args'], {trigger: lib.getCodec(TriggerId), args: lib.getCodec(lib.Json)}))

/**
 * Structure with named fields.
 */
export interface Executor { wasm: WasmSmartContract }
/**
 * Codec of the structure.
 */
export const Executor: lib.CodecContainer<Executor> = lib.defineCodec(lib.structCodec<Executor>(['wasm'], {wasm: lib.getCodec(WasmSmartContract)}))

/**
 * Structure with named fields.
 */
export interface FindAccountsWithAsset { assetDefinition: lib.AssetDefinitionId }
/**
 * Codec of the structure.
 */
export const FindAccountsWithAsset: lib.CodecContainer<FindAccountsWithAsset> = lib.defineCodec(lib.structCodec<FindAccountsWithAsset>(['assetDefinition'], {assetDefinition: lib.getCodec(lib.AssetDefinitionId)}))

/**
 * Structure with named fields.
 */
export interface FindPermissionsByAccountId { id: lib.AccountId }
/**
 * Codec of the structure.
 */
export const FindPermissionsByAccountId: lib.CodecContainer<FindPermissionsByAccountId> = lib.defineCodec(lib.structCodec<FindPermissionsByAccountId>(['id'], {id: lib.getCodec(lib.AccountId)}))

/**
 * Structure with named fields.
 */
export interface FindRolesByAccountId { id: lib.AccountId }
/**
 * Codec of the structure.
 */
export const FindRolesByAccountId: lib.CodecContainer<FindRolesByAccountId> = lib.defineCodec(lib.structCodec<FindRolesByAccountId>(['id'], {id: lib.getCodec(lib.AccountId)}))

/**
 * Structure with named fields.
 */
export interface ForwardCursor { query: lib.String, cursor: lib.NonZero<lib.U64> }
/**
 * Codec of the structure.
 */
export const ForwardCursor: lib.CodecContainer<ForwardCursor> = lib.defineCodec(lib.structCodec<ForwardCursor>(['query', 'cursor'], {query: lib.getCodec(lib.String), cursor: lib.NonZero.with(lib.getCodec(lib.U64))}))

/**
 * Structure with named fields.
 */
export interface GenesisWasmAction { executable: lib.String, repeats: Repeats, authority: lib.AccountId, filter: EventFilterBox }
/**
 * Codec of the structure.
 */
export const GenesisWasmAction: lib.CodecContainer<GenesisWasmAction> = lib.defineCodec(lib.structCodec<GenesisWasmAction>(['executable', 'repeats', 'authority', 'filter'], {executable: lib.getCodec(lib.String), repeats: lib.getCodec(Repeats), authority: lib.getCodec(lib.AccountId), filter: lib.getCodec(EventFilterBox)}))

/**
 * Structure with named fields.
 */
export interface GenesisWasmTrigger { id: TriggerId, action: GenesisWasmAction }
/**
 * Codec of the structure.
 */
export const GenesisWasmTrigger: lib.CodecContainer<GenesisWasmTrigger> = lib.defineCodec(lib.structCodec<GenesisWasmTrigger>(['id', 'action'], {id: lib.getCodec(TriggerId), action: lib.getCodec(GenesisWasmAction)}))

/**
 * Structure with named fields and generic parameters.
 */
export interface Grant<T0, T1> { object: T0, destination: T1 }
/**
 * Codec constructor for the structure with generic parameters.
 */
export const Grant = { /**
 * Create a codec with the actual codecs for generic parameters.
 */
with: <T0, T1>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>): lib.GenCodec<Grant<T0, T1>> => lib.structCodec<Grant<T0, T1>>(['object', 'destination'], {object: t0, destination: t1}) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Permission`
 * - `Role`
 * - `RolePermission`
 * 
 * TODO how to construct, how to use
 */
export type GrantBox = lib.Variant<'Permission', Grant<Permission, lib.AccountId>> | lib.Variant<'Role', Grant<RoleId, lib.AccountId>> | lib.Variant<'RolePermission', Grant<Permission, RoleId>>
/**
 * Codec and constructors for enumeration {@link GrantBox}.
 */
export const GrantBox: lib.CodecContainer<GrantBox> & { Permission: <const T extends Grant<Permission, lib.AccountId>>(value: T) => lib.Variant<'Permission', T>, Role: <const T extends Grant<RoleId, lib.AccountId>>(value: T) => lib.Variant<'Role', T>, RolePermission: <const T extends Grant<Permission, RoleId>>(value: T) => lib.Variant<'RolePermission', T> } = { ...{ Permission: <const T extends Grant<Permission, lib.AccountId>>(value: T): lib.Variant<'Permission', T> => ({ kind: 'Permission', value }), Role: <const T extends Grant<RoleId, lib.AccountId>>(value: T): lib.Variant<'Role', T> => ({ kind: 'Role', value }), RolePermission: <const T extends Grant<Permission, RoleId>>(value: T): lib.Variant<'RolePermission', T> => ({ kind: 'RolePermission', value }) }, ...lib.defineCodec(lib.enumCodec<{ Permission: [Grant<Permission, lib.AccountId>], Role: [Grant<RoleId, lib.AccountId>], RolePermission: [Grant<Permission, RoleId>] }>({ Permission: [0, Grant.with(lib.getCodec(Permission), lib.getCodec(lib.AccountId))], Role: [1, Grant.with(lib.getCodec(RoleId), lib.getCodec(lib.AccountId))], RolePermission: [2, Grant.with(lib.getCodec(Permission), lib.getCodec(RoleId))] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface NewDomain { id: lib.DomainId, logo: lib.Option<IpfsPath>, metadata: Metadata }
/**
 * Codec of the structure.
 */
export const NewDomain: lib.CodecContainer<NewDomain> = lib.defineCodec(lib.structCodec<NewDomain>(['id', 'logo', 'metadata'], {id: lib.getCodec(lib.DomainId), logo: lib.Option.with(lib.getCodec(IpfsPath)), metadata: lib.getCodec(Metadata)}))

/**
 * Structure with named fields.
 */
export interface NewAccount { id: lib.AccountId, metadata: Metadata }
/**
 * Codec of the structure.
 */
export const NewAccount: lib.CodecContainer<NewAccount> = lib.defineCodec(lib.structCodec<NewAccount>(['id', 'metadata'], {id: lib.getCodec(lib.AccountId), metadata: lib.getCodec(Metadata)}))

/**
 * Structure with named fields.
 */
export interface NewAssetDefinition { id: lib.AssetDefinitionId, spec: NumericSpec, mintable: Mintable, logo: lib.Option<IpfsPath>, metadata: Metadata }
/**
 * Codec of the structure.
 */
export const NewAssetDefinition: lib.CodecContainer<NewAssetDefinition> = lib.defineCodec(lib.structCodec<NewAssetDefinition>(['id', 'spec', 'mintable', 'logo', 'metadata'], {id: lib.getCodec(lib.AssetDefinitionId), spec: lib.getCodec(NumericSpec), mintable: lib.getCodec(Mintable), logo: lib.Option.with(lib.getCodec(IpfsPath)), metadata: lib.getCodec(Metadata)}))

/**
 * Structure with named fields.
 */
export interface NewNft { id: lib.NftId, content: Metadata }
/**
 * Codec of the structure.
 */
export const NewNft: lib.CodecContainer<NewNft> = lib.defineCodec(lib.structCodec<NewNft>(['id', 'content'], {id: lib.getCodec(lib.NftId), content: lib.getCodec(Metadata)}))

/**
 * Structure with named fields.
 */
export interface NewRole { inner: Role, grantTo: lib.AccountId }
/**
 * Codec of the structure.
 */
export const NewRole: lib.CodecContainer<NewRole> = lib.defineCodec(lib.structCodec<NewRole>(['inner', 'grantTo'], {inner: lib.getCodec(Role), grantTo: lib.getCodec(lib.AccountId)}))

/**
 * Structure with named fields.
 */
export interface Trigger { id: TriggerId, action: Action }
/**
 * Codec of the structure.
 */
export const Trigger: lib.CodecContainer<Trigger> = lib.defineCodec(lib.structCodec<Trigger>(['id', 'action'], {id: lib.getCodec(TriggerId), action: lib.getCodec(Action)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Peer`
 * - `Domain`
 * - `Account`
 * - `AssetDefinition`
 * - `Nft`
 * - `Role`
 * - `Trigger`
 * 
 * TODO how to construct, how to use
 */
export type RegisterBox = lib.Variant<'Peer', PeerId> | lib.Variant<'Domain', NewDomain> | lib.Variant<'Account', NewAccount> | lib.Variant<'AssetDefinition', NewAssetDefinition> | lib.Variant<'Nft', NewNft> | lib.Variant<'Role', NewRole> | lib.Variant<'Trigger', Trigger>
/**
 * Codec and constructors for enumeration {@link RegisterBox}.
 */
export const RegisterBox: lib.CodecContainer<RegisterBox> & { Peer: <const T extends PeerId>(value: T) => lib.Variant<'Peer', T>, Domain: <const T extends NewDomain>(value: T) => lib.Variant<'Domain', T>, Account: <const T extends NewAccount>(value: T) => lib.Variant<'Account', T>, AssetDefinition: <const T extends NewAssetDefinition>(value: T) => lib.Variant<'AssetDefinition', T>, Nft: <const T extends NewNft>(value: T) => lib.Variant<'Nft', T>, Role: <const T extends NewRole>(value: T) => lib.Variant<'Role', T>, Trigger: <const T extends Trigger>(value: T) => lib.Variant<'Trigger', T> } = { ...{ Peer: <const T extends PeerId>(value: T): lib.Variant<'Peer', T> => ({ kind: 'Peer', value }), Domain: <const T extends NewDomain>(value: T): lib.Variant<'Domain', T> => ({ kind: 'Domain', value }), Account: <const T extends NewAccount>(value: T): lib.Variant<'Account', T> => ({ kind: 'Account', value }), AssetDefinition: <const T extends NewAssetDefinition>(value: T): lib.Variant<'AssetDefinition', T> => ({ kind: 'AssetDefinition', value }), Nft: <const T extends NewNft>(value: T): lib.Variant<'Nft', T> => ({ kind: 'Nft', value }), Role: <const T extends NewRole>(value: T): lib.Variant<'Role', T> => ({ kind: 'Role', value }), Trigger: <const T extends Trigger>(value: T): lib.Variant<'Trigger', T> => ({ kind: 'Trigger', value }) }, ...lib.defineCodec(lib.enumCodec<{ Peer: [PeerId], Domain: [NewDomain], Account: [NewAccount], AssetDefinition: [NewAssetDefinition], Nft: [NewNft], Role: [NewRole], Trigger: [Trigger] }>({ Peer: [0, lib.getCodec(PeerId)], Domain: [1, lib.getCodec(NewDomain)], Account: [2, lib.getCodec(NewAccount)], AssetDefinition: [3, lib.getCodec(NewAssetDefinition)], Nft: [4, lib.getCodec(NewNft)], Role: [5, lib.getCodec(NewRole)], Trigger: [6, lib.getCodec(Trigger)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Peer`
 * - `Domain`
 * - `Account`
 * - `AssetDefinition`
 * - `Nft`
 * - `Role`
 * - `Trigger`
 * 
 * TODO how to construct, how to use
 */
export type UnregisterBox = lib.Variant<'Peer', PeerId> | lib.Variant<'Domain', lib.DomainId> | lib.Variant<'Account', lib.AccountId> | lib.Variant<'AssetDefinition', lib.AssetDefinitionId> | lib.Variant<'Nft', lib.NftId> | lib.Variant<'Role', RoleId> | lib.Variant<'Trigger', TriggerId>
/**
 * Codec and constructors for enumeration {@link UnregisterBox}.
 */
export const UnregisterBox: lib.CodecContainer<UnregisterBox> & { Peer: <const T extends PeerId>(value: T) => lib.Variant<'Peer', T>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Domain', T>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Account', T>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'AssetDefinition', T>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Nft', T>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Role', T>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Trigger', T> } = { ...{ Peer: <const T extends PeerId>(value: T): lib.Variant<'Peer', T> => ({ kind: 'Peer', value }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Domain', T> => ({ kind: 'Domain', value }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Account', T> => ({ kind: 'Account', value }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'AssetDefinition', T> => ({ kind: 'AssetDefinition', value }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Nft', T> => ({ kind: 'Nft', value }), Role: <const T extends RoleId>(value: T): lib.Variant<'Role', T> => ({ kind: 'Role', value }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Trigger', T> => ({ kind: 'Trigger', value }) }, ...lib.defineCodec(lib.enumCodec<{ Peer: [PeerId], Domain: [lib.DomainId], Account: [lib.AccountId], AssetDefinition: [lib.AssetDefinitionId], Nft: [lib.NftId], Role: [RoleId], Trigger: [TriggerId] }>({ Peer: [0, lib.getCodec(PeerId)], Domain: [1, lib.getCodec(lib.DomainId)], Account: [2, lib.getCodec(lib.AccountId)], AssetDefinition: [3, lib.getCodec(lib.AssetDefinitionId)], Nft: [4, lib.getCodec(lib.NftId)], Role: [5, lib.getCodec(RoleId)], Trigger: [6, lib.getCodec(TriggerId)] }).discriminated()) }

/**
 * Structure with named fields and generic parameters.
 */
export interface Mint<T0, T1> { object: T0, destination: T1 }
/**
 * Codec constructor for the structure with generic parameters.
 */
export const Mint = { /**
 * Create a codec with the actual codecs for generic parameters.
 */
with: <T0, T1>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>): lib.GenCodec<Mint<T0, T1>> => lib.structCodec<Mint<T0, T1>>(['object', 'destination'], {object: t0, destination: t1}) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Asset`
 * - `TriggerRepetitions`
 * 
 * TODO how to construct, how to use
 */
export type MintBox = lib.Variant<'Asset', Mint<Numeric, lib.AssetId>> | lib.Variant<'TriggerRepetitions', Mint<lib.U32, TriggerId>>
/**
 * Codec and constructors for enumeration {@link MintBox}.
 */
export const MintBox: lib.CodecContainer<MintBox> & { Asset: <const T extends Mint<Numeric, lib.AssetId>>(value: T) => lib.Variant<'Asset', T>, TriggerRepetitions: <const T extends Mint<lib.U32, TriggerId>>(value: T) => lib.Variant<'TriggerRepetitions', T> } = { ...{ Asset: <const T extends Mint<Numeric, lib.AssetId>>(value: T): lib.Variant<'Asset', T> => ({ kind: 'Asset', value }), TriggerRepetitions: <const T extends Mint<lib.U32, TriggerId>>(value: T): lib.Variant<'TriggerRepetitions', T> => ({ kind: 'TriggerRepetitions', value }) }, ...lib.defineCodec(lib.enumCodec<{ Asset: [Mint<Numeric, lib.AssetId>], TriggerRepetitions: [Mint<lib.U32, TriggerId>] }>({ Asset: [0, Mint.with(lib.getCodec(Numeric), lib.getCodec(lib.AssetId))], TriggerRepetitions: [1, Mint.with(lib.getCodec(lib.U32), lib.getCodec(TriggerId))] }).discriminated()) }

/**
 * Structure with named fields and generic parameters.
 */
export interface Transfer<T0, T1, T2> { source: T0, object: T1, destination: T2 }
/**
 * Codec constructor for the structure with generic parameters.
 */
export const Transfer = { /**
 * Create a codec with the actual codecs for generic parameters.
 */
with: <T0, T1, T2>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>, t2: lib.GenCodec<T2>): lib.GenCodec<Transfer<T0, T1, T2>> => lib.structCodec<Transfer<T0, T1, T2>>(['source', 'object', 'destination'], {source: t0, object: t1, destination: t2}) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Domain`
 * - `AssetDefinition`
 * - `Asset`
 * - `Nft`
 * 
 * TODO how to construct, how to use
 */
export type TransferBox = lib.Variant<'Domain', Transfer<lib.AccountId, lib.DomainId, lib.AccountId>> | lib.Variant<'AssetDefinition', Transfer<lib.AccountId, lib.AssetDefinitionId, lib.AccountId>> | lib.Variant<'Asset', Transfer<lib.AssetId, Numeric, lib.AccountId>> | lib.Variant<'Nft', Transfer<lib.AccountId, lib.NftId, lib.AccountId>>
/**
 * Codec and constructors for enumeration {@link TransferBox}.
 */
export const TransferBox: lib.CodecContainer<TransferBox> & { Domain: <const T extends Transfer<lib.AccountId, lib.DomainId, lib.AccountId>>(value: T) => lib.Variant<'Domain', T>, AssetDefinition: <const T extends Transfer<lib.AccountId, lib.AssetDefinitionId, lib.AccountId>>(value: T) => lib.Variant<'AssetDefinition', T>, Asset: <const T extends Transfer<lib.AssetId, Numeric, lib.AccountId>>(value: T) => lib.Variant<'Asset', T>, Nft: <const T extends Transfer<lib.AccountId, lib.NftId, lib.AccountId>>(value: T) => lib.Variant<'Nft', T> } = { ...{ Domain: <const T extends Transfer<lib.AccountId, lib.DomainId, lib.AccountId>>(value: T): lib.Variant<'Domain', T> => ({ kind: 'Domain', value }), AssetDefinition: <const T extends Transfer<lib.AccountId, lib.AssetDefinitionId, lib.AccountId>>(value: T): lib.Variant<'AssetDefinition', T> => ({ kind: 'AssetDefinition', value }), Asset: <const T extends Transfer<lib.AssetId, Numeric, lib.AccountId>>(value: T): lib.Variant<'Asset', T> => ({ kind: 'Asset', value }), Nft: <const T extends Transfer<lib.AccountId, lib.NftId, lib.AccountId>>(value: T): lib.Variant<'Nft', T> => ({ kind: 'Nft', value }) }, ...lib.defineCodec(lib.enumCodec<{ Domain: [Transfer<lib.AccountId, lib.DomainId, lib.AccountId>], AssetDefinition: [Transfer<lib.AccountId, lib.AssetDefinitionId, lib.AccountId>], Asset: [Transfer<lib.AssetId, Numeric, lib.AccountId>], Nft: [Transfer<lib.AccountId, lib.NftId, lib.AccountId>] }>({ Domain: [0, Transfer.with(lib.getCodec(lib.AccountId), lib.getCodec(lib.DomainId), lib.getCodec(lib.AccountId))], AssetDefinition: [1, Transfer.with(lib.getCodec(lib.AccountId), lib.getCodec(lib.AssetDefinitionId), lib.getCodec(lib.AccountId))], Asset: [2, Transfer.with(lib.getCodec(lib.AssetId), lib.getCodec(Numeric), lib.getCodec(lib.AccountId))], Nft: [3, Transfer.with(lib.getCodec(lib.AccountId), lib.getCodec(lib.NftId), lib.getCodec(lib.AccountId))] }).discriminated()) }

/**
 * Structure with named fields and generic parameters.
 */
export interface SetKeyValue<T0> { object: T0, key: lib.Name, value: lib.Json }
/**
 * Codec constructor for the structure with generic parameters.
 */
export const SetKeyValue = { /**
 * Create a codec with the actual codecs for generic parameters.
 */
with: <T0>(t0: lib.GenCodec<T0>): lib.GenCodec<SetKeyValue<T0>> => lib.structCodec<SetKeyValue<T0>>(['object', 'key', 'value'], {object: t0, key: lib.getCodec(lib.Name), value: lib.getCodec(lib.Json)}) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Domain`
 * - `Account`
 * - `AssetDefinition`
 * - `Nft`
 * - `Trigger`
 * 
 * TODO how to construct, how to use
 */
export type SetKeyValueBox = lib.Variant<'Domain', SetKeyValue<lib.DomainId>> | lib.Variant<'Account', SetKeyValue<lib.AccountId>> | lib.Variant<'AssetDefinition', SetKeyValue<lib.AssetDefinitionId>> | lib.Variant<'Nft', SetKeyValue<lib.NftId>> | lib.Variant<'Trigger', SetKeyValue<TriggerId>>
/**
 * Codec and constructors for enumeration {@link SetKeyValueBox}.
 */
export const SetKeyValueBox: lib.CodecContainer<SetKeyValueBox> & { Domain: <const T extends SetKeyValue<lib.DomainId>>(value: T) => lib.Variant<'Domain', T>, Account: <const T extends SetKeyValue<lib.AccountId>>(value: T) => lib.Variant<'Account', T>, AssetDefinition: <const T extends SetKeyValue<lib.AssetDefinitionId>>(value: T) => lib.Variant<'AssetDefinition', T>, Nft: <const T extends SetKeyValue<lib.NftId>>(value: T) => lib.Variant<'Nft', T>, Trigger: <const T extends SetKeyValue<TriggerId>>(value: T) => lib.Variant<'Trigger', T> } = { ...{ Domain: <const T extends SetKeyValue<lib.DomainId>>(value: T): lib.Variant<'Domain', T> => ({ kind: 'Domain', value }), Account: <const T extends SetKeyValue<lib.AccountId>>(value: T): lib.Variant<'Account', T> => ({ kind: 'Account', value }), AssetDefinition: <const T extends SetKeyValue<lib.AssetDefinitionId>>(value: T): lib.Variant<'AssetDefinition', T> => ({ kind: 'AssetDefinition', value }), Nft: <const T extends SetKeyValue<lib.NftId>>(value: T): lib.Variant<'Nft', T> => ({ kind: 'Nft', value }), Trigger: <const T extends SetKeyValue<TriggerId>>(value: T): lib.Variant<'Trigger', T> => ({ kind: 'Trigger', value }) }, ...lib.defineCodec(lib.enumCodec<{ Domain: [SetKeyValue<lib.DomainId>], Account: [SetKeyValue<lib.AccountId>], AssetDefinition: [SetKeyValue<lib.AssetDefinitionId>], Nft: [SetKeyValue<lib.NftId>], Trigger: [SetKeyValue<TriggerId>] }>({ Domain: [0, SetKeyValue.with(lib.getCodec(lib.DomainId))], Account: [1, SetKeyValue.with(lib.getCodec(lib.AccountId))], AssetDefinition: [2, SetKeyValue.with(lib.getCodec(lib.AssetDefinitionId))], Nft: [3, SetKeyValue.with(lib.getCodec(lib.NftId))], Trigger: [4, SetKeyValue.with(lib.getCodec(TriggerId))] }).discriminated()) }

/**
 * Structure with named fields and generic parameters.
 */
export interface RemoveKeyValue<T0> { object: T0, key: lib.Name }
/**
 * Codec constructor for the structure with generic parameters.
 */
export const RemoveKeyValue = { /**
 * Create a codec with the actual codecs for generic parameters.
 */
with: <T0>(t0: lib.GenCodec<T0>): lib.GenCodec<RemoveKeyValue<T0>> => lib.structCodec<RemoveKeyValue<T0>>(['object', 'key'], {object: t0, key: lib.getCodec(lib.Name)}) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Domain`
 * - `Account`
 * - `AssetDefinition`
 * - `Nft`
 * - `Trigger`
 * 
 * TODO how to construct, how to use
 */
export type RemoveKeyValueBox = lib.Variant<'Domain', RemoveKeyValue<lib.DomainId>> | lib.Variant<'Account', RemoveKeyValue<lib.AccountId>> | lib.Variant<'AssetDefinition', RemoveKeyValue<lib.AssetDefinitionId>> | lib.Variant<'Nft', RemoveKeyValue<lib.NftId>> | lib.Variant<'Trigger', RemoveKeyValue<TriggerId>>
/**
 * Codec and constructors for enumeration {@link RemoveKeyValueBox}.
 */
export const RemoveKeyValueBox: lib.CodecContainer<RemoveKeyValueBox> & { Domain: <const T extends RemoveKeyValue<lib.DomainId>>(value: T) => lib.Variant<'Domain', T>, Account: <const T extends RemoveKeyValue<lib.AccountId>>(value: T) => lib.Variant<'Account', T>, AssetDefinition: <const T extends RemoveKeyValue<lib.AssetDefinitionId>>(value: T) => lib.Variant<'AssetDefinition', T>, Nft: <const T extends RemoveKeyValue<lib.NftId>>(value: T) => lib.Variant<'Nft', T>, Trigger: <const T extends RemoveKeyValue<TriggerId>>(value: T) => lib.Variant<'Trigger', T> } = { ...{ Domain: <const T extends RemoveKeyValue<lib.DomainId>>(value: T): lib.Variant<'Domain', T> => ({ kind: 'Domain', value }), Account: <const T extends RemoveKeyValue<lib.AccountId>>(value: T): lib.Variant<'Account', T> => ({ kind: 'Account', value }), AssetDefinition: <const T extends RemoveKeyValue<lib.AssetDefinitionId>>(value: T): lib.Variant<'AssetDefinition', T> => ({ kind: 'AssetDefinition', value }), Nft: <const T extends RemoveKeyValue<lib.NftId>>(value: T): lib.Variant<'Nft', T> => ({ kind: 'Nft', value }), Trigger: <const T extends RemoveKeyValue<TriggerId>>(value: T): lib.Variant<'Trigger', T> => ({ kind: 'Trigger', value }) }, ...lib.defineCodec(lib.enumCodec<{ Domain: [RemoveKeyValue<lib.DomainId>], Account: [RemoveKeyValue<lib.AccountId>], AssetDefinition: [RemoveKeyValue<lib.AssetDefinitionId>], Nft: [RemoveKeyValue<lib.NftId>], Trigger: [RemoveKeyValue<TriggerId>] }>({ Domain: [0, RemoveKeyValue.with(lib.getCodec(lib.DomainId))], Account: [1, RemoveKeyValue.with(lib.getCodec(lib.AccountId))], AssetDefinition: [2, RemoveKeyValue.with(lib.getCodec(lib.AssetDefinitionId))], Nft: [3, RemoveKeyValue.with(lib.getCodec(lib.NftId))], Trigger: [4, RemoveKeyValue.with(lib.getCodec(TriggerId))] }).discriminated()) }

/**
 * Structure with named fields and generic parameters.
 */
export interface Revoke<T0, T1> { object: T0, destination: T1 }
/**
 * Codec constructor for the structure with generic parameters.
 */
export const Revoke = { /**
 * Create a codec with the actual codecs for generic parameters.
 */
with: <T0, T1>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>): lib.GenCodec<Revoke<T0, T1>> => lib.structCodec<Revoke<T0, T1>>(['object', 'destination'], {object: t0, destination: t1}) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Permission`
 * - `Role`
 * - `RolePermission`
 * 
 * TODO how to construct, how to use
 */
export type RevokeBox = lib.Variant<'Permission', Revoke<Permission, lib.AccountId>> | lib.Variant<'Role', Revoke<RoleId, lib.AccountId>> | lib.Variant<'RolePermission', Revoke<Permission, RoleId>>
/**
 * Codec and constructors for enumeration {@link RevokeBox}.
 */
export const RevokeBox: lib.CodecContainer<RevokeBox> & { Permission: <const T extends Revoke<Permission, lib.AccountId>>(value: T) => lib.Variant<'Permission', T>, Role: <const T extends Revoke<RoleId, lib.AccountId>>(value: T) => lib.Variant<'Role', T>, RolePermission: <const T extends Revoke<Permission, RoleId>>(value: T) => lib.Variant<'RolePermission', T> } = { ...{ Permission: <const T extends Revoke<Permission, lib.AccountId>>(value: T): lib.Variant<'Permission', T> => ({ kind: 'Permission', value }), Role: <const T extends Revoke<RoleId, lib.AccountId>>(value: T): lib.Variant<'Role', T> => ({ kind: 'Role', value }), RolePermission: <const T extends Revoke<Permission, RoleId>>(value: T): lib.Variant<'RolePermission', T> => ({ kind: 'RolePermission', value }) }, ...lib.defineCodec(lib.enumCodec<{ Permission: [Revoke<Permission, lib.AccountId>], Role: [Revoke<RoleId, lib.AccountId>], RolePermission: [Revoke<Permission, RoleId>] }>({ Permission: [0, Revoke.with(lib.getCodec(Permission), lib.getCodec(lib.AccountId))], Role: [1, Revoke.with(lib.getCodec(RoleId), lib.getCodec(lib.AccountId))], RolePermission: [2, Revoke.with(lib.getCodec(Permission), lib.getCodec(RoleId))] }).discriminated()) }

export type SetParameter = Parameter
export const SetParameter = Parameter

/**
 * Structure with named fields.
 */
export interface Upgrade { executor: Executor }
/**
 * Codec of the structure.
 */
export const Upgrade: lib.CodecContainer<Upgrade> = lib.defineCodec(lib.structCodec<Upgrade>(['executor'], {executor: lib.getCodec(Executor)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `TRACE`
 * - `DEBUG`
 * - `INFO`
 * - `WARN`
 * - `ERROR`
 * 
 * TODO how to construct, how to use
 */
export type Level = lib.VariantUnit<'TRACE'> | lib.VariantUnit<'DEBUG'> | lib.VariantUnit<'INFO'> | lib.VariantUnit<'WARN'> | lib.VariantUnit<'ERROR'>
/**
 * Codec and constructors for enumeration {@link Level}.
 */
export const Level: lib.CodecContainer<Level> & { TRACE: lib.VariantUnit<'TRACE'>, DEBUG: lib.VariantUnit<'DEBUG'>, INFO: lib.VariantUnit<'INFO'>, WARN: lib.VariantUnit<'WARN'>, ERROR: lib.VariantUnit<'ERROR'> } = { ...{ TRACE: Object.freeze({ kind: 'TRACE' }), DEBUG: Object.freeze({ kind: 'DEBUG' }), INFO: Object.freeze({ kind: 'INFO' }), WARN: Object.freeze({ kind: 'WARN' }), ERROR: Object.freeze({ kind: 'ERROR' }) }, ...lib.defineCodec(lib.enumCodec<{ TRACE: [], DEBUG: [], INFO: [], WARN: [], ERROR: [] }>({ TRACE: [0], DEBUG: [1], INFO: [2], WARN: [3], ERROR: [4] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface Log { level: Level, msg: lib.String }
/**
 * Codec of the structure.
 */
export const Log: lib.CodecContainer<Log> = lib.defineCodec(lib.structCodec<Log>(['level', 'msg'], {level: lib.getCodec(Level), msg: lib.getCodec(lib.String)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Register`
 * - `Unregister`
 * - `Mint`
 * - `Burn`
 * - `Transfer`
 * - `SetKeyValue`
 * - `RemoveKeyValue`
 * - `Grant`
 * - `Revoke`
 * - `ExecuteTrigger`
 * - `SetParameter`
 * - `Upgrade`
 * - `Log`
 * - `Custom`
 * 
 * TODO how to construct, how to use
 */
export type InstructionBox = lib.Variant<'Register', RegisterBox> | lib.Variant<'Unregister', UnregisterBox> | lib.Variant<'Mint', MintBox> | lib.Variant<'Burn', BurnBox> | lib.Variant<'Transfer', TransferBox> | lib.Variant<'SetKeyValue', SetKeyValueBox> | lib.Variant<'RemoveKeyValue', RemoveKeyValueBox> | lib.Variant<'Grant', GrantBox> | lib.Variant<'Revoke', RevokeBox> | lib.Variant<'ExecuteTrigger', ExecuteTrigger> | lib.Variant<'SetParameter', SetParameter> | lib.Variant<'Upgrade', Upgrade> | lib.Variant<'Log', Log> | lib.Variant<'Custom', CustomInstruction>
/**
 * Codec and constructors for enumeration {@link InstructionBox}.
 */
export const InstructionBox: lib.CodecContainer<InstructionBox> & { Register: { Peer: <const T extends PeerId>(value: T) => lib.Variant<'Register', lib.Variant<'Peer', T>>, Domain: <const T extends NewDomain>(value: T) => lib.Variant<'Register', lib.Variant<'Domain', T>>, Account: <const T extends NewAccount>(value: T) => lib.Variant<'Register', lib.Variant<'Account', T>>, AssetDefinition: <const T extends NewAssetDefinition>(value: T) => lib.Variant<'Register', lib.Variant<'AssetDefinition', T>>, Nft: <const T extends NewNft>(value: T) => lib.Variant<'Register', lib.Variant<'Nft', T>>, Role: <const T extends NewRole>(value: T) => lib.Variant<'Register', lib.Variant<'Role', T>>, Trigger: <const T extends Trigger>(value: T) => lib.Variant<'Register', lib.Variant<'Trigger', T>> }, Unregister: { Peer: <const T extends PeerId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Peer', T>>, Domain: <const T extends lib.DomainId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Domain', T>>, Account: <const T extends lib.AccountId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Account', T>>, AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T) => lib.Variant<'Unregister', lib.Variant<'AssetDefinition', T>>, Nft: <const T extends lib.NftId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Nft', T>>, Role: <const T extends RoleId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Role', T>>, Trigger: <const T extends TriggerId>(value: T) => lib.Variant<'Unregister', lib.Variant<'Trigger', T>> }, Mint: { Asset: <const T extends Mint<Numeric, lib.AssetId>>(value: T) => lib.Variant<'Mint', lib.Variant<'Asset', T>>, TriggerRepetitions: <const T extends Mint<lib.U32, TriggerId>>(value: T) => lib.Variant<'Mint', lib.Variant<'TriggerRepetitions', T>> }, Burn: { Asset: <const T extends Burn<Numeric, lib.AssetId>>(value: T) => lib.Variant<'Burn', lib.Variant<'Asset', T>>, TriggerRepetitions: <const T extends Burn<lib.U32, TriggerId>>(value: T) => lib.Variant<'Burn', lib.Variant<'TriggerRepetitions', T>> }, Transfer: { Domain: <const T extends Transfer<lib.AccountId, lib.DomainId, lib.AccountId>>(value: T) => lib.Variant<'Transfer', lib.Variant<'Domain', T>>, AssetDefinition: <const T extends Transfer<lib.AccountId, lib.AssetDefinitionId, lib.AccountId>>(value: T) => lib.Variant<'Transfer', lib.Variant<'AssetDefinition', T>>, Asset: <const T extends Transfer<lib.AssetId, Numeric, lib.AccountId>>(value: T) => lib.Variant<'Transfer', lib.Variant<'Asset', T>>, Nft: <const T extends Transfer<lib.AccountId, lib.NftId, lib.AccountId>>(value: T) => lib.Variant<'Transfer', lib.Variant<'Nft', T>> }, SetKeyValue: { Domain: <const T extends SetKeyValue<lib.DomainId>>(value: T) => lib.Variant<'SetKeyValue', lib.Variant<'Domain', T>>, Account: <const T extends SetKeyValue<lib.AccountId>>(value: T) => lib.Variant<'SetKeyValue', lib.Variant<'Account', T>>, AssetDefinition: <const T extends SetKeyValue<lib.AssetDefinitionId>>(value: T) => lib.Variant<'SetKeyValue', lib.Variant<'AssetDefinition', T>>, Nft: <const T extends SetKeyValue<lib.NftId>>(value: T) => lib.Variant<'SetKeyValue', lib.Variant<'Nft', T>>, Trigger: <const T extends SetKeyValue<TriggerId>>(value: T) => lib.Variant<'SetKeyValue', lib.Variant<'Trigger', T>> }, RemoveKeyValue: { Domain: <const T extends RemoveKeyValue<lib.DomainId>>(value: T) => lib.Variant<'RemoveKeyValue', lib.Variant<'Domain', T>>, Account: <const T extends RemoveKeyValue<lib.AccountId>>(value: T) => lib.Variant<'RemoveKeyValue', lib.Variant<'Account', T>>, AssetDefinition: <const T extends RemoveKeyValue<lib.AssetDefinitionId>>(value: T) => lib.Variant<'RemoveKeyValue', lib.Variant<'AssetDefinition', T>>, Nft: <const T extends RemoveKeyValue<lib.NftId>>(value: T) => lib.Variant<'RemoveKeyValue', lib.Variant<'Nft', T>>, Trigger: <const T extends RemoveKeyValue<TriggerId>>(value: T) => lib.Variant<'RemoveKeyValue', lib.Variant<'Trigger', T>> }, Grant: { Permission: <const T extends Grant<Permission, lib.AccountId>>(value: T) => lib.Variant<'Grant', lib.Variant<'Permission', T>>, Role: <const T extends Grant<RoleId, lib.AccountId>>(value: T) => lib.Variant<'Grant', lib.Variant<'Role', T>>, RolePermission: <const T extends Grant<Permission, RoleId>>(value: T) => lib.Variant<'Grant', lib.Variant<'RolePermission', T>> }, Revoke: { Permission: <const T extends Revoke<Permission, lib.AccountId>>(value: T) => lib.Variant<'Revoke', lib.Variant<'Permission', T>>, Role: <const T extends Revoke<RoleId, lib.AccountId>>(value: T) => lib.Variant<'Revoke', lib.Variant<'Role', T>>, RolePermission: <const T extends Revoke<Permission, RoleId>>(value: T) => lib.Variant<'Revoke', lib.Variant<'RolePermission', T>> }, ExecuteTrigger: <const T extends ExecuteTrigger>(value: T) => lib.Variant<'ExecuteTrigger', T>, SetParameter: { Sumeragi: { BlockTime: <const T extends lib.Duration>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Sumeragi', lib.Variant<'BlockTime', T>>>, CommitTime: <const T extends lib.Duration>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Sumeragi', lib.Variant<'CommitTime', T>>>, MaxClockDrift: <const T extends lib.Duration>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Sumeragi', lib.Variant<'MaxClockDrift', T>>> }, Block: { MaxTransactions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Block', lib.Variant<'MaxTransactions', T>>> }, Transaction: { MaxInstructions: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Transaction', lib.Variant<'MaxInstructions', T>>>, SmartContractSize: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Transaction', lib.Variant<'SmartContractSize', T>>> }, SmartContract: { Fuel: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'SmartContract', lib.Variant<'Fuel', T>>>, Memory: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'SmartContract', lib.Variant<'Memory', T>>> }, Executor: { Fuel: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Executor', lib.Variant<'Fuel', T>>>, Memory: <const T extends lib.NonZero<lib.U64>>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Executor', lib.Variant<'Memory', T>>> }, Custom: <const T extends CustomParameter>(value: T) => lib.Variant<'SetParameter', lib.Variant<'Custom', T>> }, Upgrade: <const T extends Upgrade>(value: T) => lib.Variant<'Upgrade', T>, Log: <const T extends Log>(value: T) => lib.Variant<'Log', T>, Custom: <const T extends CustomInstruction>(value: T) => lib.Variant<'Custom', T> } = { ...{ Register: { Peer: <const T extends PeerId>(value: T): lib.Variant<'Register', lib.Variant<'Peer', T>> => ({ kind: 'Register', value: RegisterBox.Peer(value) }), Domain: <const T extends NewDomain>(value: T): lib.Variant<'Register', lib.Variant<'Domain', T>> => ({ kind: 'Register', value: RegisterBox.Domain(value) }), Account: <const T extends NewAccount>(value: T): lib.Variant<'Register', lib.Variant<'Account', T>> => ({ kind: 'Register', value: RegisterBox.Account(value) }), AssetDefinition: <const T extends NewAssetDefinition>(value: T): lib.Variant<'Register', lib.Variant<'AssetDefinition', T>> => ({ kind: 'Register', value: RegisterBox.AssetDefinition(value) }), Nft: <const T extends NewNft>(value: T): lib.Variant<'Register', lib.Variant<'Nft', T>> => ({ kind: 'Register', value: RegisterBox.Nft(value) }), Role: <const T extends NewRole>(value: T): lib.Variant<'Register', lib.Variant<'Role', T>> => ({ kind: 'Register', value: RegisterBox.Role(value) }), Trigger: <const T extends Trigger>(value: T): lib.Variant<'Register', lib.Variant<'Trigger', T>> => ({ kind: 'Register', value: RegisterBox.Trigger(value) }) }, Unregister: { Peer: <const T extends PeerId>(value: T): lib.Variant<'Unregister', lib.Variant<'Peer', T>> => ({ kind: 'Unregister', value: UnregisterBox.Peer(value) }), Domain: <const T extends lib.DomainId>(value: T): lib.Variant<'Unregister', lib.Variant<'Domain', T>> => ({ kind: 'Unregister', value: UnregisterBox.Domain(value) }), Account: <const T extends lib.AccountId>(value: T): lib.Variant<'Unregister', lib.Variant<'Account', T>> => ({ kind: 'Unregister', value: UnregisterBox.Account(value) }), AssetDefinition: <const T extends lib.AssetDefinitionId>(value: T): lib.Variant<'Unregister', lib.Variant<'AssetDefinition', T>> => ({ kind: 'Unregister', value: UnregisterBox.AssetDefinition(value) }), Nft: <const T extends lib.NftId>(value: T): lib.Variant<'Unregister', lib.Variant<'Nft', T>> => ({ kind: 'Unregister', value: UnregisterBox.Nft(value) }), Role: <const T extends RoleId>(value: T): lib.Variant<'Unregister', lib.Variant<'Role', T>> => ({ kind: 'Unregister', value: UnregisterBox.Role(value) }), Trigger: <const T extends TriggerId>(value: T): lib.Variant<'Unregister', lib.Variant<'Trigger', T>> => ({ kind: 'Unregister', value: UnregisterBox.Trigger(value) }) }, Mint: { Asset: <const T extends Mint<Numeric, lib.AssetId>>(value: T): lib.Variant<'Mint', lib.Variant<'Asset', T>> => ({ kind: 'Mint', value: MintBox.Asset(value) }), TriggerRepetitions: <const T extends Mint<lib.U32, TriggerId>>(value: T): lib.Variant<'Mint', lib.Variant<'TriggerRepetitions', T>> => ({ kind: 'Mint', value: MintBox.TriggerRepetitions(value) }) }, Burn: { Asset: <const T extends Burn<Numeric, lib.AssetId>>(value: T): lib.Variant<'Burn', lib.Variant<'Asset', T>> => ({ kind: 'Burn', value: BurnBox.Asset(value) }), TriggerRepetitions: <const T extends Burn<lib.U32, TriggerId>>(value: T): lib.Variant<'Burn', lib.Variant<'TriggerRepetitions', T>> => ({ kind: 'Burn', value: BurnBox.TriggerRepetitions(value) }) }, Transfer: { Domain: <const T extends Transfer<lib.AccountId, lib.DomainId, lib.AccountId>>(value: T): lib.Variant<'Transfer', lib.Variant<'Domain', T>> => ({ kind: 'Transfer', value: TransferBox.Domain(value) }), AssetDefinition: <const T extends Transfer<lib.AccountId, lib.AssetDefinitionId, lib.AccountId>>(value: T): lib.Variant<'Transfer', lib.Variant<'AssetDefinition', T>> => ({ kind: 'Transfer', value: TransferBox.AssetDefinition(value) }), Asset: <const T extends Transfer<lib.AssetId, Numeric, lib.AccountId>>(value: T): lib.Variant<'Transfer', lib.Variant<'Asset', T>> => ({ kind: 'Transfer', value: TransferBox.Asset(value) }), Nft: <const T extends Transfer<lib.AccountId, lib.NftId, lib.AccountId>>(value: T): lib.Variant<'Transfer', lib.Variant<'Nft', T>> => ({ kind: 'Transfer', value: TransferBox.Nft(value) }) }, SetKeyValue: { Domain: <const T extends SetKeyValue<lib.DomainId>>(value: T): lib.Variant<'SetKeyValue', lib.Variant<'Domain', T>> => ({ kind: 'SetKeyValue', value: SetKeyValueBox.Domain(value) }), Account: <const T extends SetKeyValue<lib.AccountId>>(value: T): lib.Variant<'SetKeyValue', lib.Variant<'Account', T>> => ({ kind: 'SetKeyValue', value: SetKeyValueBox.Account(value) }), AssetDefinition: <const T extends SetKeyValue<lib.AssetDefinitionId>>(value: T): lib.Variant<'SetKeyValue', lib.Variant<'AssetDefinition', T>> => ({ kind: 'SetKeyValue', value: SetKeyValueBox.AssetDefinition(value) }), Nft: <const T extends SetKeyValue<lib.NftId>>(value: T): lib.Variant<'SetKeyValue', lib.Variant<'Nft', T>> => ({ kind: 'SetKeyValue', value: SetKeyValueBox.Nft(value) }), Trigger: <const T extends SetKeyValue<TriggerId>>(value: T): lib.Variant<'SetKeyValue', lib.Variant<'Trigger', T>> => ({ kind: 'SetKeyValue', value: SetKeyValueBox.Trigger(value) }) }, RemoveKeyValue: { Domain: <const T extends RemoveKeyValue<lib.DomainId>>(value: T): lib.Variant<'RemoveKeyValue', lib.Variant<'Domain', T>> => ({ kind: 'RemoveKeyValue', value: RemoveKeyValueBox.Domain(value) }), Account: <const T extends RemoveKeyValue<lib.AccountId>>(value: T): lib.Variant<'RemoveKeyValue', lib.Variant<'Account', T>> => ({ kind: 'RemoveKeyValue', value: RemoveKeyValueBox.Account(value) }), AssetDefinition: <const T extends RemoveKeyValue<lib.AssetDefinitionId>>(value: T): lib.Variant<'RemoveKeyValue', lib.Variant<'AssetDefinition', T>> => ({ kind: 'RemoveKeyValue', value: RemoveKeyValueBox.AssetDefinition(value) }), Nft: <const T extends RemoveKeyValue<lib.NftId>>(value: T): lib.Variant<'RemoveKeyValue', lib.Variant<'Nft', T>> => ({ kind: 'RemoveKeyValue', value: RemoveKeyValueBox.Nft(value) }), Trigger: <const T extends RemoveKeyValue<TriggerId>>(value: T): lib.Variant<'RemoveKeyValue', lib.Variant<'Trigger', T>> => ({ kind: 'RemoveKeyValue', value: RemoveKeyValueBox.Trigger(value) }) }, Grant: { Permission: <const T extends Grant<Permission, lib.AccountId>>(value: T): lib.Variant<'Grant', lib.Variant<'Permission', T>> => ({ kind: 'Grant', value: GrantBox.Permission(value) }), Role: <const T extends Grant<RoleId, lib.AccountId>>(value: T): lib.Variant<'Grant', lib.Variant<'Role', T>> => ({ kind: 'Grant', value: GrantBox.Role(value) }), RolePermission: <const T extends Grant<Permission, RoleId>>(value: T): lib.Variant<'Grant', lib.Variant<'RolePermission', T>> => ({ kind: 'Grant', value: GrantBox.RolePermission(value) }) }, Revoke: { Permission: <const T extends Revoke<Permission, lib.AccountId>>(value: T): lib.Variant<'Revoke', lib.Variant<'Permission', T>> => ({ kind: 'Revoke', value: RevokeBox.Permission(value) }), Role: <const T extends Revoke<RoleId, lib.AccountId>>(value: T): lib.Variant<'Revoke', lib.Variant<'Role', T>> => ({ kind: 'Revoke', value: RevokeBox.Role(value) }), RolePermission: <const T extends Revoke<Permission, RoleId>>(value: T): lib.Variant<'Revoke', lib.Variant<'RolePermission', T>> => ({ kind: 'Revoke', value: RevokeBox.RolePermission(value) }) }, ExecuteTrigger: <const T extends ExecuteTrigger>(value: T): lib.Variant<'ExecuteTrigger', T> => ({ kind: 'ExecuteTrigger', value }), SetParameter: { Sumeragi: { BlockTime: <const T extends lib.Duration>(value: T): lib.Variant<'SetParameter', lib.Variant<'Sumeragi', lib.Variant<'BlockTime', T>>> => ({ kind: 'SetParameter', value: SetParameter.Sumeragi.BlockTime(value) }), CommitTime: <const T extends lib.Duration>(value: T): lib.Variant<'SetParameter', lib.Variant<'Sumeragi', lib.Variant<'CommitTime', T>>> => ({ kind: 'SetParameter', value: SetParameter.Sumeragi.CommitTime(value) }), MaxClockDrift: <const T extends lib.Duration>(value: T): lib.Variant<'SetParameter', lib.Variant<'Sumeragi', lib.Variant<'MaxClockDrift', T>>> => ({ kind: 'SetParameter', value: SetParameter.Sumeragi.MaxClockDrift(value) }) }, Block: { MaxTransactions: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'SetParameter', lib.Variant<'Block', lib.Variant<'MaxTransactions', T>>> => ({ kind: 'SetParameter', value: SetParameter.Block.MaxTransactions(value) }) }, Transaction: { MaxInstructions: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'SetParameter', lib.Variant<'Transaction', lib.Variant<'MaxInstructions', T>>> => ({ kind: 'SetParameter', value: SetParameter.Transaction.MaxInstructions(value) }), SmartContractSize: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'SetParameter', lib.Variant<'Transaction', lib.Variant<'SmartContractSize', T>>> => ({ kind: 'SetParameter', value: SetParameter.Transaction.SmartContractSize(value) }) }, SmartContract: { Fuel: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'SetParameter', lib.Variant<'SmartContract', lib.Variant<'Fuel', T>>> => ({ kind: 'SetParameter', value: SetParameter.SmartContract.Fuel(value) }), Memory: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'SetParameter', lib.Variant<'SmartContract', lib.Variant<'Memory', T>>> => ({ kind: 'SetParameter', value: SetParameter.SmartContract.Memory(value) }) }, Executor: { Fuel: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'SetParameter', lib.Variant<'Executor', lib.Variant<'Fuel', T>>> => ({ kind: 'SetParameter', value: SetParameter.Executor.Fuel(value) }), Memory: <const T extends lib.NonZero<lib.U64>>(value: T): lib.Variant<'SetParameter', lib.Variant<'Executor', lib.Variant<'Memory', T>>> => ({ kind: 'SetParameter', value: SetParameter.Executor.Memory(value) }) }, Custom: <const T extends CustomParameter>(value: T): lib.Variant<'SetParameter', lib.Variant<'Custom', T>> => ({ kind: 'SetParameter', value: SetParameter.Custom(value) }) }, Upgrade: <const T extends Upgrade>(value: T): lib.Variant<'Upgrade', T> => ({ kind: 'Upgrade', value }), Log: <const T extends Log>(value: T): lib.Variant<'Log', T> => ({ kind: 'Log', value }), Custom: <const T extends CustomInstruction>(value: T): lib.Variant<'Custom', T> => ({ kind: 'Custom', value }) }, ...lib.defineCodec(lib.enumCodec<{ Register: [RegisterBox], Unregister: [UnregisterBox], Mint: [MintBox], Burn: [BurnBox], Transfer: [TransferBox], SetKeyValue: [SetKeyValueBox], RemoveKeyValue: [RemoveKeyValueBox], Grant: [GrantBox], Revoke: [RevokeBox], ExecuteTrigger: [ExecuteTrigger], SetParameter: [SetParameter], Upgrade: [Upgrade], Log: [Log], Custom: [CustomInstruction] }>({ Register: [0, lib.getCodec(RegisterBox)], Unregister: [1, lib.getCodec(UnregisterBox)], Mint: [2, lib.getCodec(MintBox)], Burn: [3, lib.getCodec(BurnBox)], Transfer: [4, lib.getCodec(TransferBox)], SetKeyValue: [5, lib.getCodec(SetKeyValueBox)], RemoveKeyValue: [6, lib.getCodec(RemoveKeyValueBox)], Grant: [7, lib.getCodec(GrantBox)], Revoke: [8, lib.getCodec(RevokeBox)], ExecuteTrigger: [9, lib.getCodec(ExecuteTrigger)], SetParameter: [10, lib.getCodec(SetParameter)], Upgrade: [11, lib.getCodec(Upgrade)], Log: [12, lib.getCodec(Log)], Custom: [13, lib.getCodec(CustomInstruction)] }).discriminated()) }

export type Ipv4Addr = [lib.U8, lib.U8, lib.U8, lib.U8]
export const Ipv4Addr: lib.CodecContainer<Ipv4Addr> = lib.defineCodec(lib.tupleCodec([lib.getCodec(lib.U8), lib.getCodec(lib.U8), lib.getCodec(lib.U8), lib.getCodec(lib.U8)]))

export type Ipv6Addr = [lib.U16, lib.U16, lib.U16, lib.U16, lib.U16, lib.U16, lib.U16, lib.U16]
export const Ipv6Addr: lib.CodecContainer<Ipv6Addr> = lib.defineCodec(lib.tupleCodec([lib.getCodec(lib.U16), lib.getCodec(lib.U16), lib.getCodec(lib.U16), lib.getCodec(lib.U16), lib.getCodec(lib.U16), lib.getCodec(lib.U16), lib.getCodec(lib.U16), lib.getCodec(lib.U16)]))

/**
 * Structure with named fields.
 */
export interface MultisigApprove { account: lib.AccountId, instructionsHash: lib.Hash }
/**
 * Codec of the structure.
 */
export const MultisigApprove: lib.CodecContainer<MultisigApprove> = lib.defineCodec(lib.structCodec<MultisigApprove>(['account', 'instructionsHash'], {account: lib.getCodec(lib.AccountId), instructionsHash: lib.getCodec(lib.Hash)}))

/**
 * Structure with named fields.
 */
export interface MultisigSpec { signatories: lib.BTreeMap<lib.AccountId, lib.U8>, quorum: lib.NonZero<lib.U16>, transactionTtl: lib.NonZero<lib.Duration> }
/**
 * Codec of the structure.
 */
export const MultisigSpec: lib.CodecContainer<MultisigSpec> = lib.defineCodec(lib.structCodec<MultisigSpec>(['signatories', 'quorum', 'transactionTtl'], {signatories: lib.BTreeMap.with(lib.getCodec(lib.AccountId), lib.getCodec(lib.U8)), quorum: lib.NonZero.with(lib.getCodec(lib.U16)), transactionTtl: lib.NonZero.with(lib.getCodec(lib.Duration))}))

/**
 * Structure with named fields.
 */
export interface MultisigRegister { account: lib.AccountId, spec: MultisigSpec }
/**
 * Codec of the structure.
 */
export const MultisigRegister: lib.CodecContainer<MultisigRegister> = lib.defineCodec(lib.structCodec<MultisigRegister>(['account', 'spec'], {account: lib.getCodec(lib.AccountId), spec: lib.getCodec(MultisigSpec)}))

/**
 * Structure with named fields.
 */
export interface MultisigPropose { account: lib.AccountId, instructions: lib.Vec<InstructionBox>, transactionTtl: lib.Option<lib.NonZero<lib.Duration>> }
/**
 * Codec of the structure.
 */
export const MultisigPropose: lib.CodecContainer<MultisigPropose> = lib.defineCodec(lib.structCodec<MultisigPropose>(['account', 'instructions', 'transactionTtl'], {account: lib.getCodec(lib.AccountId), instructions: lib.Vec.with(lib.lazyCodec(() => lib.getCodec(InstructionBox))), transactionTtl: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.Duration)))}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Register`
 * - `Propose`
 * - `Approve`
 * 
 * TODO how to construct, how to use
 */
export type MultisigInstructionBox = lib.Variant<'Register', MultisigRegister> | lib.Variant<'Propose', MultisigPropose> | lib.Variant<'Approve', MultisigApprove>
/**
 * Codec and constructors for enumeration {@link MultisigInstructionBox}.
 */
export const MultisigInstructionBox: lib.CodecContainer<MultisigInstructionBox> & { Register: <const T extends MultisigRegister>(value: T) => lib.Variant<'Register', T>, Propose: <const T extends MultisigPropose>(value: T) => lib.Variant<'Propose', T>, Approve: <const T extends MultisigApprove>(value: T) => lib.Variant<'Approve', T> } = { ...{ Register: <const T extends MultisigRegister>(value: T): lib.Variant<'Register', T> => ({ kind: 'Register', value }), Propose: <const T extends MultisigPropose>(value: T): lib.Variant<'Propose', T> => ({ kind: 'Propose', value }), Approve: <const T extends MultisigApprove>(value: T): lib.Variant<'Approve', T> => ({ kind: 'Approve', value }) }, ...lib.defineCodec(lib.enumCodec<{ Register: [MultisigRegister], Propose: [MultisigPropose], Approve: [MultisigApprove] }>({ Register: [0, lib.getCodec(MultisigRegister)], Propose: [1, lib.getCodec(MultisigPropose)], Approve: [2, lib.getCodec(MultisigApprove)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface MultisigProposalValue { instructions: lib.Vec<InstructionBox>, proposedAt: lib.Timestamp, expiresAt: lib.Timestamp, approvals: lib.BTreeSet<lib.AccountId>, isRelayed: lib.Option<lib.Bool> }
/**
 * Codec of the structure.
 */
export const MultisigProposalValue: lib.CodecContainer<MultisigProposalValue> = lib.defineCodec(lib.structCodec<MultisigProposalValue>(['instructions', 'proposedAt', 'expiresAt', 'approvals', 'isRelayed'], {instructions: lib.Vec.with(lib.lazyCodec(() => lib.getCodec(InstructionBox))), proposedAt: lib.getCodec(lib.Timestamp), expiresAt: lib.getCodec(lib.Timestamp), approvals: lib.BTreeSet.with(lib.getCodec(lib.AccountId)), isRelayed: lib.Option.with(lib.getCodec(lib.Bool))}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Domain`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */
export type NftIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Domain', DomainIdProjectionSelector> | lib.Variant<'Name', NameProjectionSelector>
/**
 * Codec and constructors for enumeration {@link NftIdProjectionSelector}.
 */
export const NftIdProjectionSelector: lib.CodecContainer<NftIdProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Domain: { Atom: lib.Variant<'Domain', lib.VariantUnit<'Atom'>>, Name: { Atom: lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>> } }, Name: { Atom: lib.Variant<'Name', lib.VariantUnit<'Atom'>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Domain: { Atom: Object.freeze<lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>({ kind: 'Domain', value: DomainIdProjectionSelector.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>({ kind: 'Domain', value: DomainIdProjectionSelector.Name.Atom }) } }, Name: { Atom: Object.freeze<lib.Variant<'Name', lib.VariantUnit<'Atom'>>>({ kind: 'Name', value: NameProjectionSelector.Atom }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Domain: [DomainIdProjectionSelector], Name: [NameProjectionSelector] }>({ Atom: [0], Domain: [1, lib.getCodec(DomainIdProjectionSelector)], Name: [2, lib.getCodec(NameProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Metadata`
 * - `AccountId`
 * 
 * TODO how to construct, how to use
 */
export type NftProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', NftIdProjectionSelector> | lib.Variant<'Metadata', MetadataProjectionSelector> | lib.Variant<'AccountId', AccountIdProjectionSelector>
/**
 * Codec and constructors for enumeration {@link NftProjectionSelector}.
 */
export const NftProjectionSelector: lib.CodecContainer<NftProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Id: { Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>, Domain: { Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>, Name: { Atom: lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>> } }, Name: { Atom: lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>> } }, Metadata: { Atom: lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>, Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Metadata', lib.Variant<'Key', T>> }, AccountId: { Atom: lib.Variant<'AccountId', lib.VariantUnit<'Atom'>>, Domain: { Atom: lib.Variant<'AccountId', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>, Name: { Atom: lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>> } }, Signatory: { Atom: lib.Variant<'AccountId', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>> } } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Id: { Atom: Object.freeze<lib.Variant<'Id', lib.VariantUnit<'Atom'>>>({ kind: 'Id', value: NftIdProjectionSelector.Atom }), Domain: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: NftIdProjectionSelector.Domain.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>({ kind: 'Id', value: NftIdProjectionSelector.Domain.Name.Atom }) } }, Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: NftIdProjectionSelector.Name.Atom }) } }, Metadata: { Atom: Object.freeze<lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>>({ kind: 'Metadata', value: MetadataProjectionSelector.Atom }), Key: <const T extends MetadataKeyProjectionSelector>(value: T): lib.Variant<'Metadata', lib.Variant<'Key', T>> => ({ kind: 'Metadata', value: MetadataProjectionSelector.Key(value) }) }, AccountId: { Atom: Object.freeze<lib.Variant<'AccountId', lib.VariantUnit<'Atom'>>>({ kind: 'AccountId', value: AccountIdProjectionSelector.Atom }), Domain: { Atom: Object.freeze<lib.Variant<'AccountId', lib.Variant<'Domain', lib.VariantUnit<'Atom'>>>>({ kind: 'AccountId', value: AccountIdProjectionSelector.Domain.Atom }), Name: { Atom: Object.freeze<lib.Variant<'AccountId', lib.Variant<'Domain', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>>({ kind: 'AccountId', value: AccountIdProjectionSelector.Domain.Name.Atom }) } }, Signatory: { Atom: Object.freeze<lib.Variant<'AccountId', lib.Variant<'Signatory', lib.VariantUnit<'Atom'>>>>({ kind: 'AccountId', value: AccountIdProjectionSelector.Signatory.Atom }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Id: [NftIdProjectionSelector], Metadata: [MetadataProjectionSelector], AccountId: [AccountIdProjectionSelector] }>({ Atom: [0], Id: [1, lib.getCodec(NftIdProjectionSelector)], Metadata: [2, lib.getCodec(MetadataProjectionSelector)], AccountId: [3, lib.getCodec(AccountIdProjectionSelector)] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type NumericPredicateAtom = never
/**
 * Codec for {@link NumericPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const NumericPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Structure with named fields.
 */
export interface SumeragiParameters { blockTime: lib.Duration, commitTime: lib.Duration, maxClockDrift: lib.Duration }
/**
 * Codec of the structure.
 */
export const SumeragiParameters: lib.CodecContainer<SumeragiParameters> = lib.defineCodec(lib.structCodec<SumeragiParameters>(['blockTime', 'commitTime', 'maxClockDrift'], {blockTime: lib.getCodec(lib.Duration), commitTime: lib.getCodec(lib.Duration), maxClockDrift: lib.getCodec(lib.Duration)}))

/**
 * Structure with named fields.
 */
export interface TransactionParameters { maxInstructions: lib.NonZero<lib.U64>, smartContractSize: lib.NonZero<lib.U64> }
/**
 * Codec of the structure.
 */
export const TransactionParameters: lib.CodecContainer<TransactionParameters> = lib.defineCodec(lib.structCodec<TransactionParameters>(['maxInstructions', 'smartContractSize'], {maxInstructions: lib.NonZero.with(lib.getCodec(lib.U64)), smartContractSize: lib.NonZero.with(lib.getCodec(lib.U64))}))

/**
 * Structure with named fields.
 */
export interface SmartContractParameters { fuel: lib.NonZero<lib.U64>, memory: lib.NonZero<lib.U64> }
/**
 * Codec of the structure.
 */
export const SmartContractParameters: lib.CodecContainer<SmartContractParameters> = lib.defineCodec(lib.structCodec<SmartContractParameters>(['fuel', 'memory'], {fuel: lib.NonZero.with(lib.getCodec(lib.U64)), memory: lib.NonZero.with(lib.getCodec(lib.U64))}))

/**
 * Structure with named fields.
 */
export interface Parameters { sumeragi: SumeragiParameters, block: BlockParameters, transaction: TransactionParameters, executor: SmartContractParameters, smartContract: SmartContractParameters, custom: lib.BTreeMap<CustomParameterId, CustomParameter> }
/**
 * Codec of the structure.
 */
export const Parameters: lib.CodecContainer<Parameters> = lib.defineCodec(lib.structCodec<Parameters>(['sumeragi', 'block', 'transaction', 'executor', 'smartContract', 'custom'], {sumeragi: lib.getCodec(SumeragiParameters), block: lib.getCodec(BlockParameters), transaction: lib.getCodec(TransactionParameters), executor: lib.getCodec(SmartContractParameters), smartContract: lib.getCodec(SmartContractParameters), custom: lib.BTreeMap.with(lib.getCodec(CustomParameterId), lib.getCodec(CustomParameter))}))

/**
 * Structure with named fields.
 */
export interface Pagination { limit: lib.Option<lib.NonZero<lib.U64>>, offset: lib.U64 }
/**
 * Codec of the structure.
 */
export const Pagination: lib.CodecContainer<Pagination> = lib.defineCodec(lib.structCodec<Pagination>(['limit', 'offset'], {limit: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U64))), offset: lib.getCodec(lib.U64)}))

/**
 * Structure with named fields.
 */
export interface SocketAddrV4 { ip: Ipv4Addr, port: lib.U16 }
/**
 * Codec of the structure.
 */
export const SocketAddrV4: lib.CodecContainer<SocketAddrV4> = lib.defineCodec(lib.structCodec<SocketAddrV4>(['ip', 'port'], {ip: lib.getCodec(Ipv4Addr), port: lib.getCodec(lib.U16)}))

/**
 * Structure with named fields.
 */
export interface SocketAddrV6 { ip: Ipv6Addr, port: lib.U16 }
/**
 * Codec of the structure.
 */
export const SocketAddrV6: lib.CodecContainer<SocketAddrV6> = lib.defineCodec(lib.structCodec<SocketAddrV6>(['ip', 'port'], {ip: lib.getCodec(Ipv6Addr), port: lib.getCodec(lib.U16)}))

/**
 * Structure with named fields.
 */
export interface SocketAddrHost { host: lib.String, port: lib.U16 }
/**
 * Codec of the structure.
 */
export const SocketAddrHost: lib.CodecContainer<SocketAddrHost> = lib.defineCodec(lib.structCodec<SocketAddrHost>(['host', 'port'], {host: lib.getCodec(lib.String), port: lib.getCodec(lib.U16)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Ipv4`
 * - `Ipv6`
 * - `Host`
 * 
 * TODO how to construct, how to use
 */
export type SocketAddr = lib.Variant<'Ipv4', SocketAddrV4> | lib.Variant<'Ipv6', SocketAddrV6> | lib.Variant<'Host', SocketAddrHost>
/**
 * Codec and constructors for enumeration {@link SocketAddr}.
 */
export const SocketAddr: lib.CodecContainer<SocketAddr> & { Ipv4: <const T extends SocketAddrV4>(value: T) => lib.Variant<'Ipv4', T>, Ipv6: <const T extends SocketAddrV6>(value: T) => lib.Variant<'Ipv6', T>, Host: <const T extends SocketAddrHost>(value: T) => lib.Variant<'Host', T> } = { ...{ Ipv4: <const T extends SocketAddrV4>(value: T): lib.Variant<'Ipv4', T> => ({ kind: 'Ipv4', value }), Ipv6: <const T extends SocketAddrV6>(value: T): lib.Variant<'Ipv6', T> => ({ kind: 'Ipv6', value }), Host: <const T extends SocketAddrHost>(value: T): lib.Variant<'Host', T> => ({ kind: 'Host', value }) }, ...lib.defineCodec(lib.enumCodec<{ Ipv4: [SocketAddrV4], Ipv6: [SocketAddrV6], Host: [SocketAddrHost] }>({ Ipv4: [0, lib.getCodec(SocketAddrV4)], Ipv6: [1, lib.getCodec(SocketAddrV6)], Host: [2, lib.getCodec(SocketAddrHost)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface Peer { address: SocketAddr, id: PeerId }
/**
 * Codec of the structure.
 */
export const Peer: lib.CodecContainer<Peer> = lib.defineCodec(lib.structCodec<Peer>(['address', 'id'], {address: lib.getCodec(SocketAddr), id: lib.getCodec(PeerId)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `PublicKey`
 * 
 * TODO how to construct, how to use
 */
export type PeerIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'PublicKey', PublicKeyProjectionSelector>
/**
 * Codec and constructors for enumeration {@link PeerIdProjectionSelector}.
 */
export const PeerIdProjectionSelector: lib.CodecContainer<PeerIdProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, PublicKey: { Atom: lib.Variant<'PublicKey', lib.VariantUnit<'Atom'>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), PublicKey: { Atom: Object.freeze<lib.Variant<'PublicKey', lib.VariantUnit<'Atom'>>>({ kind: 'PublicKey', value: PublicKeyProjectionSelector.Atom }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], PublicKey: [PublicKeyProjectionSelector] }>({ Atom: [0], PublicKey: [1, lib.getCodec(PublicKeyProjectionSelector)] }).discriminated()) }

/**
 * This type could not be constructed.
 * 
 * It is a enumeration without any variants that could be created _at this time_. However,
 * in future it is possible that this type will be extended with actual constructable variants.
 */
export type PermissionPredicateAtom = never
/**
 * Codec for {@link PermissionPredicateAtom}. 
 * 
 * Since the type is `never`, this codec does nothing and throws an error if actually called.
 */
export const PermissionPredicateAtom: lib.CodecContainer<never> = lib.defineCodec(lib.neverCodec)

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * 
 * TODO how to construct, how to use
 */
export type PermissionProjectionSelector = lib.VariantUnit<'Atom'>
/**
 * Codec and constructors for enumeration {@link PermissionProjectionSelector}.
 */
export const PermissionProjectionSelector: lib.CodecContainer<PermissionProjectionSelector> & { Atom: lib.VariantUnit<'Atom'> } = { ...{ Atom: Object.freeze({ kind: 'Atom' }) }, ...lib.defineCodec(lib.enumCodec<{ Atom: [] }>({ Atom: [0] }).discriminated()) }

/**
 * Structure with named fields and generic parameters.
 */
export interface QueryWithFilter<T0, T1, T2> { query: T0, predicate: T1, selector: T2 }
/**
 * Codec constructor for the structure with generic parameters.
 */
export const QueryWithFilter = { /**
 * Create a codec with the actual codecs for generic parameters.
 */
with: <T0, T1, T2>(t0: lib.GenCodec<T0>, t1: lib.GenCodec<T1>, t2: lib.GenCodec<T2>): lib.GenCodec<QueryWithFilter<T0, T1, T2>> => lib.structCodec<QueryWithFilter<T0, T1, T2>>(['query', 'predicate', 'selector'], {query: t0, predicate: t1, selector: t2}) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */
export type RoleIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Name', NameProjectionSelector>
/**
 * Codec and constructors for enumeration {@link RoleIdProjectionSelector}.
 */
export const RoleIdProjectionSelector: lib.CodecContainer<RoleIdProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Name: { Atom: lib.Variant<'Name', lib.VariantUnit<'Atom'>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Name: { Atom: Object.freeze<lib.Variant<'Name', lib.VariantUnit<'Atom'>>>({ kind: 'Name', value: NameProjectionSelector.Atom }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Name: [NameProjectionSelector] }>({ Atom: [0], Name: [1, lib.getCodec(NameProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * 
 * TODO how to construct, how to use
 */
export type RoleProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', RoleIdProjectionSelector>
/**
 * Codec and constructors for enumeration {@link RoleProjectionSelector}.
 */
export const RoleProjectionSelector: lib.CodecContainer<RoleProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Id: { Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>, Name: { Atom: lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>> } } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Id: { Atom: Object.freeze<lib.Variant<'Id', lib.VariantUnit<'Atom'>>>({ kind: 'Id', value: RoleIdProjectionSelector.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: RoleIdProjectionSelector.Name.Atom }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Id: [RoleIdProjectionSelector] }>({ Atom: [0], Id: [1, lib.getCodec(RoleIdProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Name`
 * 
 * TODO how to construct, how to use
 */
export type TriggerIdProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Name', NameProjectionSelector>
/**
 * Codec and constructors for enumeration {@link TriggerIdProjectionSelector}.
 */
export const TriggerIdProjectionSelector: lib.CodecContainer<TriggerIdProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Name: { Atom: lib.Variant<'Name', lib.VariantUnit<'Atom'>> } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Name: { Atom: Object.freeze<lib.Variant<'Name', lib.VariantUnit<'Atom'>>>({ kind: 'Name', value: NameProjectionSelector.Atom }) } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Name: [NameProjectionSelector] }>({ Atom: [0], Name: [1, lib.getCodec(NameProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Id`
 * - `Action`
 * 
 * TODO how to construct, how to use
 */
export type TriggerProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Id', TriggerIdProjectionSelector> | lib.Variant<'Action', ActionProjectionSelector>
/**
 * Codec and constructors for enumeration {@link TriggerProjectionSelector}.
 */
export const TriggerProjectionSelector: lib.CodecContainer<TriggerProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Id: { Atom: lib.Variant<'Id', lib.VariantUnit<'Atom'>>, Name: { Atom: lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>> } }, Action: { Atom: lib.Variant<'Action', lib.VariantUnit<'Atom'>>, Metadata: { Atom: lib.Variant<'Action', lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>>, Key: <const T extends MetadataKeyProjectionSelector>(value: T) => lib.Variant<'Action', lib.Variant<'Metadata', lib.Variant<'Key', T>>> } } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Id: { Atom: Object.freeze<lib.Variant<'Id', lib.VariantUnit<'Atom'>>>({ kind: 'Id', value: TriggerIdProjectionSelector.Atom }), Name: { Atom: Object.freeze<lib.Variant<'Id', lib.Variant<'Name', lib.VariantUnit<'Atom'>>>>({ kind: 'Id', value: TriggerIdProjectionSelector.Name.Atom }) } }, Action: { Atom: Object.freeze<lib.Variant<'Action', lib.VariantUnit<'Atom'>>>({ kind: 'Action', value: ActionProjectionSelector.Atom }), Metadata: { Atom: Object.freeze<lib.Variant<'Action', lib.Variant<'Metadata', lib.VariantUnit<'Atom'>>>>({ kind: 'Action', value: ActionProjectionSelector.Metadata.Atom }), Key: <const T extends MetadataKeyProjectionSelector>(value: T): lib.Variant<'Action', lib.Variant<'Metadata', lib.Variant<'Key', T>>> => ({ kind: 'Action', value: ActionProjectionSelector.Metadata.Key(value) }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Id: [TriggerIdProjectionSelector], Action: [ActionProjectionSelector] }>({ Atom: [0], Id: [1, lib.getCodec(TriggerIdProjectionSelector)], Action: [2, lib.getCodec(ActionProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Atom`
 * - `Header`
 * 
 * TODO how to construct, how to use
 */
export type SignedBlockProjectionSelector = lib.VariantUnit<'Atom'> | lib.Variant<'Header', BlockHeaderProjectionSelector>
/**
 * Codec and constructors for enumeration {@link SignedBlockProjectionSelector}.
 */
export const SignedBlockProjectionSelector: lib.CodecContainer<SignedBlockProjectionSelector> & { Atom: lib.VariantUnit<'Atom'>, Header: { Atom: lib.Variant<'Header', lib.VariantUnit<'Atom'>>, Hash: { Atom: lib.Variant<'Header', lib.Variant<'Hash', lib.VariantUnit<'Atom'>>> } } } = { ...{ Atom: Object.freeze({ kind: 'Atom' }), Header: { Atom: Object.freeze<lib.Variant<'Header', lib.VariantUnit<'Atom'>>>({ kind: 'Header', value: BlockHeaderProjectionSelector.Atom }), Hash: { Atom: Object.freeze<lib.Variant<'Header', lib.Variant<'Hash', lib.VariantUnit<'Atom'>>>>({ kind: 'Header', value: BlockHeaderProjectionSelector.Hash.Atom }) } } }, ...lib.defineCodec(lib.enumCodec<{ Atom: [], Header: [BlockHeaderProjectionSelector] }>({ Atom: [0], Header: [1, lib.getCodec(BlockHeaderProjectionSelector)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `FindDomains`
 * - `FindAccounts`
 * - `FindAssets`
 * - `FindAssetsDefinitions`
 * - `FindNfts`
 * - `FindRoles`
 * - `FindRoleIds`
 * - `FindPermissionsByAccountId`
 * - `FindRolesByAccountId`
 * - `FindAccountsWithAsset`
 * - `FindPeers`
 * - `FindActiveTriggerIds`
 * - `FindTriggers`
 * - `FindTransactions`
 * - `FindBlocks`
 * - `FindBlockHeaders`
 * 
 * TODO how to construct, how to use
 */
export type QueryBox = lib.Variant<'FindDomains', QueryWithFilter<null, lib.CompoundPredicate<DomainProjectionPredicate>, lib.Vec<DomainProjectionSelector>>> | lib.Variant<'FindAccounts', QueryWithFilter<null, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>> | lib.Variant<'FindAssets', QueryWithFilter<null, lib.CompoundPredicate<AssetProjectionPredicate>, lib.Vec<AssetProjectionSelector>>> | lib.Variant<'FindAssetsDefinitions', QueryWithFilter<null, lib.CompoundPredicate<AssetDefinitionProjectionPredicate>, lib.Vec<AssetDefinitionProjectionSelector>>> | lib.Variant<'FindNfts', QueryWithFilter<null, lib.CompoundPredicate<NftProjectionPredicate>, lib.Vec<NftProjectionSelector>>> | lib.Variant<'FindRoles', QueryWithFilter<null, lib.CompoundPredicate<RoleProjectionPredicate>, lib.Vec<RoleProjectionSelector>>> | lib.Variant<'FindRoleIds', QueryWithFilter<null, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>> | lib.Variant<'FindPermissionsByAccountId', QueryWithFilter<FindPermissionsByAccountId, lib.CompoundPredicate<PermissionProjectionPredicate>, lib.Vec<PermissionProjectionSelector>>> | lib.Variant<'FindRolesByAccountId', QueryWithFilter<FindRolesByAccountId, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>> | lib.Variant<'FindAccountsWithAsset', QueryWithFilter<FindAccountsWithAsset, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>> | lib.Variant<'FindPeers', QueryWithFilter<null, lib.CompoundPredicate<PeerIdProjectionPredicate>, lib.Vec<PeerIdProjectionSelector>>> | lib.Variant<'FindActiveTriggerIds', QueryWithFilter<null, lib.CompoundPredicate<TriggerIdProjectionPredicate>, lib.Vec<TriggerIdProjectionSelector>>> | lib.Variant<'FindTriggers', QueryWithFilter<null, lib.CompoundPredicate<TriggerProjectionPredicate>, lib.Vec<TriggerProjectionSelector>>> | lib.Variant<'FindTransactions', QueryWithFilter<null, lib.CompoundPredicate<CommittedTransactionProjectionPredicate>, lib.Vec<CommittedTransactionProjectionSelector>>> | lib.Variant<'FindBlocks', QueryWithFilter<null, lib.CompoundPredicate<SignedBlockProjectionPredicate>, lib.Vec<SignedBlockProjectionSelector>>> | lib.Variant<'FindBlockHeaders', QueryWithFilter<null, lib.CompoundPredicate<BlockHeaderProjectionPredicate>, lib.Vec<BlockHeaderProjectionSelector>>>
/**
 * Codec and constructors for enumeration {@link QueryBox}.
 */
export const QueryBox: lib.CodecContainer<QueryBox> & { FindDomains: <const T extends QueryWithFilter<null, lib.CompoundPredicate<DomainProjectionPredicate>, lib.Vec<DomainProjectionSelector>>>(value: T) => lib.Variant<'FindDomains', T>, FindAccounts: <const T extends QueryWithFilter<null, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>>(value: T) => lib.Variant<'FindAccounts', T>, FindAssets: <const T extends QueryWithFilter<null, lib.CompoundPredicate<AssetProjectionPredicate>, lib.Vec<AssetProjectionSelector>>>(value: T) => lib.Variant<'FindAssets', T>, FindAssetsDefinitions: <const T extends QueryWithFilter<null, lib.CompoundPredicate<AssetDefinitionProjectionPredicate>, lib.Vec<AssetDefinitionProjectionSelector>>>(value: T) => lib.Variant<'FindAssetsDefinitions', T>, FindNfts: <const T extends QueryWithFilter<null, lib.CompoundPredicate<NftProjectionPredicate>, lib.Vec<NftProjectionSelector>>>(value: T) => lib.Variant<'FindNfts', T>, FindRoles: <const T extends QueryWithFilter<null, lib.CompoundPredicate<RoleProjectionPredicate>, lib.Vec<RoleProjectionSelector>>>(value: T) => lib.Variant<'FindRoles', T>, FindRoleIds: <const T extends QueryWithFilter<null, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>>(value: T) => lib.Variant<'FindRoleIds', T>, FindPermissionsByAccountId: <const T extends QueryWithFilter<FindPermissionsByAccountId, lib.CompoundPredicate<PermissionProjectionPredicate>, lib.Vec<PermissionProjectionSelector>>>(value: T) => lib.Variant<'FindPermissionsByAccountId', T>, FindRolesByAccountId: <const T extends QueryWithFilter<FindRolesByAccountId, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>>(value: T) => lib.Variant<'FindRolesByAccountId', T>, FindAccountsWithAsset: <const T extends QueryWithFilter<FindAccountsWithAsset, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>>(value: T) => lib.Variant<'FindAccountsWithAsset', T>, FindPeers: <const T extends QueryWithFilter<null, lib.CompoundPredicate<PeerIdProjectionPredicate>, lib.Vec<PeerIdProjectionSelector>>>(value: T) => lib.Variant<'FindPeers', T>, FindActiveTriggerIds: <const T extends QueryWithFilter<null, lib.CompoundPredicate<TriggerIdProjectionPredicate>, lib.Vec<TriggerIdProjectionSelector>>>(value: T) => lib.Variant<'FindActiveTriggerIds', T>, FindTriggers: <const T extends QueryWithFilter<null, lib.CompoundPredicate<TriggerProjectionPredicate>, lib.Vec<TriggerProjectionSelector>>>(value: T) => lib.Variant<'FindTriggers', T>, FindTransactions: <const T extends QueryWithFilter<null, lib.CompoundPredicate<CommittedTransactionProjectionPredicate>, lib.Vec<CommittedTransactionProjectionSelector>>>(value: T) => lib.Variant<'FindTransactions', T>, FindBlocks: <const T extends QueryWithFilter<null, lib.CompoundPredicate<SignedBlockProjectionPredicate>, lib.Vec<SignedBlockProjectionSelector>>>(value: T) => lib.Variant<'FindBlocks', T>, FindBlockHeaders: <const T extends QueryWithFilter<null, lib.CompoundPredicate<BlockHeaderProjectionPredicate>, lib.Vec<BlockHeaderProjectionSelector>>>(value: T) => lib.Variant<'FindBlockHeaders', T> } = { ...{ FindDomains: <const T extends QueryWithFilter<null, lib.CompoundPredicate<DomainProjectionPredicate>, lib.Vec<DomainProjectionSelector>>>(value: T): lib.Variant<'FindDomains', T> => ({ kind: 'FindDomains', value }), FindAccounts: <const T extends QueryWithFilter<null, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>>(value: T): lib.Variant<'FindAccounts', T> => ({ kind: 'FindAccounts', value }), FindAssets: <const T extends QueryWithFilter<null, lib.CompoundPredicate<AssetProjectionPredicate>, lib.Vec<AssetProjectionSelector>>>(value: T): lib.Variant<'FindAssets', T> => ({ kind: 'FindAssets', value }), FindAssetsDefinitions: <const T extends QueryWithFilter<null, lib.CompoundPredicate<AssetDefinitionProjectionPredicate>, lib.Vec<AssetDefinitionProjectionSelector>>>(value: T): lib.Variant<'FindAssetsDefinitions', T> => ({ kind: 'FindAssetsDefinitions', value }), FindNfts: <const T extends QueryWithFilter<null, lib.CompoundPredicate<NftProjectionPredicate>, lib.Vec<NftProjectionSelector>>>(value: T): lib.Variant<'FindNfts', T> => ({ kind: 'FindNfts', value }), FindRoles: <const T extends QueryWithFilter<null, lib.CompoundPredicate<RoleProjectionPredicate>, lib.Vec<RoleProjectionSelector>>>(value: T): lib.Variant<'FindRoles', T> => ({ kind: 'FindRoles', value }), FindRoleIds: <const T extends QueryWithFilter<null, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>>(value: T): lib.Variant<'FindRoleIds', T> => ({ kind: 'FindRoleIds', value }), FindPermissionsByAccountId: <const T extends QueryWithFilter<FindPermissionsByAccountId, lib.CompoundPredicate<PermissionProjectionPredicate>, lib.Vec<PermissionProjectionSelector>>>(value: T): lib.Variant<'FindPermissionsByAccountId', T> => ({ kind: 'FindPermissionsByAccountId', value }), FindRolesByAccountId: <const T extends QueryWithFilter<FindRolesByAccountId, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>>(value: T): lib.Variant<'FindRolesByAccountId', T> => ({ kind: 'FindRolesByAccountId', value }), FindAccountsWithAsset: <const T extends QueryWithFilter<FindAccountsWithAsset, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>>(value: T): lib.Variant<'FindAccountsWithAsset', T> => ({ kind: 'FindAccountsWithAsset', value }), FindPeers: <const T extends QueryWithFilter<null, lib.CompoundPredicate<PeerIdProjectionPredicate>, lib.Vec<PeerIdProjectionSelector>>>(value: T): lib.Variant<'FindPeers', T> => ({ kind: 'FindPeers', value }), FindActiveTriggerIds: <const T extends QueryWithFilter<null, lib.CompoundPredicate<TriggerIdProjectionPredicate>, lib.Vec<TriggerIdProjectionSelector>>>(value: T): lib.Variant<'FindActiveTriggerIds', T> => ({ kind: 'FindActiveTriggerIds', value }), FindTriggers: <const T extends QueryWithFilter<null, lib.CompoundPredicate<TriggerProjectionPredicate>, lib.Vec<TriggerProjectionSelector>>>(value: T): lib.Variant<'FindTriggers', T> => ({ kind: 'FindTriggers', value }), FindTransactions: <const T extends QueryWithFilter<null, lib.CompoundPredicate<CommittedTransactionProjectionPredicate>, lib.Vec<CommittedTransactionProjectionSelector>>>(value: T): lib.Variant<'FindTransactions', T> => ({ kind: 'FindTransactions', value }), FindBlocks: <const T extends QueryWithFilter<null, lib.CompoundPredicate<SignedBlockProjectionPredicate>, lib.Vec<SignedBlockProjectionSelector>>>(value: T): lib.Variant<'FindBlocks', T> => ({ kind: 'FindBlocks', value }), FindBlockHeaders: <const T extends QueryWithFilter<null, lib.CompoundPredicate<BlockHeaderProjectionPredicate>, lib.Vec<BlockHeaderProjectionSelector>>>(value: T): lib.Variant<'FindBlockHeaders', T> => ({ kind: 'FindBlockHeaders', value }) }, ...lib.defineCodec(lib.enumCodec<{ FindDomains: [QueryWithFilter<null, lib.CompoundPredicate<DomainProjectionPredicate>, lib.Vec<DomainProjectionSelector>>], FindAccounts: [QueryWithFilter<null, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>], FindAssets: [QueryWithFilter<null, lib.CompoundPredicate<AssetProjectionPredicate>, lib.Vec<AssetProjectionSelector>>], FindAssetsDefinitions: [QueryWithFilter<null, lib.CompoundPredicate<AssetDefinitionProjectionPredicate>, lib.Vec<AssetDefinitionProjectionSelector>>], FindNfts: [QueryWithFilter<null, lib.CompoundPredicate<NftProjectionPredicate>, lib.Vec<NftProjectionSelector>>], FindRoles: [QueryWithFilter<null, lib.CompoundPredicate<RoleProjectionPredicate>, lib.Vec<RoleProjectionSelector>>], FindRoleIds: [QueryWithFilter<null, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>], FindPermissionsByAccountId: [QueryWithFilter<FindPermissionsByAccountId, lib.CompoundPredicate<PermissionProjectionPredicate>, lib.Vec<PermissionProjectionSelector>>], FindRolesByAccountId: [QueryWithFilter<FindRolesByAccountId, lib.CompoundPredicate<RoleIdProjectionPredicate>, lib.Vec<RoleIdProjectionSelector>>], FindAccountsWithAsset: [QueryWithFilter<FindAccountsWithAsset, lib.CompoundPredicate<AccountProjectionPredicate>, lib.Vec<AccountProjectionSelector>>], FindPeers: [QueryWithFilter<null, lib.CompoundPredicate<PeerIdProjectionPredicate>, lib.Vec<PeerIdProjectionSelector>>], FindActiveTriggerIds: [QueryWithFilter<null, lib.CompoundPredicate<TriggerIdProjectionPredicate>, lib.Vec<TriggerIdProjectionSelector>>], FindTriggers: [QueryWithFilter<null, lib.CompoundPredicate<TriggerProjectionPredicate>, lib.Vec<TriggerProjectionSelector>>], FindTransactions: [QueryWithFilter<null, lib.CompoundPredicate<CommittedTransactionProjectionPredicate>, lib.Vec<CommittedTransactionProjectionSelector>>], FindBlocks: [QueryWithFilter<null, lib.CompoundPredicate<SignedBlockProjectionPredicate>, lib.Vec<SignedBlockProjectionSelector>>], FindBlockHeaders: [QueryWithFilter<null, lib.CompoundPredicate<BlockHeaderProjectionPredicate>, lib.Vec<BlockHeaderProjectionSelector>>] }>({ FindDomains: [0, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(DomainProjectionPredicate)), lib.Vec.with(lib.getCodec(DomainProjectionSelector)))], FindAccounts: [1, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(AccountProjectionPredicate)), lib.Vec.with(lib.getCodec(AccountProjectionSelector)))], FindAssets: [2, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(AssetProjectionPredicate)), lib.Vec.with(lib.getCodec(AssetProjectionSelector)))], FindAssetsDefinitions: [3, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(AssetDefinitionProjectionPredicate)), lib.Vec.with(lib.getCodec(AssetDefinitionProjectionSelector)))], FindNfts: [4, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(NftProjectionPredicate)), lib.Vec.with(lib.getCodec(NftProjectionSelector)))], FindRoles: [5, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(RoleProjectionPredicate)), lib.Vec.with(lib.getCodec(RoleProjectionSelector)))], FindRoleIds: [6, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(RoleIdProjectionPredicate)), lib.Vec.with(lib.getCodec(RoleIdProjectionSelector)))], FindPermissionsByAccountId: [7, QueryWithFilter.with(lib.getCodec(FindPermissionsByAccountId), lib.CompoundPredicate.with(lib.getCodec(PermissionProjectionPredicate)), lib.Vec.with(lib.getCodec(PermissionProjectionSelector)))], FindRolesByAccountId: [8, QueryWithFilter.with(lib.getCodec(FindRolesByAccountId), lib.CompoundPredicate.with(lib.getCodec(RoleIdProjectionPredicate)), lib.Vec.with(lib.getCodec(RoleIdProjectionSelector)))], FindAccountsWithAsset: [9, QueryWithFilter.with(lib.getCodec(FindAccountsWithAsset), lib.CompoundPredicate.with(lib.getCodec(AccountProjectionPredicate)), lib.Vec.with(lib.getCodec(AccountProjectionSelector)))], FindPeers: [10, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(PeerIdProjectionPredicate)), lib.Vec.with(lib.getCodec(PeerIdProjectionSelector)))], FindActiveTriggerIds: [11, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(TriggerIdProjectionPredicate)), lib.Vec.with(lib.getCodec(TriggerIdProjectionSelector)))], FindTriggers: [12, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(TriggerProjectionPredicate)), lib.Vec.with(lib.getCodec(TriggerProjectionSelector)))], FindTransactions: [13, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(CommittedTransactionProjectionPredicate)), lib.Vec.with(lib.getCodec(CommittedTransactionProjectionSelector)))], FindBlocks: [14, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(SignedBlockProjectionPredicate)), lib.Vec.with(lib.getCodec(SignedBlockProjectionSelector)))], FindBlockHeaders: [15, QueryWithFilter.with(lib.nullCodec, lib.CompoundPredicate.with(lib.getCodec(BlockHeaderProjectionPredicate)), lib.Vec.with(lib.getCodec(BlockHeaderProjectionSelector)))] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `PublicKey`
 * - `String`
 * - `Metadata`
 * - `Json`
 * - `Numeric`
 * - `Name`
 * - `DomainId`
 * - `Domain`
 * - `AccountId`
 * - `Account`
 * - `AssetId`
 * - `Asset`
 * - `AssetDefinitionId`
 * - `AssetDefinition`
 * - `NftId`
 * - `Nft`
 * - `Role`
 * - `Parameter`
 * - `Permission`
 * - `CommittedTransaction`
 * - `SignedTransaction`
 * - `TransactionHash`
 * - `TransactionRejectionReason`
 * - `Peer`
 * - `RoleId`
 * - `TriggerId`
 * - `Trigger`
 * - `Action`
 * - `Block`
 * - `BlockHeader`
 * - `BlockHeaderHash`
 * 
 * TODO how to construct, how to use
 */
export type QueryOutputBatchBox = lib.Variant<'PublicKey', lib.Vec<lib.PublicKey>> | lib.Variant<'String', lib.Vec<lib.String>> | lib.Variant<'Metadata', lib.Vec<Metadata>> | lib.Variant<'Json', lib.Vec<lib.Json>> | lib.Variant<'Numeric', lib.Vec<Numeric>> | lib.Variant<'Name', lib.Vec<lib.Name>> | lib.Variant<'DomainId', lib.Vec<lib.DomainId>> | lib.Variant<'Domain', lib.Vec<Domain>> | lib.Variant<'AccountId', lib.Vec<lib.AccountId>> | lib.Variant<'Account', lib.Vec<Account>> | lib.Variant<'AssetId', lib.Vec<lib.AssetId>> | lib.Variant<'Asset', lib.Vec<Asset>> | lib.Variant<'AssetDefinitionId', lib.Vec<lib.AssetDefinitionId>> | lib.Variant<'AssetDefinition', lib.Vec<AssetDefinition>> | lib.Variant<'NftId', lib.Vec<lib.NftId>> | lib.Variant<'Nft', lib.Vec<Nft>> | lib.Variant<'Role', lib.Vec<Role>> | lib.Variant<'Parameter', lib.Vec<Parameter>> | lib.Variant<'Permission', lib.Vec<Permission>> | lib.Variant<'CommittedTransaction', lib.Vec<CommittedTransaction>> | lib.Variant<'SignedTransaction', lib.Vec<SignedTransaction>> | lib.Variant<'TransactionHash', lib.Vec<lib.Hash>> | lib.Variant<'TransactionRejectionReason', lib.Vec<lib.Option<TransactionRejectionReason>>> | lib.Variant<'Peer', lib.Vec<PeerId>> | lib.Variant<'RoleId', lib.Vec<RoleId>> | lib.Variant<'TriggerId', lib.Vec<TriggerId>> | lib.Variant<'Trigger', lib.Vec<Trigger>> | lib.Variant<'Action', lib.Vec<Action>> | lib.Variant<'Block', lib.Vec<SignedBlock>> | lib.Variant<'BlockHeader', lib.Vec<BlockHeader>> | lib.Variant<'BlockHeaderHash', lib.Vec<lib.Hash>>
/**
 * Codec and constructors for enumeration {@link QueryOutputBatchBox}.
 */
export const QueryOutputBatchBox: lib.CodecContainer<QueryOutputBatchBox> & { PublicKey: <const T extends lib.Vec<lib.PublicKey>>(value: T) => lib.Variant<'PublicKey', T>, String: <const T extends lib.Vec<lib.String>>(value: T) => lib.Variant<'String', T>, Metadata: <const T extends lib.Vec<Metadata>>(value: T) => lib.Variant<'Metadata', T>, Json: <const T extends lib.Vec<lib.Json>>(value: T) => lib.Variant<'Json', T>, Numeric: <const T extends lib.Vec<Numeric>>(value: T) => lib.Variant<'Numeric', T>, Name: <const T extends lib.Vec<lib.Name>>(value: T) => lib.Variant<'Name', T>, DomainId: <const T extends lib.Vec<lib.DomainId>>(value: T) => lib.Variant<'DomainId', T>, Domain: <const T extends lib.Vec<Domain>>(value: T) => lib.Variant<'Domain', T>, AccountId: <const T extends lib.Vec<lib.AccountId>>(value: T) => lib.Variant<'AccountId', T>, Account: <const T extends lib.Vec<Account>>(value: T) => lib.Variant<'Account', T>, AssetId: <const T extends lib.Vec<lib.AssetId>>(value: T) => lib.Variant<'AssetId', T>, Asset: <const T extends lib.Vec<Asset>>(value: T) => lib.Variant<'Asset', T>, AssetDefinitionId: <const T extends lib.Vec<lib.AssetDefinitionId>>(value: T) => lib.Variant<'AssetDefinitionId', T>, AssetDefinition: <const T extends lib.Vec<AssetDefinition>>(value: T) => lib.Variant<'AssetDefinition', T>, NftId: <const T extends lib.Vec<lib.NftId>>(value: T) => lib.Variant<'NftId', T>, Nft: <const T extends lib.Vec<Nft>>(value: T) => lib.Variant<'Nft', T>, Role: <const T extends lib.Vec<Role>>(value: T) => lib.Variant<'Role', T>, Parameter: <const T extends lib.Vec<Parameter>>(value: T) => lib.Variant<'Parameter', T>, Permission: <const T extends lib.Vec<Permission>>(value: T) => lib.Variant<'Permission', T>, CommittedTransaction: <const T extends lib.Vec<CommittedTransaction>>(value: T) => lib.Variant<'CommittedTransaction', T>, SignedTransaction: <const T extends lib.Vec<SignedTransaction>>(value: T) => lib.Variant<'SignedTransaction', T>, TransactionHash: <const T extends lib.Vec<lib.Hash>>(value: T) => lib.Variant<'TransactionHash', T>, TransactionRejectionReason: <const T extends lib.Vec<lib.Option<TransactionRejectionReason>>>(value: T) => lib.Variant<'TransactionRejectionReason', T>, Peer: <const T extends lib.Vec<PeerId>>(value: T) => lib.Variant<'Peer', T>, RoleId: <const T extends lib.Vec<RoleId>>(value: T) => lib.Variant<'RoleId', T>, TriggerId: <const T extends lib.Vec<TriggerId>>(value: T) => lib.Variant<'TriggerId', T>, Trigger: <const T extends lib.Vec<Trigger>>(value: T) => lib.Variant<'Trigger', T>, Action: <const T extends lib.Vec<Action>>(value: T) => lib.Variant<'Action', T>, Block: <const T extends lib.Vec<SignedBlock>>(value: T) => lib.Variant<'Block', T>, BlockHeader: <const T extends lib.Vec<BlockHeader>>(value: T) => lib.Variant<'BlockHeader', T>, BlockHeaderHash: <const T extends lib.Vec<lib.Hash>>(value: T) => lib.Variant<'BlockHeaderHash', T> } = { ...{ PublicKey: <const T extends lib.Vec<lib.PublicKey>>(value: T): lib.Variant<'PublicKey', T> => ({ kind: 'PublicKey', value }), String: <const T extends lib.Vec<lib.String>>(value: T): lib.Variant<'String', T> => ({ kind: 'String', value }), Metadata: <const T extends lib.Vec<Metadata>>(value: T): lib.Variant<'Metadata', T> => ({ kind: 'Metadata', value }), Json: <const T extends lib.Vec<lib.Json>>(value: T): lib.Variant<'Json', T> => ({ kind: 'Json', value }), Numeric: <const T extends lib.Vec<Numeric>>(value: T): lib.Variant<'Numeric', T> => ({ kind: 'Numeric', value }), Name: <const T extends lib.Vec<lib.Name>>(value: T): lib.Variant<'Name', T> => ({ kind: 'Name', value }), DomainId: <const T extends lib.Vec<lib.DomainId>>(value: T): lib.Variant<'DomainId', T> => ({ kind: 'DomainId', value }), Domain: <const T extends lib.Vec<Domain>>(value: T): lib.Variant<'Domain', T> => ({ kind: 'Domain', value }), AccountId: <const T extends lib.Vec<lib.AccountId>>(value: T): lib.Variant<'AccountId', T> => ({ kind: 'AccountId', value }), Account: <const T extends lib.Vec<Account>>(value: T): lib.Variant<'Account', T> => ({ kind: 'Account', value }), AssetId: <const T extends lib.Vec<lib.AssetId>>(value: T): lib.Variant<'AssetId', T> => ({ kind: 'AssetId', value }), Asset: <const T extends lib.Vec<Asset>>(value: T): lib.Variant<'Asset', T> => ({ kind: 'Asset', value }), AssetDefinitionId: <const T extends lib.Vec<lib.AssetDefinitionId>>(value: T): lib.Variant<'AssetDefinitionId', T> => ({ kind: 'AssetDefinitionId', value }), AssetDefinition: <const T extends lib.Vec<AssetDefinition>>(value: T): lib.Variant<'AssetDefinition', T> => ({ kind: 'AssetDefinition', value }), NftId: <const T extends lib.Vec<lib.NftId>>(value: T): lib.Variant<'NftId', T> => ({ kind: 'NftId', value }), Nft: <const T extends lib.Vec<Nft>>(value: T): lib.Variant<'Nft', T> => ({ kind: 'Nft', value }), Role: <const T extends lib.Vec<Role>>(value: T): lib.Variant<'Role', T> => ({ kind: 'Role', value }), Parameter: <const T extends lib.Vec<Parameter>>(value: T): lib.Variant<'Parameter', T> => ({ kind: 'Parameter', value }), Permission: <const T extends lib.Vec<Permission>>(value: T): lib.Variant<'Permission', T> => ({ kind: 'Permission', value }), CommittedTransaction: <const T extends lib.Vec<CommittedTransaction>>(value: T): lib.Variant<'CommittedTransaction', T> => ({ kind: 'CommittedTransaction', value }), SignedTransaction: <const T extends lib.Vec<SignedTransaction>>(value: T): lib.Variant<'SignedTransaction', T> => ({ kind: 'SignedTransaction', value }), TransactionHash: <const T extends lib.Vec<lib.Hash>>(value: T): lib.Variant<'TransactionHash', T> => ({ kind: 'TransactionHash', value }), TransactionRejectionReason: <const T extends lib.Vec<lib.Option<TransactionRejectionReason>>>(value: T): lib.Variant<'TransactionRejectionReason', T> => ({ kind: 'TransactionRejectionReason', value }), Peer: <const T extends lib.Vec<PeerId>>(value: T): lib.Variant<'Peer', T> => ({ kind: 'Peer', value }), RoleId: <const T extends lib.Vec<RoleId>>(value: T): lib.Variant<'RoleId', T> => ({ kind: 'RoleId', value }), TriggerId: <const T extends lib.Vec<TriggerId>>(value: T): lib.Variant<'TriggerId', T> => ({ kind: 'TriggerId', value }), Trigger: <const T extends lib.Vec<Trigger>>(value: T): lib.Variant<'Trigger', T> => ({ kind: 'Trigger', value }), Action: <const T extends lib.Vec<Action>>(value: T): lib.Variant<'Action', T> => ({ kind: 'Action', value }), Block: <const T extends lib.Vec<SignedBlock>>(value: T): lib.Variant<'Block', T> => ({ kind: 'Block', value }), BlockHeader: <const T extends lib.Vec<BlockHeader>>(value: T): lib.Variant<'BlockHeader', T> => ({ kind: 'BlockHeader', value }), BlockHeaderHash: <const T extends lib.Vec<lib.Hash>>(value: T): lib.Variant<'BlockHeaderHash', T> => ({ kind: 'BlockHeaderHash', value }) }, ...lib.defineCodec(lib.enumCodec<{ PublicKey: [lib.Vec<lib.PublicKey>], String: [lib.Vec<lib.String>], Metadata: [lib.Vec<Metadata>], Json: [lib.Vec<lib.Json>], Numeric: [lib.Vec<Numeric>], Name: [lib.Vec<lib.Name>], DomainId: [lib.Vec<lib.DomainId>], Domain: [lib.Vec<Domain>], AccountId: [lib.Vec<lib.AccountId>], Account: [lib.Vec<Account>], AssetId: [lib.Vec<lib.AssetId>], Asset: [lib.Vec<Asset>], AssetDefinitionId: [lib.Vec<lib.AssetDefinitionId>], AssetDefinition: [lib.Vec<AssetDefinition>], NftId: [lib.Vec<lib.NftId>], Nft: [lib.Vec<Nft>], Role: [lib.Vec<Role>], Parameter: [lib.Vec<Parameter>], Permission: [lib.Vec<Permission>], CommittedTransaction: [lib.Vec<CommittedTransaction>], SignedTransaction: [lib.Vec<SignedTransaction>], TransactionHash: [lib.Vec<lib.Hash>], TransactionRejectionReason: [lib.Vec<lib.Option<TransactionRejectionReason>>], Peer: [lib.Vec<PeerId>], RoleId: [lib.Vec<RoleId>], TriggerId: [lib.Vec<TriggerId>], Trigger: [lib.Vec<Trigger>], Action: [lib.Vec<Action>], Block: [lib.Vec<SignedBlock>], BlockHeader: [lib.Vec<BlockHeader>], BlockHeaderHash: [lib.Vec<lib.Hash>] }>({ PublicKey: [0, lib.Vec.with(lib.getCodec(lib.PublicKey))], String: [1, lib.Vec.with(lib.getCodec(lib.String))], Metadata: [2, lib.Vec.with(lib.getCodec(Metadata))], Json: [3, lib.Vec.with(lib.getCodec(lib.Json))], Numeric: [4, lib.Vec.with(lib.getCodec(Numeric))], Name: [5, lib.Vec.with(lib.getCodec(lib.Name))], DomainId: [6, lib.Vec.with(lib.getCodec(lib.DomainId))], Domain: [7, lib.Vec.with(lib.getCodec(Domain))], AccountId: [8, lib.Vec.with(lib.getCodec(lib.AccountId))], Account: [9, lib.Vec.with(lib.getCodec(Account))], AssetId: [10, lib.Vec.with(lib.getCodec(lib.AssetId))], Asset: [11, lib.Vec.with(lib.getCodec(Asset))], AssetDefinitionId: [12, lib.Vec.with(lib.getCodec(lib.AssetDefinitionId))], AssetDefinition: [13, lib.Vec.with(lib.getCodec(AssetDefinition))], NftId: [14, lib.Vec.with(lib.getCodec(lib.NftId))], Nft: [15, lib.Vec.with(lib.getCodec(Nft))], Role: [16, lib.Vec.with(lib.getCodec(Role))], Parameter: [17, lib.Vec.with(lib.getCodec(Parameter))], Permission: [18, lib.Vec.with(lib.getCodec(Permission))], CommittedTransaction: [19, lib.Vec.with(lib.getCodec(CommittedTransaction))], SignedTransaction: [20, lib.Vec.with(lib.getCodec(SignedTransaction))], TransactionHash: [21, lib.Vec.with(lib.getCodec(lib.Hash))], TransactionRejectionReason: [22, lib.Vec.with(lib.Option.with(lib.getCodec(TransactionRejectionReason)))], Peer: [23, lib.Vec.with(lib.getCodec(PeerId))], RoleId: [24, lib.Vec.with(lib.getCodec(RoleId))], TriggerId: [25, lib.Vec.with(lib.getCodec(TriggerId))], Trigger: [26, lib.Vec.with(lib.getCodec(Trigger))], Action: [27, lib.Vec.with(lib.getCodec(Action))], Block: [28, lib.Vec.with(lib.getCodec(SignedBlock))], BlockHeader: [29, lib.Vec.with(lib.getCodec(BlockHeader))], BlockHeaderHash: [30, lib.Vec.with(lib.getCodec(lib.Hash))] }).discriminated()) }

export type QueryOutputBatchBoxTuple = lib.Vec<QueryOutputBatchBox>
export const QueryOutputBatchBoxTuple: lib.CodecContainer<QueryOutputBatchBoxTuple> = lib.defineCodec(lib.Vec.with(lib.getCodec(QueryOutputBatchBox)))

/**
 * Structure with named fields.
 */
export interface QueryOutput { batch: QueryOutputBatchBoxTuple, remainingItems: lib.U64, continueCursor: lib.Option<ForwardCursor> }
/**
 * Codec of the structure.
 */
export const QueryOutput: lib.CodecContainer<QueryOutput> = lib.defineCodec(lib.structCodec<QueryOutput>(['batch', 'remainingItems', 'continueCursor'], {batch: lib.getCodec(QueryOutputBatchBoxTuple), remainingItems: lib.getCodec(lib.U64), continueCursor: lib.Option.with(lib.getCodec(ForwardCursor))}))

/**
 * Structure with named fields.
 */
export interface Sorting { sortByMetadataKey: lib.Option<lib.Name> }
/**
 * Codec of the structure.
 */
export const Sorting: lib.CodecContainer<Sorting> = lib.defineCodec(lib.structCodec<Sorting>(['sortByMetadataKey'], {sortByMetadataKey: lib.Option.with(lib.getCodec(lib.Name))}))

/**
 * Structure with named fields.
 */
export interface QueryParams { pagination: Pagination, sorting: Sorting, fetchSize: lib.Option<lib.NonZero<lib.U64>> }
/**
 * Codec of the structure.
 */
export const QueryParams: lib.CodecContainer<QueryParams> = lib.defineCodec(lib.structCodec<QueryParams>(['pagination', 'sorting', 'fetchSize'], {pagination: lib.getCodec(Pagination), sorting: lib.getCodec(Sorting), fetchSize: lib.Option.with(lib.NonZero.with(lib.getCodec(lib.U64)))}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `FindExecutorDataModel`
 * - `FindParameters`
 * 
 * TODO how to construct, how to use
 */
export type SingularQueryBox = lib.VariantUnit<'FindExecutorDataModel'> | lib.VariantUnit<'FindParameters'>
/**
 * Codec and constructors for enumeration {@link SingularQueryBox}.
 */
export const SingularQueryBox: lib.CodecContainer<SingularQueryBox> & { FindExecutorDataModel: lib.VariantUnit<'FindExecutorDataModel'>, FindParameters: lib.VariantUnit<'FindParameters'> } = { ...{ FindExecutorDataModel: Object.freeze({ kind: 'FindExecutorDataModel' }), FindParameters: Object.freeze({ kind: 'FindParameters' }) }, ...lib.defineCodec(lib.enumCodec<{ FindExecutorDataModel: [], FindParameters: [] }>({ FindExecutorDataModel: [0], FindParameters: [1] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface QueryWithParams { query: QueryBox, params: QueryParams }
/**
 * Codec of the structure.
 */
export const QueryWithParams: lib.CodecContainer<QueryWithParams> = lib.defineCodec(lib.structCodec<QueryWithParams>(['query', 'params'], {query: lib.getCodec(QueryBox), params: lib.getCodec(QueryParams)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Singular`
 * - `Start`
 * - `Continue`
 * 
 * TODO how to construct, how to use
 */
export type QueryRequest = lib.Variant<'Singular', SingularQueryBox> | lib.Variant<'Start', QueryWithParams> | lib.Variant<'Continue', ForwardCursor>
/**
 * Codec and constructors for enumeration {@link QueryRequest}.
 */
export const QueryRequest: lib.CodecContainer<QueryRequest> & { Singular: { FindExecutorDataModel: lib.Variant<'Singular', lib.VariantUnit<'FindExecutorDataModel'>>, FindParameters: lib.Variant<'Singular', lib.VariantUnit<'FindParameters'>> }, Start: <const T extends QueryWithParams>(value: T) => lib.Variant<'Start', T>, Continue: <const T extends ForwardCursor>(value: T) => lib.Variant<'Continue', T> } = { ...{ Singular: { FindExecutorDataModel: Object.freeze<lib.Variant<'Singular', lib.VariantUnit<'FindExecutorDataModel'>>>({ kind: 'Singular', value: SingularQueryBox.FindExecutorDataModel }), FindParameters: Object.freeze<lib.Variant<'Singular', lib.VariantUnit<'FindParameters'>>>({ kind: 'Singular', value: SingularQueryBox.FindParameters }) }, Start: <const T extends QueryWithParams>(value: T): lib.Variant<'Start', T> => ({ kind: 'Start', value }), Continue: <const T extends ForwardCursor>(value: T): lib.Variant<'Continue', T> => ({ kind: 'Continue', value }) }, ...lib.defineCodec(lib.enumCodec<{ Singular: [SingularQueryBox], Start: [QueryWithParams], Continue: [ForwardCursor] }>({ Singular: [0, lib.getCodec(SingularQueryBox)], Start: [1, lib.getCodec(QueryWithParams)], Continue: [2, lib.getCodec(ForwardCursor)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface QueryRequestWithAuthority { authority: lib.AccountId, request: QueryRequest }
/**
 * Codec of the structure.
 */
export const QueryRequestWithAuthority: lib.CodecContainer<QueryRequestWithAuthority> = lib.defineCodec(lib.structCodec<QueryRequestWithAuthority>(['authority', 'request'], {authority: lib.getCodec(lib.AccountId), request: lib.getCodec(QueryRequest)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `ExecutorDataModel`
 * - `Parameters`
 * 
 * TODO how to construct, how to use
 */
export type SingularQueryOutputBox = lib.Variant<'ExecutorDataModel', ExecutorDataModel> | lib.Variant<'Parameters', Parameters>
/**
 * Codec and constructors for enumeration {@link SingularQueryOutputBox}.
 */
export const SingularQueryOutputBox: lib.CodecContainer<SingularQueryOutputBox> & { ExecutorDataModel: <const T extends ExecutorDataModel>(value: T) => lib.Variant<'ExecutorDataModel', T>, Parameters: <const T extends Parameters>(value: T) => lib.Variant<'Parameters', T> } = { ...{ ExecutorDataModel: <const T extends ExecutorDataModel>(value: T): lib.Variant<'ExecutorDataModel', T> => ({ kind: 'ExecutorDataModel', value }), Parameters: <const T extends Parameters>(value: T): lib.Variant<'Parameters', T> => ({ kind: 'Parameters', value }) }, ...lib.defineCodec(lib.enumCodec<{ ExecutorDataModel: [ExecutorDataModel], Parameters: [Parameters] }>({ ExecutorDataModel: [0, lib.getCodec(ExecutorDataModel)], Parameters: [1, lib.getCodec(Parameters)] }).discriminated()) }

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `Singular`
 * - `Iterable`
 * 
 * TODO how to construct, how to use
 */
export type QueryResponse = lib.Variant<'Singular', SingularQueryOutputBox> | lib.Variant<'Iterable', QueryOutput>
/**
 * Codec and constructors for enumeration {@link QueryResponse}.
 */
export const QueryResponse: lib.CodecContainer<QueryResponse> & { Singular: { ExecutorDataModel: <const T extends ExecutorDataModel>(value: T) => lib.Variant<'Singular', lib.Variant<'ExecutorDataModel', T>>, Parameters: <const T extends Parameters>(value: T) => lib.Variant<'Singular', lib.Variant<'Parameters', T>> }, Iterable: <const T extends QueryOutput>(value: T) => lib.Variant<'Iterable', T> } = { ...{ Singular: { ExecutorDataModel: <const T extends ExecutorDataModel>(value: T): lib.Variant<'Singular', lib.Variant<'ExecutorDataModel', T>> => ({ kind: 'Singular', value: SingularQueryOutputBox.ExecutorDataModel(value) }), Parameters: <const T extends Parameters>(value: T): lib.Variant<'Singular', lib.Variant<'Parameters', T>> => ({ kind: 'Singular', value: SingularQueryOutputBox.Parameters(value) }) }, Iterable: <const T extends QueryOutput>(value: T): lib.Variant<'Iterable', T> => ({ kind: 'Iterable', value }) }, ...lib.defineCodec(lib.enumCodec<{ Singular: [SingularQueryOutputBox], Iterable: [QueryOutput] }>({ Singular: [0, lib.getCodec(SingularQueryOutputBox)], Iterable: [1, lib.getCodec(QueryOutput)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface RawGenesisTransaction { chain: ChainId, executor: lib.String, parameters: lib.Option<Parameters>, instructions: lib.Vec<InstructionBox>, wasmDir: lib.String, wasmTriggers: lib.Vec<GenesisWasmTrigger>, topology: lib.Vec<PeerId> }
/**
 * Codec of the structure.
 */
export const RawGenesisTransaction: lib.CodecContainer<RawGenesisTransaction> = lib.defineCodec(lib.structCodec<RawGenesisTransaction>(['chain', 'executor', 'parameters', 'instructions', 'wasmDir', 'wasmTriggers', 'topology'], {chain: lib.getCodec(ChainId), executor: lib.getCodec(lib.String), parameters: lib.Option.with(lib.getCodec(Parameters)), instructions: lib.Vec.with(lib.lazyCodec(() => lib.getCodec(InstructionBox))), wasmDir: lib.getCodec(lib.String), wasmTriggers: lib.Vec.with(lib.getCodec(GenesisWasmTrigger)), topology: lib.Vec.with(lib.getCodec(PeerId))}))

/**
 * Structure with named fields.
 */
export interface SignedQueryV1 { signature: lib.Signature, payload: QueryRequestWithAuthority }
/**
 * Codec of the structure.
 */
export const SignedQueryV1: lib.CodecContainer<SignedQueryV1> = lib.defineCodec(lib.structCodec<SignedQueryV1>(['signature', 'payload'], {signature: lib.getCodec(lib.Signature), payload: lib.getCodec(QueryRequestWithAuthority)}))

/**
 * Enumeration (discriminated union). Represented as one of the following variants:
 * 
 * - `V1`
 * 
 * TODO how to construct, how to use
 */
export type SignedQuery = lib.Variant<'V1', SignedQueryV1>
/**
 * Codec and constructors for enumeration {@link SignedQuery}.
 */
export const SignedQuery: lib.CodecContainer<SignedQuery> & { V1: <const T extends SignedQueryV1>(value: T) => lib.Variant<'V1', T> } = { ...{ V1: <const T extends SignedQueryV1>(value: T): lib.Variant<'V1', T> => ({ kind: 'V1', value }) }, ...lib.defineCodec(lib.enumCodec<{ V1: [SignedQueryV1] }>({ V1: [1, lib.getCodec(SignedQueryV1)] }).discriminated()) }

/**
 * Structure with named fields.
 */
export interface Uptime { secs: lib.Compact, nanos: lib.U32 }
/**
 * Codec of the structure.
 */
export const Uptime: lib.CodecContainer<Uptime> = lib.defineCodec(lib.structCodec<Uptime>(['secs', 'nanos'], {secs: lib.getCodec(lib.Compact), nanos: lib.getCodec(lib.U32)}))

/**
 * Structure with named fields.
 */
export interface Status { peers: lib.Compact, blocks: lib.Compact, blocksNonEmpty: lib.Compact, txsApproved: lib.Compact, txsRejected: lib.Compact, uptime: Uptime, viewChanges: lib.Compact, queueSize: lib.Compact }
/**
 * Codec of the structure.
 */
export const Status: lib.CodecContainer<Status> = lib.defineCodec(lib.structCodec<Status>(['peers', 'blocks', 'blocksNonEmpty', 'txsApproved', 'txsRejected', 'uptime', 'viewChanges', 'queueSize'], {peers: lib.getCodec(lib.Compact), blocks: lib.getCodec(lib.Compact), blocksNonEmpty: lib.getCodec(lib.Compact), txsApproved: lib.getCodec(lib.Compact), txsRejected: lib.getCodec(lib.Compact), uptime: lib.getCodec(Uptime), viewChanges: lib.getCodec(lib.Compact), queueSize: lib.getCodec(lib.Compact)}))
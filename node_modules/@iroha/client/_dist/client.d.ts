import type { PrivateKey } from "@jsr/iroha__core/crypto";
import * as types from "@jsr/iroha__core/data-model";
import type { Except } from "type-fest";
import { type TransactionPayloadParams } from "@jsr/iroha__core";
import { type Fetch, MainAPI } from "./api.js";
import { type SetupBlocksStreamParams, type SetupBlocksStreamReturn, type SetupEventsParams, type SetupEventsReturn, WebSocketAPI } from "./api-ws.js";
import type { IsomorphicWebSocketAdapter } from "./web-socket/mod.js";
import { FindAPI } from "./find-api.generated.js";
export { FindAPI };
export interface CreateClientParams {
  /**
   * Custom {@linkcode fetch} for environments where it is not available natively.
   */ fetch?: Fetch;
  /**
   * WebSocket adapter. For environments where {@linkcode WebSocket} is not available natively.
   */ ws?: IsomorphicWebSocketAdapter;
  /**
   * The base URL of **Torii**, Iroha API Gateway.
   */ toriiBaseURL: URL;
  /**
   * Chain ID.
   */ chain: string;
  /**
   * Authority on which behalf to sign transactions and queries.
   */ authority: types.AccountId;
  /**
   * The private key of {@linkcode CreateClientParams.authority}.
   */ authorityPrivateKey: types.PrivateKey;
}
export interface SubmitParams {
  /**
   * Whether to wait for the transaction to be accepted/rejected/expired.
   * @default false
   */ verify?: boolean;
  verifyAbort?: AbortSignal;
}
export declare class TransactionRejectedError extends Error {
  public reason: types.TransactionRejectionReason;
  public constructor(reason: types.TransactionRejectionReason);
}
export declare class TransactionExpiredError extends Error {
  public constructor();
}
/**
 * All-in-one Iroha client.
 *
 * Through it, it is possible to perform all different kinds of interactions with Iroha, e.g.
 * signing and submitting transactions and queries or listening to events through WebSockets.
 *
 * It is possible to use each layer of functionality separately, through lower-level layers:
 *
 * - {@linkcode MainAPI}
 * - {@linkcode WebSocketAPI}
 *
 * It could be useful if e.g. you don't need to submit transactions (which requires an account with a key pair),
 * but only want to check Iroha status.
 */ export declare class Client {
  public readonly params: CreateClientParams;
  /**
   * Lower-level API calls.
   */ public readonly api: MainAPI;
  /**
   * Lower-level WebSocket API calls.
   */ public readonly socket: WebSocketAPI;
  /**
   * Shortcuts for querying data from Iroha
   */ public readonly find: FindAPI;
  public constructor(params: CreateClientParams);
  public get authority(): types.AccountId;
  public get authorityPrivateKey(): PrivateKey;
  /**
   * Create a transaction.
   *
   * @param executable the executable of the transactions
   * @param params parameters to adjust the constructed transaction payload
   * @returns the handle to perform further operations, such as computing transaction's hash or submitting it to Iroha.
   */ public transaction(executable: types.Executable, params?: Except<TransactionPayloadParams, 'authority' | 'chain'>): TransactionHandle;
  /**
   * Receive events from Iroha in real time.
   */ public events(params?: SetupEventsParams): Promise<SetupEventsReturn>;
  /**
   * Receive blocks from Iroha in real time.
   */ public blocks(params?: SetupBlocksStreamParams): Promise<SetupBlocksStreamReturn>;
}
export declare class TransactionHandle {
  private readonly client: any;
  private readonly tx: any;
  private readonly txHash: any;
  public constructor(tx: types.SignedTransaction, client: Client);
  public get hash(): types.Hash;
  public submit(params?: SubmitParams): Promise<void>;
}
//# sourceMappingURL=client.d.ts.map
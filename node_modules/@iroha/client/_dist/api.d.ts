import { type Variant, type VariantUnit } from "@jsr/iroha__core";
import * as dm from "@jsr/iroha__core/data-model";
import type { Schema as DataModelSchema } from "@jsr/iroha__core/data-model/schema";
import type { PartialDeep } from "type-fest";
/**
 * Peer information returned from {@link TelemetryAPI.peers}
 */ export interface PeerJson {
  /**
   * Socket address of the peer
   */ address: string;
  /**
   * Peer public key
   */ id: dm.PublicKey;
}
export type PeerGetConfig = {
  logger: {
    level: dm.Level['kind'];
    /**
     * Filter directives, e.g. `info,iroha_core=debug`.
     */ filter: string;
  };
  network: {
    blockGossipPeriod: dm.Duration;
    blockGossipSize: number;
    transactionGossipPeriod: dm.Duration;
    transactionGossipSize: number;
  };
  publicKey: dm.PublicKey;
  queue: {
    capacity: number;
  };
};
export type PeerSetConfig = PartialDeep<Pick<PeerGetConfig, 'logger'>>;
export type Fetch = typeof fetch;
export type HealthResult = VariantUnit<'healthy'> | Variant<'error', unknown>;
export declare class ResponseError extends Error {
  public static assertStatus(response: Response, status: number): Promise<void>;
  public constructor(response: Response, message: string);
}
/**
 * Adapter for HTTP requests made by various methods.
 */ export declare class HttpTransport {
  public readonly toriiBaseURL: URL;
  private readonly fetch: any;
  /**
   * @param toriiBaseURL URL of Torii (Iroha API Gateway)
   * @param fetch `fetch` implementation for environments where it is not available natively.
   * For example, you might need to use `node-fetch` or `undici` in older versions of Node.js.
   */ public constructor(toriiBaseURL: URL, fetch?: Fetch);
  public getFetch(): Fetch;
}
/**
 * Lower-level client to interact with Iroha HTTP APIs.
 *
 * It is separated from {@linkcode WebSocketAPI}.
 *
 * It is lower-level in a sense that, for example, {@linkcode MainAPI#transaction} accepts an already signed transaction
 * and simply "fire and forget"s it, while {@linkcode Client#transaction} helps to construct a transaction, submit it,
 * and verify that it is accepted.
 */ export declare class MainAPI {
  /**
   * Works only if Iroha is compiled with `telemetry` feature flag.
   */ public readonly telemetry: TelemetryAPI;
  private readonly http: any;
  public constructor(http: HttpTransport);
  public health(): Promise<HealthResult>;
  public transaction(transaction: dm.SignedTransaction): Promise<void>;
  public query(query: dm.SignedQuery): Promise<dm.QueryResponse>;
  public getConfig(): Promise<PeerGetConfig>;
  public setConfig(config: PeerSetConfig): Promise<void>;
  /**
   * Will only work if Iroha is compiled with `schema` feature enabled.
   */ public schema(): Promise<DataModelSchema>;
}
export declare class QueryValidationError extends Error {
  public reason: dm.ValidationFail;
  public constructor(reason: dm.ValidationFail);
}
export declare class TelemetryAPI {
  private readonly http: any;
  public constructor(http: HttpTransport);
  public status(): Promise<dm.Status>;
  public peers(): Promise<PeerJson[]>;
  public metrics(): Promise<string>;
}
//# sourceMappingURL=api.d.ts.map
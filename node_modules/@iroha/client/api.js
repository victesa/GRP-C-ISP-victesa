import { assert } from "@jsr/std__assert";
import { getCodec } from "@jsr/iroha__core";
import * as dm from "@jsr/iroha__core/data-model";
import { ENDPOINT_CONFIGURATION, ENDPOINT_HEALTH, ENDPOINT_METRICS, ENDPOINT_PEERS, ENDPOINT_QUERY, ENDPOINT_SCHEMA, ENDPOINT_STATUS, ENDPOINT_TRANSACTION, HEALTHY_RESPONSE } from "./const.js";
import { urlJoinPath } from "./util.js";
export class ResponseError extends Error {
  static async assertStatus(response, status) {
    if (response.status !== status) {
      let message = 'got an error response';
      if (/text\/plain/.test(response.headers.get('content-type') ?? '')) {
        message = await response.text();
      }
      throw new ResponseError(response, message);
    }
  }
  constructor(response, message){
    super(`${response.status} (${response.statusText}): ${message}`);
  }
}
/**
 * Adapter for HTTP requests made by various methods.
 */ export class HttpTransport {
  toriiBaseURL;
  fetch;
  /**
   * @param toriiBaseURL URL of Torii (Iroha API Gateway)
   * @param fetch `fetch` implementation for environments where it is not available natively.
   * For example, you might need to use `node-fetch` or `undici` in older versions of Node.js.
   */ constructor(toriiBaseURL, fetch){
    this.toriiBaseURL = toriiBaseURL;
    this.fetch = fetch ?? globalThis.fetch;
  }
  getFetch() {
    // this is needed to avoid an issue when `Window.fetch` is called with `this` object not being `Window`
    return this.fetch;
  }
}
/**
 * Lower-level client to interact with Iroha HTTP APIs.
 *
 * It is separated from {@linkcode WebSocketAPI}.
 *
 * It is lower-level in a sense that, for example, {@linkcode MainAPI#transaction} accepts an already signed transaction
 * and simply "fire and forget"s it, while {@linkcode Client#transaction} helps to construct a transaction, submit it,
 * and verify that it is accepted.
 */ export class MainAPI {
  /**
   * Works only if Iroha is compiled with `telemetry` feature flag.
   */ telemetry;
  http;
  constructor(http){
    this.http = http;
    this.telemetry = new TelemetryAPI(http);
  }
  async health() {
    let response;
    try {
      response = await this.http.getFetch()(urlJoinPath(this.http.toriiBaseURL, ENDPOINT_HEALTH));
    } catch (err) {
      return {
        kind: 'error',
        value: err
      };
    }
    await ResponseError.assertStatus(response, 200);
    const text = await response.text();
    if (text !== HEALTHY_RESPONSE) {
      return {
        kind: 'error',
        value: new Error(`Expected '${HEALTHY_RESPONSE}' response; got: '${text}'`)
      };
    }
    return {
      kind: 'healthy'
    };
  }
  async transaction(transaction) {
    const body = getCodec(dm.SignedTransaction).encode(transaction);
    const response = await this.http.getFetch()(urlJoinPath(this.http.toriiBaseURL, ENDPOINT_TRANSACTION), {
      body,
      method: 'POST'
    });
    await ResponseError.assertStatus(response, 200);
  }
  async query(query) {
    return this.http.getFetch()(urlJoinPath(this.http.toriiBaseURL, ENDPOINT_QUERY), {
      method: 'POST',
      body: getCodec(dm.SignedQuery).encode(query)
    }).then(handleQueryResponse);
  }
  async getConfig() {
    const response = await this.http.getFetch()(urlJoinPath(this.http.toriiBaseURL, ENDPOINT_CONFIGURATION));
    await ResponseError.assertStatus(response, 200);
    // TODO: use schema parser e.g. zod?
    const raw = await response.json();
    return {
      publicKey: dm.PublicKey.fromMultihash(raw.public_key),
      logger: raw.logger,
      network: {
        blockGossipSize: raw.network.block_gossip_size,
        blockGossipPeriod: dm.Duration.fromMillis(raw.network.block_gossip_period_ms),
        transactionGossipSize: raw.network.transaction_gossip_size,
        transactionGossipPeriod: dm.Duration.fromMillis(raw.network.transaction_gossip_period_ms)
      },
      queue: raw.queue
    };
  }
  async setConfig(config) {
    const response = await this.http.getFetch()(urlJoinPath(this.http.toriiBaseURL, ENDPOINT_CONFIGURATION), {
      method: 'POST',
      body: JSON.stringify(config),
      headers: {
        'Content-Type': 'application/json'
      }
    });
    await ResponseError.assertStatus(response, 202 /* ACCEPTED */ );
  }
  /**
   * Will only work if Iroha is compiled with `schema` feature enabled.
   */ async schema() {
    const response = await this.http.getFetch()(urlJoinPath(this.http.toriiBaseURL, ENDPOINT_SCHEMA));
    await ResponseError.assertStatus(response, 200);
    return response.json();
  }
}
async function handleQueryResponse(resp) {
  if (resp.status === 200) {
    const bytes = await resp.arrayBuffer();
    return getCodec(dm.QueryResponse).decode(new Uint8Array(bytes));
  } else if (resp.status >= 400 && resp.status < 500) {
    const bytes = await resp.arrayBuffer();
    const error = getCodec(dm.ValidationFail).decode(new Uint8Array(bytes));
    throw new QueryValidationError(error);
  }
  throw new Error(`unexpected response from Iroha: ${resp.status} ${resp.statusText}`);
}
export class QueryValidationError extends Error {
  reason;
  constructor(reason){
    super();
    this.name = 'QueryValidationError';
    this.reason = reason;
  }
}
// TODO: handle errors with a hint that Iroha might be not compiled with the needed features
export class TelemetryAPI {
  http;
  constructor(http){
    this.http = http;
  }
  async status() {
    const response = await this.http.getFetch()(urlJoinPath(this.http.toriiBaseURL, ENDPOINT_STATUS), {
      headers: {
        accept: 'application/x-parity-scale'
      }
    });
    await ResponseError.assertStatus(response, 200);
    return response.arrayBuffer().then((buffer)=>getCodec(dm.Status).decode(new Uint8Array(buffer)));
  }
  // TODO: move once metrics are updated
  async peers() {
    const response = await this.http.getFetch()(urlJoinPath(this.http.toriiBaseURL, ENDPOINT_PEERS));
    await ResponseError.assertStatus(response, 200);
    return response.json().then(// array of strings in format `<pub key multihash>@<socket addr>`
    (ids)=>{
      assert(Array.isArray(ids));
      return ids.map((id)=>{
        assert(typeof id === 'string');
        const [pubkey, address] = id.split('@');
        return {
          id: dm.PublicKey.fromMultihash(pubkey),
          address
        };
      });
    });
  }
  async metrics() {
    const response = await this.http.getFetch()(urlJoinPath(this.http.toriiBaseURL, ENDPOINT_METRICS));
    await ResponseError.assertStatus(response, 200);
    return response.text();
  }
}
//# sourceMappingURL=api.js.map
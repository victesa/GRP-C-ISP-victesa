import * as types from "@jsr/iroha__core/data-model";
import defer from "p-defer";
import { buildTransactionPayload, signTransaction, transactionHash } from "@jsr/iroha__core";
import { HttpTransport, MainAPI } from "./api.js";
import { WebSocketAPI } from "./api-ws.js";
import { FindAPI } from "./find-api.generated.js";
import { QueryExecutor } from "./query.js";
export { FindAPI };
export class TransactionRejectedError extends Error {
  reason;
  constructor(reason){
    super();
    this.name = 'TransactionRejectedError';
    this.reason = reason;
  }
}
export class TransactionExpiredError extends Error {
  constructor(){
    super();
    this.name = 'TransactionExpiredError';
  }
}
/**
 * All-in-one Iroha client.
 *
 * Through it, it is possible to perform all different kinds of interactions with Iroha, e.g.
 * signing and submitting transactions and queries or listening to events through WebSockets.
 *
 * It is possible to use each layer of functionality separately, through lower-level layers:
 *
 * - {@linkcode MainAPI}
 * - {@linkcode WebSocketAPI}
 *
 * It could be useful if e.g. you don't need to submit transactions (which requires an account with a key pair),
 * but only want to check Iroha status.
 */ export class Client {
  params;
  /**
   * Lower-level API calls.
   */ api;
  /**
   * Lower-level WebSocket API calls.
   */ socket;
  /**
   * Shortcuts for querying data from Iroha
   */ find;
  constructor(params){
    this.params = params;
    const http = new HttpTransport(params.toriiBaseURL, params.fetch);
    this.api = new MainAPI(http);
    const executor = new QueryExecutor(this.api, this.authority, this.authorityPrivateKey);
    this.find = new FindAPI(executor);
    this.socket = new WebSocketAPI(params.toriiBaseURL, params.ws);
  }
  get authority() {
    return this.params.authority;
  }
  get authorityPrivateKey() {
    return this.params.authorityPrivateKey;
  }
  /**
   * Create a transaction.
   *
   * @param executable the executable of the transactions
   * @param params parameters to adjust the constructed transaction payload
   * @returns the handle to perform further operations, such as computing transaction's hash or submitting it to Iroha.
   */ transaction(executable, params) {
    const tx = signTransaction(buildTransactionPayload(executable, {
      chain: this.params.chain,
      authority: this.authority,
      ...params
    }), this.authorityPrivateKey);
    return new TransactionHandle(tx, this);
  }
  /**
   * Receive events from Iroha in real time.
   */ async events(params) {
    return this.socket.events(params);
  }
  /**
   * Receive blocks from Iroha in real time.
   */ async blocks(params) {
    return this.socket.blocksStream(params);
  }
}
export class TransactionHandle {
  client;
  tx;
  txHash;
  constructor(tx, client){
    this.client = client;
    this.tx = tx;
    this.txHash = transactionHash(tx);
  }
  get hash() {
    return this.txHash;
  }
  async submit(params) {
    if (params?.verify) {
      // const hash = transactionHash(tx)
      const stream = await this.client.events({
        filters: [
          types.EventFilterBox.Pipeline.Transaction({
            hash: this.txHash,
            blockHeight: null,
            // TODO: include "status" when Iroha API is fixed about it
            // FIXME: Iroha design issue
            //   If I want to filter by "rejected" status, I will also have to include a rejection reason into the
            //   filter. I could imagine users wanting to just watch for rejections with all possible reasons.
            status: null
          })
        ]
      });
      // TODO: replace with Promise.withResolvers
      const confirmation = defer();
      stream.ee.on('event', (event)=>{
        if (event.kind === 'Pipeline' && event.value.kind === 'Transaction') {
          const txEvent = event.value.value;
          if (txEvent.status.kind === 'Approved') confirmation.resolve();
          else if (txEvent.status.kind === 'Rejected') {
            confirmation.reject(new TransactionRejectedError(txEvent.status.value));
          } else if (txEvent.status.kind === 'Expired') confirmation.reject(new TransactionExpiredError());
        }
      });
      stream.ee.on('close', ()=>{
        confirmation.reject(new Error('Events stream was unexpectedly closed'));
      });
      params.verifyAbort?.addEventListener('abort', ()=>{
        confirmation.reject(new Error('Aborted'));
      });
      try {
        await this.client.api.transaction(this.tx);
        await confirmation.promise;
      } finally{
        stream.stop();
      }
    } else {
      await this.client.api.transaction(this.tx);
    }
  }
}
//# sourceMappingURL=client.js.map
import * as dm from "@jsr/iroha__core/data-model";
import { getCodec } from "@jsr/iroha__core";
import { ENDPOINT_BLOCKS_STREAM, ENDPOINT_EVENTS } from "./const.js";
import { setupWebSocket } from "./util.js";
import { nativeWS } from "./web-socket/mod.js";
/**
 * Lower-level client
 */ export class WebSocketAPI {
  toriiBaseURL;
  adapter;
  /**
   * Create an instance.
   * @param toriiBaseURL Torii base URL
   * @param adapter A custom WebSocket adapter. Uses native by default.
   * See the {@linkcode [web-socket]} module for more details.
   */ constructor(toriiBaseURL, adapter){
    this.toriiBaseURL = toriiBaseURL;
    this.adapter = adapter ?? nativeWS;
  }
  async blocksStream(params) {
    const { ee, send: sendRaw, isClosed, close, accepted } = setupWebSocket({
      baseURL: this.toriiBaseURL,
      endpoint: ENDPOINT_BLOCKS_STREAM,
      adapter: this.adapter
    });
    ee.on('open', ()=>{
      sendRaw(getCodec(dm.BlockSubscriptionRequest).encode({
        fromBlockHeight: params?.fromBlockHeight?.map(BigInt) ?? new dm.NonZero(1n)
      }).buffer);
    });
    ee.on('message', (raw)=>{
      const block = getCodec(dm.SignedBlock).decode(raw);
      ee.emit('block', block);
    });
    await accepted();
    return {
      ee: // Emittery typing bug
      ee,
      stop: close,
      isClosed
    };
  }
  async events(params) {
    const { ee, isClosed, close, accepted, send: sendRaw } = setupWebSocket({
      baseURL: this.toriiBaseURL,
      endpoint: ENDPOINT_EVENTS,
      adapter: this.adapter
    });
    ee.on('open', ()=>{
      sendRaw(getCodec(dm.EventSubscriptionRequest).encode({
        filters: params?.filters ?? []
      }).buffer);
    });
    ee.on('message', (raw)=>{
      const event = getCodec(dm.EventBox).decode(raw);
      ee.emit('event', event);
    });
    await accepted();
    return {
      stop: close,
      ee: // Emittery typing bug :<
      ee,
      isClosed
    };
  }
}
//# sourceMappingURL=api-ws.js.map
import { QueryBuilder as BaseQueryBuilder, signQuery } from "@jsr/iroha__core";
import * as types from "@jsr/iroha__core/data-model";
import { assert } from "@jsr/std__assert";
export class QueryExecutor {
  api;
  authority;
  privateKey;
  constructor(api, authority, authorityPrivateKey){
    this.api = api;
    this.authority = authority;
    this.privateKey = authorityPrivateKey;
  }
  async *execute(query) {
    let continueCursor = null;
    do {
      const response = await this.api.query(this.signQuery(continueCursor ? types.QueryRequest.Continue(continueCursor) : types.QueryRequest.Start(query)));
      assert(response.kind === 'Iterable');
      yield response.value;
      continueCursor = response.value.continueCursor;
    }while (continueCursor)
  }
  async executeSingular(query) {
    const response = await this.api.query(this.signQuery({
      kind: 'Singular',
      value: query
    }));
    assert(response.kind === 'Singular');
    return response.value;
  }
  signQuery(request) {
    return signQuery({
      request,
      authority: this.authority
    }, this.privateKey);
  }
}
export class QueryBuilder extends BaseQueryBuilder {
  #executor;
  constructor(executor, ...args){
    // @ts-ignore causes `deno publish` to fail https://github.com/denoland/deno/issues/28472
    super(...args);
    this.#executor = executor;
  }
  selectWith(fn) {
    super.selectWith(fn);
    return this;
  }
  async executeAll() {
    const items = [];
    for await (const batch of this.batches()){
      items.push(...batch);
    }
    return items;
  }
  async executeSingle() {
    const items = await this.executeAll();
    if (items.length === 1) return items[0];
    throw new TypeError(`Expected query to return exactly one element, got ${items.length}`);
  }
  async executeSingleOpt() {
    const items = await this.executeAll();
    if (items.length <= 1) return items.at(0) ?? null;
    throw new TypeError(`Expected query to return one or non elements, got ${items.length}`);
  }
  async *batches() {
    for await (const { batch } of this.#executor.execute(this.build())){
      const items = [
        ...this.parseOutput(batch)
      ];
      yield items;
    }
  }
}
//# sourceMappingURL=query.js.map